{"id":"oc-1b7","title":"Missing providerDisplayName methods in TransformationEditorView","description":"## Problem\nTransformationEditorView.swift referenced two methods that didn't exist:\n- `providerDisplayName(for: LLMProviderKind)`\n- `providerDisplayName(forRawValue: String)`\n\nThis caused a compilation error preventing the project from building.\n\n## Root Cause\nIncomplete refactoring left broken code - the methods were called but never implemented.\n\n## Fix\n1. Added `displayName` computed property to `LLMProviderKind` enum in LLMProvider.swift\n2. Added the two helper methods to TransformationEditorView\n\n## Files Changed\n- Sources/OptimusClipCore/LLMClients/LLMProvider.swift\n- Sources/OptimusClip/Views/Settings/Transformations/TransformationEditorView.swift","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-16T19:04:34.408976-05:00","updated_at":"2025-12-16T20:35:11.304807-05:00","closed_at":"2025-12-16T20:35:11.304807-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:08:18.022459-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-1me","title":"SECURITY: EncryptedStorageService salt stored in UserDefaults","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-16T19:54:51.920413-05:00","updated_at":"2025-12-16T20:35:11.302443-05:00","closed_at":"2025-12-16T20:35:11.302443-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T20:05:29.855826-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-1u7","title":"Support AWS Bedrock inference profiles for newer models","description":"Newer AWS Bedrock models like Claude 3.5 Haiku require inference profiles instead of direct model IDs.\n\n## Problem\n- Claude 3.5 Haiku (anthropic.claude-3-5-haiku-20241022-v1:0) fails with: 'Invocation with on-demand throughput isn't supported'\n- These models require cross-region inference profiles\n\n## Solution\n- Detect models that require inference profiles\n- Automatically prefix with appropriate region (us.*, eu.*, global.*)\n- Or allow users to specify inference profile ARNs directly\n\n## References\n- https://docs.aws.amazon.com/bedrock/latest/userguide/inference-profiles.html","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-27T20:16:06.836023-05:00","created_by":"Chris Edwards","updated_at":"2025-12-27T20:20:41.485339-05:00","closed_at":"2025-12-27T20:20:41.485339-05:00","close_reason":"Implemented inference profile support - model IDs automatically prefixed with us./eu./apac. based on region"}
{"id":"oc-24d","title":"Add --unsigned mode to release.sh","description":"Add --unsigned flag to release.sh to enable GitHub releases without Apple Developer account. Creates ad-hoc signed builds that work (with Gatekeeper warning) for technical users.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-27T18:12:42.333995-05:00","created_by":"Chris Edwards","updated_at":"2025-12-27T18:14:04.088734-05:00","closed_at":"2025-12-27T18:14:04.088734-05:00","close_reason":"Closed","comments":[{"id":26,"issue_id":"oc-24d","author":"Chris Edwards","text":"Added --unsigned flag to release.sh. Builds ad-hoc signed release, creates GitHub release with zip/dSYM, updates appcast, tags and pushes. Users see Gatekeeper warning but can right-click \u003e Open. Sparkle auto-updates won't work without Developer ID. Commit: a34e2a1","created_at":"2025-12-27T23:13:56Z"}]}
{"id":"oc-370","title":"Add model selection to all LLM providers","description":"Add model selection dropdown to all LLM providers (OpenAI, Anthropic, OpenRouter, Ollama) following the pattern established by AWS Bedrock. Each provider should have a model dropdown with autocomplete and a Fetch button to dynamically load available models from the provider's API.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T19:47:25.361116-05:00","updated_at":"2025-12-14T20:22:26.391106-05:00","closed_at":"2025-12-14T20:22:26.391106-05:00"}
{"id":"oc-3bc","title":"REFACTOR: Extract views from ProviderSetupStepView.swift (file_length violation)","status":"closed","priority":3,"issue_type":"chore","created_at":"2025-12-16T20:04:16.120114-05:00","updated_at":"2025-12-16T20:34:18.096697-05:00","closed_at":"2025-12-16T20:34:18.096711-05:00"}
{"id":"oc-3oa","title":"Cannot set keyboard shortcut to Cmd+Option+V","description":"KeyboardShortcuts recorder allows setting shortcuts to other keys but blocks Cmd+Option+V (the default). Even after changing to another key combination, cannot change it back to Cmd+Option+V. The UI seems to treat this as a reserved/excluded combination.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-13T17:04:35.649733-05:00","updated_at":"2025-12-13T17:05:03.338769-05:00","closed_at":"2025-12-13T17:05:03.338769-05:00"}
{"id":"oc-411","title":"Fix SettingsKey.transformations dead code - update to match actual key used","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-16T19:20:55.507944-05:00","updated_at":"2025-12-16T19:23:00.122112-05:00","closed_at":"2025-12-16T19:23:00.122112-05:00","close_reason":"Fixed: renamed SettingsKey.transformations to transformationsData and updated all usages to reference the constant"}
{"id":"oc-4tw","title":"Epic: Phase 3 - Hotkeys \u0026 Settings","description":"# Epic: Phase 3 - Hotkeys \u0026 Settings\n\n## Background \u0026 Context\nThis epic represents Phase 3 of Optimus Clip's development roadmap. While Phase 1 established the core clipboard transformation engine and Phase 2 built the menu bar UI, Phase 3 completes the user experience by adding global hotkey support and a comprehensive settings interface.\n\nWHY THIS IS NEEDED:\n- Users need fast, keyboard-driven access to transformations without clicking through menus\n- Power users expect customizable hotkeys for their most-used transformations\n- API keys, model configurations, and preferences need a secure, discoverable place to live\n- The app needs proper macOS integration (launch at login, accessibility permissions)\n\n## Technical Architecture\nThis phase introduces three major architectural components:\n\n1. **Hotkey System**: Uses KeyboardShortcuts package for system-wide hotkey registration\n   - Integrates with macOS accessibility APIs for global event monitoring\n   - Maps custom shortcuts to transformation actions\n   - Handles conflicts and provides UI for recording new shortcuts\n\n2. **Settings Persistence Layer**: Multi-tiered storage strategy\n   - @AppStorage/UserDefaults for general preferences and transformation configs\n   - Keychain for secure credential storage (API keys)\n   - JSON encoding for complex transformation definitions\n\n3. **Settings UI**: Native SwiftUI tabbed interface\n   - Follows macOS HIG for settings windows\n   - Live validation and error states\n   - Reactive bindings to update app behavior in real-time\n\n## UI/UX Considerations\n- Settings window is modal and singleton (only one instance)\n- Hotkey conflicts are detected and prevented at registration time\n- Accessibility permission status is live-polled for immediate feedback\n- All changes take effect immediately (no Apply button needed)\n- Keyboard navigation fully supported throughout settings\n\n## Success Criteria\n- Users can assign custom hotkeys to any transformation\n- Hotkeys work globally regardless of focused application\n- Settings persist across app restarts\n- All major LLM providers can be configured\n- Accessibility permission flow is clear and actionable\n\n## Dependencies\nPhase 2 Epic must be complete (menu bar UI and basic transformations working)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-12T22:04:53.487469-05:00","updated_at":"2025-12-13T11:51:50.076713-05:00","closed_at":"2025-12-13T11:51:50.076713-05:00"}
{"id":"oc-4tw.1","title":"KeyboardShortcuts Integration","description":"BACKGROUND \u0026 CONTEXT:\nThe KeyboardShortcuts package by sindresorhus (17,000+ GitHub stars) is a battle-tested, production-ready Swift library that abstracts the complex low-level APIs required for global hotkey registration on macOS. Without this package, we would need to manually implement:\n- CGEvent tap creation and registration\n- Event mask configuration for key combinations\n- Conflict detection with system shortcuts\n- Accessibility permission handling\n- Carbon Event Manager integration (deprecated but sometimes needed)\n- Thread safety for event handlers\n\nThis package eliminates hundreds of lines of error-prone boilerplate and provides a SwiftUI-native API.\n\nWHY THIS PACKAGE SPECIFICALLY:\n- Native SwiftUI Recorder component (drop-in UI for recording shortcuts)\n- Automatic conflict detection (warns if shortcut conflicts with system)\n- Built-in persistence (shortcuts saved to UserDefaults automatically)\n- Accessibility permission handling (checks and prompts automatically)\n- Modern Swift concurrency support (@MainActor, async/await compatible)\n- Actively maintained (last update within 6 months)\n- Used by popular apps (Dato, Plash, many others)\n\nREAL-WORLD PROBLEM:\nWithout KeyboardShortcuts, implementing global hotkeys requires:\n1. Understanding CGEventTap API (complex, low-level)\n2. Converting keycodes to readable names (\"9 + 0x100000\" → \"Cmd+V\")\n3. Detecting conflicts manually (hard to get right)\n4. Building UI for recording shortcuts (complex state management)\n5. Handling edge cases (Fn key, function keys, media keys)\n\nThis package solves all of these problems in a single dependency.\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. ADD TO PACKAGE.SWIFT:\n```swift\ndependencies: [\n    .package(url: \"https://github.com/sindresorhus/KeyboardShortcuts\", from: \"2.0.0\"),\n],\ntargets: [\n    .executableTarget(\n        name: \"OptimusClip\",\n        dependencies: [\n            // ... other dependencies\n            \"KeyboardShortcuts\",\n        ]\n    ),\n]\n```\n\n2. DEFINE HOTKEY NAMES (One per transformation):\nCreate file: Sources/OptimusClip/HotkeyNames.swift\n\n```swift\nimport KeyboardShortcuts\n\nextension KeyboardShortcuts.Name {\n    // Built-in transformations\n    static let quickFix = Self(\"quickFix\", default: .init(.v, modifiers: [.command, .option]))\n    static let smartFix = Self(\"smartFix\", default: .init(.s, modifiers: [.command, .option]))\n    \n    // User-defined transformations (dynamic)\n    // Created at runtime via: KeyboardShortcuts.Name(\"user_\u003cuuid\u003e\")\n}\n```\n\n3. NAME REGISTRATION PATTERN:\n```swift\n// Static (built-in) transformations\nlet name = KeyboardShortcuts.Name.quickFix\n\n// Dynamic (user-created) transformations\nlet id = UUID().uuidString\nlet name = KeyboardShortcuts.Name(\"user_\\(id)\")\n```\n\n4. SET DEFAULT SHORTCUTS:\n```swift\n// In app initialization\nKeyboardShortcuts.setShortcut(.init(.v, modifiers: [.command, .option]), for: .quickFix)\nKeyboardShortcuts.setShortcut(.init(.s, modifiers: [.command, .option]), for: .smartFix)\n```\n\n5. PACKAGE FEATURES WE USE:\n- KeyboardShortcuts.Name: Type-safe shortcut identifiers\n- KeyboardShortcuts.Recorder: SwiftUI component for UI\n- KeyboardShortcuts.onKeyUp(for:): Register handlers\n- KeyboardShortcuts.getShortcut(for:): Read current shortcut\n- KeyboardShortcuts.setShortcut(_:for:): Programmatic assignment\n- KeyboardShortcuts.enable(_:): Enable individual shortcut\n- KeyboardShortcuts.disable(_:): Disable individual shortcut\n- KeyboardShortcuts.reset(_:): Clear shortcut\n\nARCHITECTURAL CONNECTIONS:\n- Foundation for HotkeyManager (oc-4tw.2)\n- Required by Hotkey Recorder Integration (oc-4tw.9)\n- Used by Transformations Tab UI (oc-4tw.4)\n- Enables entire Phase 3 functionality\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. ACCESSIBILITY PERMISSION:\n   - Package checks permission automatically\n   - Provides isAccessibilityAccessGranted property\n   - Does NOT auto-prompt (we handle that in Permissions Tab)\n   - Handlers won't fire without permission (silent failure)\n\n2. SYSTEM SHORTCUT CONFLICTS:\n   - Package detects conflicts with system shortcuts\n   - Recorder shows warning in UI automatically\n   - Shortcuts still register but may not fire\n   - User must choose different shortcut\n\n3. APP SHORTCUT CONFLICTS:\n   - Package does NOT detect conflicts between our own shortcuts\n   - Must manually check before registering\n   - Two transformations can't have same shortcut\n\n4. PERSISTENCE:\n   - Package stores shortcuts in UserDefaults automatically\n   - Key format: \"KeyboardShortcuts_\u003cname\u003e\"\n   - We don't need to handle persistence manually\n   - Survives app restarts automatically\n\n5. DYNAMIC NAME CREATION:\n   - Names must be created at compile time for static shortcuts\n   - Runtime names work but need careful lifecycle management\n   - Don't create Names repeatedly (memory leak)\n   - Cache Name instances in TransformationConfig\n\n6. UNICODE IN NAMES:\n   - Name identifiers should be ASCII-safe\n   - Use UUID or slug for user transformations\n   - Display name can have Unicode (separate property)\n\nTESTING REQUIREMENTS:\n- Verify package resolves via swift package resolve\n- Test default shortcuts register on first launch\n- Test shortcut persistence across restarts\n- Test conflict detection (try Cmd+Q, Cmd+C)\n- Test without accessibility permission (no crash)\n- Test with accessibility permission (handlers fire)\n- Test multiple shortcuts registered simultaneously\n- Verify memory doesn't leak with dynamic Names\n\nSUCCESS CRITERIA:\n- Package added to Package.swift\n- swift build succeeds\n- KeyboardShortcuts.Name extensions defined\n- Default shortcuts set for built-in transformations\n- HotkeyManager can register handlers\n- Recorder component imports successfully\n- No crashes without accessibility permission\n\nCONFIGURATION OPTIONS:\n- Default shortcuts (configurable per transformation)\n- Name identifiers (static for built-in, dynamic for user)\n- No package-level configuration needed\n\nPERFORMANCE CONSIDERATIONS:\n- Package uses efficient CGEvent tap (minimal overhead)\n- Event handlers run on main thread (use async for work)\n- Name creation is cheap but should be cached\n- No performance impact when accessibility disabled\n\nSECURITY CONSIDERATIONS:\n- Requires Accessibility permission (user must grant)\n- Cannot capture shortcuts in secure input fields (system limitation)\n- Shortcuts stored in UserDefaults (not encrypted, but low risk)\n- Package is open source (auditable)\n\nIMPLEMENTATION ORDER:\n1. Add package dependency to Package.swift\n2. Create HotkeyNames.swift with Name extensions\n3. Set default shortcuts in app initialization\n4. Verify shortcuts register (use print() in handlers)\n5. Move to HotkeyManager implementation (oc-4tw.2)\n\nPACKAGE DOCUMENTATION:\n- README: https://github.com/sindresorhus/KeyboardShortcuts\n- API docs included in package\n- Example apps in repository\n\nPRIORITY: P2 (Required for Phase 3, but after clipboard foundation from Phase 2)\n\nESTIMATED TIME: 30-45 minutes (mostly reading docs and integration)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:20.310618-05:00","updated_at":"2025-12-13T10:09:43.163294-05:00","closed_at":"2025-12-13T10:09:43.163294-05:00","dependencies":[{"issue_id":"oc-4tw.1","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-13T09:39:51.565031-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-4tw.10","title":"Phase 3 Verification","description":"BACKGROUND \u0026 CONTEXT:\nPhase 3 Verification is the comprehensive end-to-end testing checklist that confirms ALL Phase 3 functionality is working correctly before proceeding to Phase 4 (Transformation Engine). This is a CRITICAL milestone because Phase 3 lays the foundation for all user interaction:\n- Hotkey infrastructure\n- Settings UI\n- Permission management\n- Data persistence\n\nIf Phase 3 is incomplete or buggy, all subsequent phases will be built on a shaky foundation. This verification task ensures that doesn't happen.\n\nThe verification checklist is organized by component and includes:\n- Functional tests (does it work?)\n- Integration tests (do components work together?)\n- Edge case tests (what breaks it?)\n- Performance tests (is it fast enough?)\n- UX tests (is it pleasant to use?)\n\nThis is NOT unit testing (that's continuous throughout development). This is ACCEPTANCE testing - the final gate before phase completion.\n\nREAL-WORLD PROBLEM/USE CASE:\nDeveloper completing Phase 3:\n1. Implements all tasks (oc-4tw.1 through oc-4tw.9)\n2. Each component works in isolation\n3. Ready to move to Phase 4\n4. BUT: Haven't tested full integration\n5. Opens Phase 3 Verification checklist\n6. Works through each item systematically\n7. Discovers bug: hotkey doesn't fire when settings closed\n8. Fixes bug (HotkeyManager not persisting registration)\n9. Re-tests, all items pass ✓\n10. Documents any issues or workarounds\n11. Marks Phase 3 complete\n12. Proceeds confidently to Phase 4\n\nWithout this verification:\n- Phase 3 appears complete but has integration bugs\n- Phase 4 development reveals Phase 3 issues\n- Must context-switch back to Phase 3\n- Wastes time, creates frustration\n- Delivery delays\n\nCOMPREHENSIVE VERIFICATION CHECKLIST:\n\n## 1. SETTINGS WINDOW (oc-4tw.3)\n□ Settings opens via menu bar \"Settings\" item\n□ Settings opens via Cmd+, keyboard shortcut\n□ Window size is exactly 450x500 (measure in debugger)\n□ Window does not resize when dragging corners\n□ Window title is \"Settings\" or \"Optimus Clip Settings\"\n□ All four tabs visible: Transformations, Providers, General, Permissions\n□ Tab icons display correctly (not placeholder symbols)\n□ Clicking tab switches immediately (no lag)\n□ Cmd+1/2/3/4 switches to respective tab\n□ Only one settings window can be open (singleton)\n□ Re-opening settings focuses existing window\n□ Cmd+W closes settings window\n□ Red X button closes settings window\n□ Window restores to last-used tab on reopen\n□ Window appears in light mode correctly\n□ Window appears in dark mode correctly\n□ No layout glitches or overlapping UI elements\n\n## 2. TRANSFORMATIONS TAB (oc-4tw.4)\n□ Sidebar shows list of transformations\n□ Sidebar initially empty (fresh install) OR shows defaults\n□ \"+\" button creates new transformation\n□ New transformation appears in sidebar immediately\n□ Selecting transformation shows detail editor\n□ Name field editable, saves immediately\n□ Hotkey Recorder visible and functional\n□ Enable/disable toggle functional\n□ Type picker (Algorithmic/LLM) functional\n□ LLM settings show when LLM selected\n□ LLM settings hide when Algorithmic selected\n□ Provider dropdown populated (OpenAI, Anthropic, etc.)\n□ Model dropdown populated for selected provider\n□ System prompt TextEditor editable\n□ \"-\" button deletes selected transformation\n□ Confirmation dialog before delete (optional but recommended)\n□ Deleting transformation removes from sidebar\n□ Empty state shows when no transformation selected\n□ Sidebar/detail split view resizable (optional)\n□ Can create 10+ transformations without issues\n□ Sidebar scrolls if many transformations\n□ No crashes when rapidly switching transformations\n\n## 3. PROVIDERS TAB (oc-4tw.5)\n□ All 5 provider sections visible: OpenAI, Anthropic, OpenRouter, Ollama, AWS Bedrock\n□ API key fields use SecureField (input masked)\n□ Pasting into SecureField works\n□ \"Validate\" button visible for each provider\n□ Validate button disabled when field empty\n□ Valid API key validation succeeds (green checkmark)\n□ Invalid API key validation fails (red X with message)\n□ Error messages helpful (not just \"Error\")\n□ Ollama \"Test Connection\" button functional\n□ Ollama test succeeds when server running\n□ Ollama test fails gracefully when server not running\n□ AWS auth method picker works (Profile vs Keys)\n□ AWS profile field shows when Profile selected\n□ AWS access/secret fields show when Keys selected\n□ AWS region dropdown populated\n□ All settings persist after closing/reopening\n□ Validation state clears when API key changed\n\n## 4. GENERAL TAB (oc-4tw.6)\n□ \"Launch at Login\" toggle visible\n□ Enable Launch at Login, status updates\n□ Restart Mac, app launches automatically\n□ Disable Launch at Login, restart, app doesn't launch\n□ Status indicator shows current state (Enabled/Requires Approval/Not Registered)\n□ \"Open System Settings\" button opens correct pane\n□ \"Sound Effects\" toggle functional\n□ \"Transformation Timeout\" picker functional\n□ Timeout options sensible (15, 30, 45, 60, 90, 120 seconds)\n□ About section shows version and build number\n□ GitHub link opens browser (optional)\n□ All settings persist after closing/reopening\n\n## 5. PERMISSIONS TAB (oc-4tw.7)\n□ Warning callout shows when permission not granted\n□ Warning callout large and impossible to miss (yellow, prominent)\n□ \"Grant Accessibility\" button visible\n□ Clicking \"Grant Accessibility\" shows system prompt\n□ \"Open System Settings\" button opens correct pane\n□ Status section shows current permission state\n□ Grant permission in System Settings\n□ Return to app, warning disappears within 2-3 seconds\n□ Green checkmark and success message appear\n□ Revoke permission in System Settings\n□ Warning reappears within 2-3 seconds\n□ Explanation section clearly explains why permission needed\n□ No crashes or errors when permission not granted\n\n## 6. KEYBOARD SHORTCUTS INTEGRATION (oc-4tw.1 + oc-4tw.9)\n□ KeyboardShortcuts package resolved successfully\n□ Recorder component imports and displays\n□ Click Recorder, enters recording mode\n□ Press key combination, Recorder captures it\n□ Shortcut displays in human-readable format (⌘⌥V)\n□ Press system shortcut (e.g., Cmd+Q), warning badge appears\n□ X button on Recorder clears shortcut\n□ Record same shortcut for two transformations (conflict test)\n□ Default shortcuts set for built-in transformations\n□ Shortcuts persist after app restart\n\n## 7. HOTKEY MANAGER (oc-4tw.2)\n□ Register transformation, hotkey fires\n□ Hotkey fires regardless of active application\n□ Hotkey triggers transformation execution\n□ Rapid key presses don't cause duplicate execution\n□ Disable transformation, hotkey doesn't fire\n□ Enable transformation, hotkey resumes\n□ Delete transformation, hotkey stops firing\n□ Create 5 transformations with different hotkeys, all work\n□ No memory leaks (profile with Instruments)\n□ No crashes without accessibility permission\n□ Error handling graceful (beep or silent, no crash)\n\n## 8. SETTINGS PERSISTENCE (oc-4tw.8)\n□ Create transformation, close app, reopen, transformation persists\n□ Record hotkey, close app, reopen, hotkey persists\n□ Configure API key, close app, reopen, API key persists\n□ Change general settings, close app, reopen, settings persist\n□ Create 10 transformations, close app, reopen, all 10 persist\n□ Corrupt UserDefaults file, app doesn't crash (loads defaults)\n□ Settings sync between views (change in one view, updates in another)\n\n## 9. INTEGRATION TESTS\n□ Full workflow: Create transformation → Record hotkey → Close settings → Press hotkey → (Should trigger, even though engine not built yet, will fail gracefully)\n□ Change transformation hotkey → Press old hotkey (shouldn't work) → Press new hotkey (should work)\n□ Disable transformation → Press hotkey (shouldn't work) → Enable → Press hotkey (should work)\n□ Delete transformation → Press hotkey (shouldn't work)\n□ Configure provider → Create LLM transformation → Select provider (model list populated)\n□ Grant accessibility permission → Hotkeys start working\n□ Revoke accessibility permission → Hotkeys stop working\n\n## 10. EDGE CASE TESTS\n□ Empty clipboard (don't crash when hotkey pressed)\n□ Very long transformation name (200+ characters)\n□ Very long system prompt (10,000+ characters)\n□ Rapid tab switching in settings (no lag or glitches)\n□ Open settings, quit app via menu (settings closes gracefully)\n□ Force quit app (Cmd+Option+Esc), reopen (no corruption)\n□ Launch at login enabled, user logs out and back in (app launches)\n□ Two transformations with identical names (allowed, works)\n□ Transformation with no name (show \"Unnamed Transformation\" placeholder)\n\n## 11. PERFORMANCE TESTS\n□ Settings window opens in \u003c500ms\n□ Tab switching \u003c50ms\n□ Hotkey fires with \u003c100ms latency\n□ Creating transformation with no lag\n□ App memory usage \u003c50MB with 10 transformations\n□ No memory leaks over 1 hour usage\n□ No CPU spikes when idle\n\n## 12. UX TESTS\n□ UI feels native (matches macOS design language)\n□ Form controls properly sized and spaced\n□ Labels aligned and readable\n□ Help text helpful (not confusing or redundant)\n□ Error messages actionable (tell user what to do)\n□ Loading states clear (ProgressView during validation)\n□ Success states reassuring (green checkmarks, clear messages)\n□ Empty states guide user (\"Add your first transformation\")\n□ Keyboard navigation works (Tab, Shift+Tab, Space, Enter)\n□ Focus ring visible and appropriate\n\n## 13. ACCESSIBILITY (a11y) TESTS\n□ VoiceOver can navigate settings\n□ VoiceOver announces controls correctly\n□ Keyboard-only navigation possible\n□ Focus ring visible for keyboard users\n□ High contrast mode works\n□ Text doesn't truncate at large text sizes\n□ Color not only means of conveying information\n\n## 14. DOCUMENTATION \u0026 CLEANUP\n□ All Phase 3 tasks marked complete in beads\n□ Any workarounds or known issues documented\n□ Code comments added for complex sections\n□ No TODO comments left in code\n□ No debug print() statements in production code\n□ SwiftLint passes with no warnings\n□ SwiftFormat applied to all files\n□ Git commits clean (meaningful messages)\n□ No uncommitted debug code\n\nTESTING METHODOLOGY:\n\n1. FRESH INSTALL TEST:\n   - Delete app bundle\n   - Delete ~/Library/Preferences/com.yourname.optimusclip.plist\n   - Rebuild and run\n   - Test first-time user experience\n\n2. UPGRADE TEST:\n   - Create transformation in current build\n   - Build new version\n   - Verify transformation persists and works\n\n3. STRESS TEST:\n   - Create 50 transformations\n   - Record 50 different hotkeys\n   - Measure performance and memory\n\n4. FAILURE TEST:\n   - Corrupt UserDefaults plist\n   - Disconnect network (for LLM validation)\n   - Revoke permissions while app running\n   - Verify graceful degradation\n\nACCEPTANCE CRITERIA:\n- ALL checklist items pass ✓\n- No critical bugs\n- Performance acceptable (\u003c500ms settings open)\n- No memory leaks\n- UX feels polished and native\n- Ready for Phase 4 development\n\nTOOLS FOR VERIFICATION:\n- Xcode Debugger (breakpoints, inspect values)\n- Instruments (memory leaks, CPU profiling)\n- Console.app (system logs)\n- Activity Monitor (memory usage)\n- VoiceOver (accessibility testing)\n- defaults command (inspect UserDefaults)\n\nCOMMON ISSUES TO WATCH FOR:\n1. Settings not persisting (wrong @AppStorage key)\n2. Hotkeys not firing (accessibility permission)\n3. Memory leaks (missing [weak self] in closures)\n4. UI glitches (layout issues in light/dark mode)\n5. Performance degradation (too much polling or refreshing)\n\nREPORTING BUGS:\nIf checklist item fails:\n1. Document exact steps to reproduce\n2. Note expected vs actual behavior\n3. Create new bead for bug fix\n4. Fix bug\n5. Re-run verification\n6. Mark item as passed\n\nPRIORITY: P2 (Gates Phase 3 completion, blocks Phase 4)\n\nESTIMATED TIME: 120-180 minutes (thorough testing takes time)\n\nSUCCESS CRITERIA:\nPhase 3 is complete when:\n- All verification checklist items pass\n- No known critical bugs\n- Code is clean and documented\n- Performance is acceptable\n- UX feels polished\n- Confident to proceed to Phase 4\n\nNOTE: Some tests involve functionality from Phase 2 (clipboard, paste). If Phase 2 not complete, those tests can be deferred or mocked.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:38.092184-05:00","updated_at":"2025-12-13T11:51:34.766406-05:00","closed_at":"2025-12-13T11:51:34.766406-05:00","dependencies":[{"issue_id":"oc-4tw.10","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-12T22:05:38.092655-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.10","depends_on_id":"oc-4tw.9","type":"blocks","created_at":"2025-12-12T22:23:58.463312-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.10","depends_on_id":"oc-4tw.2","type":"blocks","created_at":"2025-12-12T23:54:21.844154-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.10","depends_on_id":"oc-4tw.8","type":"blocks","created_at":"2025-12-12T23:54:22.430448-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-4tw.2","title":"HotkeyManager Implementation","description":"BACKGROUND \u0026 CONTEXT:\nThe HotkeyManager is the central orchestrator that bridges the KeyboardShortcuts package with the rest of the Optimus Clip application. It acts as the \"brain\" for all hotkey functionality, responsible for:\n- Registering keyboard shortcut handlers with the KeyboardShortcuts package\n- Routing hotkey events to the appropriate transformation\n- Managing transformation execution lifecycle (start/stop processing)\n- Coordinating with MenuBarState for visual feedback (pulse animation)\n- Enabling/disabling individual hotkeys based on user preferences\n- Preventing duplicate execution when user rapidly presses hotkeys\n\nWithout HotkeyManager, every part of the app would need to know about KeyboardShortcuts, transformations, and state management, creating tight coupling and maintenance nightmares.\n\nREAL-WORLD PROBLEM/USE CASE:\nUser has 5 different transformations configured:\n- Cmd+Option+V → Quick Fix (strip whitespace)\n- Cmd+Option+S → Smart Fix (LLM-based cleanup)\n- Cmd+Option+J → Format as Jira Ticket\n- Cmd+Option+M → Format as Markdown\n- Cmd+Option+C → Extract Code Blocks\n\nWhen user presses Cmd+Option+V:\n1. KeyboardShortcuts package detects key press\n2. HotkeyManager receives event via registered handler\n3. HotkeyManager looks up which transformation is mapped to this hotkey\n4. HotkeyManager checks if transformation is enabled\n5. HotkeyManager triggers MenuBarState.startProcessing() (pulse animation)\n6. HotkeyManager executes transformation asynchronously\n7. HotkeyManager waits for completion\n8. HotkeyManager triggers MenuBarState.stopProcessing()\n9. HotkeyManager simulates paste (if transformation succeeded)\n\nIf user presses Cmd+Option+V again while first transformation is still running:\n- HotkeyManager detects in-progress state\n- Ignores second press (prevents duplicate execution)\n- User sees pulse animation continue (feedback that something is happening)\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. CLASS STRUCTURE:\n```swift\n@MainActor\nfinal class HotkeyManager: ObservableObject {\n    // Singleton for global access\n    static let shared = HotkeyManager()\n    \n    // Dependencies (injected or accessed)\n    private let transformationEngine: TransformationEngine\n    private let menuBarState: MenuBarState\n    private let clipboardManager: ClipboardManager\n    private let pasteSimulator: PasteSimulator\n    \n    // State\n    @Published private(set) var isProcessing = false\n    private var registeredShortcuts: Set\u003cKeyboardShortcuts.Name\u003e = []\n    \n    private init() {\n        // Initialize dependencies\n        // Don't register shortcuts here (call registerAll() from App init)\n    }\n    \n    func registerAll() {\n        // Called once during app startup\n    }\n    \n    func register(transformation: TransformationConfig) {\n        // Register single transformation\n    }\n    \n    func unregister(transformation: TransformationConfig) {\n        // Unregister single transformation\n    }\n    \n    private func handleHotkey(for transformation: TransformationConfig) {\n        // Handler called when hotkey pressed\n    }\n}\n```\n\n2. HANDLER REGISTRATION PATTERN:\n```swift\nfunc register(transformation: TransformationConfig) {\n    guard transformation.isEnabled else { return }\n    guard let shortcutName = transformation.shortcutName else { return }\n    \n    // Register with KeyboardShortcuts package\n    KeyboardShortcuts.onKeyUp(for: shortcutName) { [weak self] in\n        guard let self = self else { return }\n        \n        // CRITICAL: Dispatch to main actor explicitly\n        Task { @MainActor in\n            await self.handleHotkey(for: transformation)\n        }\n    }\n    \n    // Track registration\n    registeredShortcuts.insert(shortcutName)\n    \n    // Enable the shortcut\n    KeyboardShortcuts.enable(shortcutName)\n}\n```\n\n3. HOTKEY HANDLER IMPLEMENTATION:\n```swift\nprivate func handleHotkey(for transformation: TransformationConfig) async {\n    // Prevent duplicate execution\n    guard !isProcessing else {\n        NSSound.beep()  // Audio feedback that we're busy\n        return\n    }\n    \n    // Mark as processing\n    isProcessing = true\n    menuBarState.startProcessing()  // Pulse animation\n    \n    defer {\n        // Always stop processing, even if error\n        isProcessing = false\n        menuBarState.stopProcessing()\n    }\n    \n    do {\n        // Read clipboard\n        guard let clipboardContent = clipboardManager.readText() else {\n            throw HotkeyError.emptyClipboard\n        }\n        \n        // Execute transformation\n        let transformed = try await transformationEngine.transform(\n            clipboardContent,\n            using: transformation\n        )\n        \n        // Write back to clipboard (with self-write marker)\n        clipboardManager.writeText(transformed)\n        \n        // Wait brief moment for clipboard to update\n        try await Task.sleep(nanoseconds: 50_000_000)  // 50ms\n        \n        // Simulate paste\n        pasteSimulator.simulatePaste()\n        \n    } catch {\n        // Log error\n        print(\"Transformation failed: \\(error)\")\n        \n        // User feedback\n        NSSound.beep()\n        \n        // Show notification (optional)\n        // NotificationManager.shared.showError(error)\n    }\n}\n```\n\n4. ENABLE/DISABLE INDIVIDUAL HOTKEYS:\n```swift\nfunc setEnabled(_ enabled: Bool, for transformation: TransformationConfig) {\n    guard let shortcutName = transformation.shortcutName else { return }\n    \n    if enabled {\n        KeyboardShortcuts.enable(shortcutName)\n    } else {\n        KeyboardShortcuts.disable(shortcutName)\n    }\n    \n    // Update persistence\n    transformationConfig.isEnabled = enabled\n    TransformationStore.shared.save(transformation)\n}\n```\n\n5. UNREGISTER ON DELETION:\n```swift\nfunc unregister(transformation: TransformationConfig) {\n    guard let shortcutName = transformation.shortcutName else { return }\n    \n    // Remove handler (no explicit API, disable is enough)\n    KeyboardShortcuts.disable(shortcutName)\n    \n    // Remove from tracking\n    registeredShortcuts.remove(shortcutName)\n    \n    // Optionally clear shortcut entirely\n    KeyboardShortcuts.reset(shortcutName)\n}\n```\n\n6. REGISTER ALL ON APP STARTUP:\n```swift\nfunc registerAll() {\n    // Load all transformations from storage\n    let transformations = TransformationStore.shared.loadAll()\n    \n    // Register each one\n    for transformation in transformations {\n        register(transformation: transformation)\n    }\n    \n    print(\"Registered \\(registeredShortcuts.count) hotkeys\")\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- Uses KeyboardShortcuts package (oc-4tw.1) for registration\n- Calls TransformationEngine to execute transformations\n- Updates MenuBarState for visual feedback (pulse animation)\n- Reads from ClipboardManager (Phase 2)\n- Calls PasteSimulator (Phase 2)\n- Accessed by SettingsView to enable/disable shortcuts\n- Singleton accessed globally but maintains single responsibility\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. RAPID KEY PRESSES:\n   - Use isProcessing flag to prevent overlapping executions\n   - Provide audio feedback (beep) when rejecting duplicate\n   - Consider queuing instead of rejecting (future enhancement)\n\n2. WEAK SELF IN CLOSURES:\n   - CRITICAL: Use [weak self] in KeyboardShortcuts.onKeyUp closure\n   - Prevents retain cycle (HotkeyManager → closure → HotkeyManager)\n   - Without this, HotkeyManager never deallocates (memory leak)\n\n3. MAIN ACTOR ISOLATION:\n   - KeyboardShortcuts calls handlers on main thread\n   - Transformation execution should be async (off main thread)\n   - Use Task { @MainActor in } for state updates\n   - MenuBarState updates must be on main actor\n\n4. ACCESSIBILITY PERMISSION:\n   - Handlers won't fire without accessibility permission\n   - Don't show errors to user (confusing UX)\n   - Permissions Tab guides user through granting access\n   - HotkeyManager doesn't check permission (let KeyboardShortcuts handle)\n\n5. HOTKEY CONFLICTS:\n   - Two transformations can't have same shortcut\n   - Validate before registration\n   - Show error in UI if conflict detected\n   - Last-registered wins (KeyboardShortcuts behavior)\n\n6. TRANSFORMATION DELETION:\n   - Must unregister before deleting\n   - Otherwise handler remains active (dangling reference)\n   - Call unregister() explicitly in TransformationStore.delete()\n\n7. APP TERMINATION:\n   - Handlers automatically cleaned up\n   - No explicit cleanup needed in deinit\n   - KeyboardShortcuts package handles event tap teardown\n\n8. EMPTY CLIPBOARD:\n   - Handle gracefully (return early, don't error)\n   - Optional beep for user feedback\n   - Don't crash or show alert\n\nTESTING REQUIREMENTS:\n- Register transformation, verify handler fires\n- Press hotkey, verify transformation executes\n- Press hotkey rapidly, verify only one execution\n- Disable transformation, verify handler doesn't fire\n- Enable transformation, verify handler resumes\n- Delete transformation, verify handler removed\n- Register 10 transformations, verify all work\n- Test without accessibility permission (no crash)\n- Test clipboard empty (graceful handling)\n- Test transformation throws error (graceful handling)\n- Verify no memory leaks (profile with Instruments)\n- Verify main thread not blocked during transformation\n\nSUCCESS CRITERIA:\n- Hotkeys trigger transformations correctly\n- No duplicate executions on rapid presses\n- Pulse animation shows during processing\n- Enable/disable works immediately\n- No memory leaks with weak self\n- Graceful error handling\n- Single point of hotkey control\n\nCONFIGURATION OPTIONS:\n- isProcessing flag (public read-only for UI state)\n- registeredShortcuts (tracking, optional)\n- Error handling strategy (beep, notification, silent)\n\nPERFORMANCE CONSIDERATIONS:\n- Handler registration is O(1) per shortcut\n- isProcessing check is O(1)\n- Async transformation execution doesn't block UI\n- Consider debouncing for very rapid key presses\n- Sleep(50ms) before paste allows clipboard to update\n\nSECURITY CONSIDERATIONS:\n- Requires accessibility permission (user must grant)\n- Clipboard content processed securely\n- No telemetry or logging of clipboard content\n- Error messages don't leak sensitive data\n\nANTI-PATTERNS TO AVOID:\n- DON'T register handlers inside handler (infinite recursion)\n- DON'T forget [weak self] (memory leak)\n- DON'T block main thread in handler (UI freeze)\n- DON'T crash on error (graceful degradation)\n- DON'T show alerts in handler (jarring UX)\n\nCODE ORGANIZATION:\nSources/OptimusClip/Managers/HotkeyManager.swift\n\nIMPLEMENTATION ORDER:\n1. Create HotkeyManager class skeleton\n2. Add register() method with KeyboardShortcuts.onKeyUp\n3. Implement handleHotkey() with isProcessing guard\n4. Add MenuBarState integration\n5. Add TransformationEngine integration\n6. Test with single transformation\n7. Add registerAll() for startup\n8. Test with multiple transformations\n9. Add enable/disable/unregister methods\n10. Test full lifecycle\n\nPRIORITY: P2 (Core Phase 3 functionality, after KeyboardShortcuts integration)\n\nESTIMATED TIME: 90-120 minutes (complex orchestration logic)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:33.499487-05:00","updated_at":"2025-12-13T11:39:40.61286-05:00","closed_at":"2025-12-13T11:39:40.61286-05:00","dependencies":[{"issue_id":"oc-4tw.2","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-12T22:05:33.499948-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.2","depends_on_id":"oc-4tw.1","type":"blocks","created_at":"2025-12-12T22:23:56.011123-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.2","depends_on_id":"oc-4tw.4","type":"blocks","created_at":"2025-12-13T11:08:19.348523-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-4tw.3","title":"SettingsView TabView Structure","description":"BACKGROUND \u0026 CONTEXT:\nThe SettingsView is the primary configuration interface for Optimus Clip. It provides a native macOS tabbed window following Apple's Human Interface Guidelines (HIG) for settings/preferences windows. The TabView structure organizes complex configuration into digestible sections:\n- Transformations (create/edit/delete transformation rules)\n- Providers (configure LLM API credentials)\n- General (app-wide preferences)\n- Permissions (accessibility permission management)\n\nThis structure is modeled after successful macOS apps like Rectangle, Dato, and native System Settings. Users expect this tabbed pattern for preferences windows.\n\nWHY TABBED STRUCTURE:\n- Prevents overwhelming single-page UI\n- Logical grouping of related settings\n- Easy navigation with keyboard shortcuts (Cmd+1/2/3/4)\n- Familiar pattern from System Settings\n- Scales well (can add tabs in future without redesign)\n\nREAL-WORLD PROBLEM/USE CASE:\nNew user opens Optimus Clip for first time:\n1. Clicks menu bar icon → \"Settings\" (or presses Cmd+,)\n2. Settings window opens to Transformations tab\n3. User sees empty list, clicks \"Add Transformation\"\n4. Configures first transformation (Quick Fix)\n5. Records hotkey (Cmd+Option+V)\n6. Switches to Permissions tab (yellow warning visible)\n7. Clicks \"Grant Access\" button\n8. Grants accessibility permission in System Settings\n9. Returns to app, warning disappears (green checkmark)\n10. Closes settings, presses hotkey → transformation works!\n\nWithout clear tabbed structure:\n- User lost in single scrolling page\n- Can't find permission settings\n- Doesn't know where to configure API keys\n- Abandons app before successful first run\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. SETTINGS SCENE APPROACH (Preferred for macOS 13+):\n```swift\n@main\nstruct OptimusClipApp: App {\n    var body: some Scene {\n        // Menu bar (primary scene)\n        MenuBarExtra(\"Optimus Clip\", systemImage: \"clipboard\") {\n            // ... menu items\n        }\n        \n        // Settings window (secondary scene)\n        Settings {\n            SettingsView()\n        }\n    }\n}\n```\n\nThis approach:\n- Provides native Cmd+, shortcut automatically\n- Shows \"Settings...\" in menu automatically (if added via MainMenu)\n- Manages window singleton behavior\n- Uses native Settings window style\n- Handles window restoration\n\n2. WINDOWGROUP APPROACH (Alternative, more control):\n```swift\nWindowGroup(id: \"settings\") {\n    SettingsView()\n}\n.windowStyle(.hiddenTitleBar)\n.windowResizability(.contentSize)\n.defaultSize(width: 450, height: 500)\n.commands {\n    CommandGroup(replacing: .appSettings) {\n        Button(\"Settings...\") {\n            NSApp.sendAction(#selector(NSApplication.showSettingsWindow(_:)), to: nil, from: nil)\n        }\n        .keyboardShortcut(\",\", modifiers: .command)\n    }\n}\n```\n\n3. SETTINGSVIEW STRUCTURE:\n```swift\nstruct SettingsView: View {\n    @State private var selectedTab: SettingsTab = .transformations\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            TransformationsTabView()\n                .tabItem {\n                    Label(\"Transformations\", systemImage: \"wand.and.stars\")\n                }\n                .tag(SettingsTab.transformations)\n            \n            ProvidersTabView()\n                .tabItem {\n                    Label(\"Providers\", systemImage: \"cloud\")\n                }\n                .tag(SettingsTab.providers)\n            \n            GeneralTabView()\n                .tabItem {\n                    Label(\"General\", systemImage: \"gearshape\")\n                }\n                .tag(SettingsTab.general)\n            \n            PermissionsTabView()\n                .tabItem {\n                    Label(\"Permissions\", systemImage: \"lock\")\n                }\n                .tag(SettingsTab.permissions)\n        }\n        .frame(width: 450, height: 500)\n        .fixedSize()  // Prevents window resizing\n    }\n}\n\nenum SettingsTab: String, CaseIterable {\n    case transformations\n    case providers\n    case general\n    case permissions\n}\n```\n\n4. WINDOW SIZE SPECIFICATIONS (macOS HIG):\n- Width: 450-500pt (comfortable reading width)\n- Height: 500-600pt (fits on MacBook screen without scrolling)\n- Fixed size: Don't allow resizing (prevents awkward layouts)\n- Minimum size: Same as fixed size\n- NOT full screen capable\n\n5. SF SYMBOLS FOR TAB ICONS:\n- Transformations: \"wand.and.stars\" (magic/transformation)\n- Providers: \"cloud\" (API services)\n- General: \"gearshape\" (settings)\n- Permissions: \"lock\" or \"hand.raised\" (security)\n\nAlternative symbols:\n- Transformations: \"hammer\", \"wrench.and.screwdriver\"\n- Providers: \"server.rack\", \"network\"\n- General: \"slider.horizontal.3\"\n- Permissions: \"checkmark.shield\"\n\n6. TABVIEW STYLE:\n```swift\n.tabViewStyle(.automatic)  // macOS default (sidebar on Big Sur+, tabs on older)\n```\n\nOr force specific style:\n```swift\n.tabViewStyle(DefaultTabViewStyle())  // Traditional tabs at top\n```\n\n7. KEYBOARD SHORTCUTS:\n- Cmd+, → Open settings (automatic with Settings scene)\n- Cmd+W → Close settings (automatic)\n- Cmd+1/2/3/4 → Switch tabs (automatic with TabView)\n- Esc → Close settings (needs manual implementation)\n\n8. WINDOW SINGLETON BEHAVIOR:\nWith Settings scene:\n- Only one settings window can be open\n- Re-opening focuses existing window\n- Window state persisted across launches\n\nWith WindowGroup:\n```swift\n.handlesExternalEvents(matching: Set(arrayLiteral: \"settings\"))\n```\n\n9. OPENING SETTINGS PROGRAMMATICALLY:\nWith Settings scene:\n```swift\n// From menu item\nButton(\"Settings...\") {\n    NSApp.sendAction(#selector(NSApplication.showSettingsWindow(_:)), to: nil, from: nil)\n}\n.keyboardShortcut(\",\", modifiers: .command)\n```\n\nWith WindowGroup:\n```swift\n@Environment(\\.openWindow) private var openWindow\n\nButton(\"Settings...\") {\n    openWindow(id: \"settings\")\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- TransformationsTabView (oc-4tw.4) - First tab\n- ProvidersTabView (oc-4tw.5) - Second tab\n- GeneralTabView (oc-4tw.6) - Third tab\n- PermissionsTabView (oc-4tw.7) - Fourth tab\n- Opened from MenuBarExtra menu\n- Each tab uses @AppStorage for persistence (oc-4tw.8)\n- Transformations tab uses HotkeyRecorder (oc-4tw.9)\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. WINDOW NOT APPEARING:\n   - Menu bar apps need explicit window opening code\n   - Settings scene requires AppDelegate configuration\n   - Check Info.plist doesn't have LSUIElement interfering\n   - Solution: Use WindowGroup with handlesExternalEvents\n\n2. WINDOW BEHIND OTHER APPS:\n   - Add: NSApp.activate(ignoringOtherApps: true)\n   - Settings window should come to front when opened\n\n3. MULTIPLE WINDOWS:\n   - Settings scene prevents this automatically\n   - WindowGroup needs handlesExternalEvents for singleton\n\n4. WINDOW RESTORATION:\n   - Settings scene handles automatically\n   - Window reopens to last-used tab (state restoration)\n   - Disable if not desired: .defaultAppStorage(.init())\n\n5. FIXED SIZE NOT WORKING:\n   - Use .fixedSize() after .frame()\n   - Set windowResizability(.contentSize) for WindowGroup\n   - Don't use ScrollView in tabs (defeats fixed size)\n\n6. TAB ICONS NOT SHOWING:\n   - Ensure SF Symbol names are correct\n   - Label requires both text and image\n   - Use .tabItem { Label(...) } not .tabItem { Text(...) }\n\n7. KEYBOARD SHORTCUTS CONFLICT:\n   - Cmd+, might be captured by other app\n   - Rare but possible with automation tools\n   - User can still open via menu\n\n8. DARK MODE:\n   - TabView style changes in dark mode\n   - Test all tabs in both light and dark\n   - SF Symbols adapt automatically\n\nTESTING REQUIREMENTS:\n- Settings window opens via menu item\n- Settings window opens via Cmd+,\n- All four tabs visible and navigable\n- Window size is 450x500 (measure in Xcode debugger)\n- Window doesn't resize (drag corners)\n- Only one settings window opens at a time\n- Settings window comes to front when opened\n- Window closes with Cmd+W and red X button\n- Tab icons visible and correct\n- Keyboard shortcuts Cmd+1/2/3/4 switch tabs\n- Window state persists across app restarts\n- Works in light mode\n- Works in dark mode\n- Tabs render without scrolling\n- Each tab component renders correctly\n\nSUCCESS CRITERIA:\n- Settings window opens reliably\n- Window is properly sized (450x500)\n- All four tabs accessible\n- Native macOS appearance (tabs/sidebar)\n- Keyboard shortcuts work\n- Single window enforcement\n- Smooth transitions between tabs\n- No layout glitches\n\nCONFIGURATION OPTIONS:\n- Window size (450x500 recommended, adjustable)\n- Tab order (transformations first recommended)\n- Tab icons (SF Symbols, customizable)\n- Default selected tab (transformations recommended)\n- Window resizability (fixed recommended)\n\nPERFORMANCE CONSIDERATIONS:\n- Window opens in \u003c500ms\n- Tab switching is instant (\u003c50ms)\n- Each tab view loads lazily (not all at once)\n- No memory leaks when opening/closing repeatedly\n- Small memory footprint (~10MB for window)\n\nSECURITY CONSIDERATIONS:\n- No sensitive data in window title\n- API keys in SecureField (oc-4tw.5)\n- Window doesn't capture screenshots in sensitive mode (future)\n\nUI/UX DESIGN NOTES:\n- First tab should be most important (Transformations)\n- Permissions tab can be last (less frequently accessed)\n- Icon style should be consistent (all outline or all filled)\n- Label text should be concise (single word preferred)\n- Window should feel native (match System Settings style)\n\nALTERNATIVE DESIGNS CONSIDERED:\n1. Single-page scrolling (rejected - too cluttered)\n2. Sidebar navigation (considered - might use in v2)\n3. Inspector panels (rejected - not standard for settings)\n4. Sheet modal (rejected - settings should be persistent window)\n\nIMPLEMENTATION ORDER:\n1. Create SettingsView.swift with TabView structure\n2. Add placeholder views for each tab (Text(\"TODO\"))\n3. Configure window size and fixed size\n4. Add Settings scene to App struct\n5. Add menu item to open settings\n6. Test opening/closing/switching tabs\n7. Implement each tab view (separate tasks)\n8. Test full integration\n\nCODE ORGANIZATION:\nSources/OptimusClip/Views/Settings/SettingsView.swift\nSources/OptimusClip/Views/Settings/TransformationsTabView.swift\nSources/OptimusClip/Views/Settings/ProvidersTabView.swift\nSources/OptimusClip/Views/Settings/GeneralTabView.swift\nSources/OptimusClip/Views/Settings/PermissionsTabView.swift\n\nPRIORITY: P2 (Foundation for all settings UI in Phase 3)\n\nESTIMATED TIME: 45-60 minutes (structure setup, tab placeholders)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:33.973577-05:00","updated_at":"2025-12-13T10:07:00.569556-05:00","closed_at":"2025-12-13T10:07:00.569556-05:00","dependencies":[{"issue_id":"oc-4tw.3","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-13T09:39:50.994759-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-4tw.4","title":"Transformations Tab UI","description":"BACKGROUND \u0026 CONTEXT:\nThe Transformations Tab is the PRIMARY interface for Optimus Clip configuration. This is where users spend 80% of their settings time. It allows users to:\n- View all configured transformations\n- Create new transformations\n- Edit existing transformations\n- Delete transformations\n- Configure hotkeys for each transformation\n- Enable/disable transformations individually\n- Choose between algorithmic and LLM-based processing\n\nThe UI follows the master-detail pattern (HSplitView): sidebar list on left, detail editor on right. This pattern is familiar from Mail.app, Notes.app, and Xcode. It's the de facto standard for macOS list-based editing interfaces.\n\nREAL-WORLD PROBLEM/USE CASE:\nDeveloper workflow:\n1. User opens Transformations tab\n2. Sees 3 existing transformations in sidebar:\n   - \"Quick Fix\" (Cmd+Option+V) - Enabled ✓\n   - \"Jira Format\" (Cmd+Option+J) - Enabled ✓\n   - \"Code Cleanup\" (Cmd+Option+C) - Disabled ✗\n3. Clicks \"Quick Fix\" in sidebar\n4. Detail pane shows:\n   - Name: \"Quick Fix\"\n   - Hotkey: Cmd+Option+V (recorded)\n   - Enabled: ✓\n   - Type: Algorithmic\n   - (No additional options for algorithmic type)\n5. User clicks \"+\" button to add new transformation\n6. New transformation created with UUID\n7. Detail pane shows blank editor\n8. User fills in:\n   - Name: \"Markdown Formatter\"\n   - Records hotkey: Cmd+Option+M\n   - Enables toggle\n   - Selects Type: LLM\n   - Provider: Anthropic\n   - Model: Claude Haiku\n   - System Prompt: \"Format this text as clean Markdown. Remove hard line breaks. Fix heading levels.\"\n9. Changes auto-save to @AppStorage\n10. User closes settings\n11. Presses Cmd+Option+M → transformation works!\n\nWithout this UI:\n- User can't create custom transformations\n- Stuck with hard-coded defaults\n- No way to customize hotkeys\n- Can't disable unwanted transformations\n- App is rigid and not useful\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. OVERALL STRUCTURE:\n```swift\nstruct TransformationsTabView: View {\n    @AppStorage(\"transformations\") private var transformations: [TransformationConfig] = []\n    @State private var selectedTransformation: TransformationConfig.ID?\n    \n    var body: some View {\n        HSplitView {\n            // Left sidebar (list)\n            TransformationsSidebarView(\n                transformations: $transformations,\n                selectedID: $selectedTransformation\n            )\n            .frame(minWidth: 150, idealWidth: 200, maxWidth: 250)\n            \n            // Right detail pane (editor)\n            if let selected = selectedTransformation,\n               let binding = transformations.binding(for: selected) {\n                TransformationEditorView(transformation: binding)\n                    .frame(minWidth: 250)\n            } else {\n                TransformationEmptyStateView()\n            }\n        }\n    }\n}\n```\n\n2. SIDEBAR IMPLEMENTATION:\n```swift\nstruct TransformationsSidebarView: View {\n    @Binding var transformations: [TransformationConfig]\n    @Binding var selectedID: TransformationConfig.ID?\n    \n    var body: some View {\n        VStack(spacing: 0) {\n            // List of transformations\n            List(transformations, selection: $selectedID) { transformation in\n                TransformationRowView(transformation: transformation)\n            }\n            .listStyle(.sidebar)\n            \n            // Toolbar at bottom\n            HStack {\n                Button(action: addTransformation) {\n                    Image(systemName: \"plus\")\n                }\n                .buttonStyle(.borderless)\n                .help(\"Add Transformation\")\n                \n                Button(action: deleteSelectedTransformation) {\n                    Image(systemName: \"minus\")\n                }\n                .buttonStyle(.borderless)\n                .disabled(selectedID == nil)\n                .help(\"Delete Transformation\")\n                \n                Spacer()\n            }\n            .padding(8)\n        }\n    }\n    \n    private func addTransformation() {\n        let new = TransformationConfig(\n            id: UUID(),\n            name: \"New Transformation\",\n            type: .algorithmic,\n            isEnabled: true\n        )\n        transformations.append(new)\n        selectedID = new.id\n    }\n    \n    private func deleteSelectedTransformation() {\n        guard let id = selectedID else { return }\n        \n        // Unregister hotkey\n        if let transformation = transformations.first(where: { $0.id == id }) {\n            HotkeyManager.shared.unregister(transformation: transformation)\n        }\n        \n        // Remove from list\n        transformations.removeAll { $0.id == id }\n        selectedID = nil\n    }\n}\n```\n\n3. ROW VIEW (Sidebar Item):\n```swift\nstruct TransformationRowView: View {\n    let transformation: TransformationConfig\n    \n    var body: some View {\n        HStack {\n            // Enabled indicator\n            Image(systemName: transformation.isEnabled ? \"checkmark.circle.fill\" : \"circle\")\n                .foregroundColor(transformation.isEnabled ? .green : .secondary)\n                .font(.system(size: 12))\n            \n            // Name\n            Text(transformation.name)\n                .lineLimit(1)\n            \n            Spacer()\n            \n            // Type badge\n            Text(transformation.type.displayName)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n    }\n}\n```\n\n4. DETAIL EDITOR VIEW:\n```swift\nstruct TransformationEditorView: View {\n    @Binding var transformation: TransformationConfig\n    \n    var body: some View {\n        Form {\n            Section(\"Basic Settings\") {\n                // Name\n                TextField(\"Name\", text: $transformation.name)\n                \n                // Hotkey Recorder\n                KeyboardShortcuts.Recorder(\n                    \"Keyboard Shortcut:\",\n                    name: transformation.shortcutName\n                )\n                \n                // Enable toggle\n                Toggle(\"Enabled\", isOn: $transformation.isEnabled)\n                    .onChange(of: transformation.isEnabled) { _, newValue in\n                        HotkeyManager.shared.setEnabled(newValue, for: transformation)\n                    }\n            }\n            \n            Section(\"Transformation Type\") {\n                Picker(\"Type\", selection: $transformation.type) {\n                    Text(\"Algorithmic (Quick)\").tag(TransformationType.algorithmic)\n                    Text(\"LLM-Based (Smart)\").tag(TransformationType.llm)\n                }\n                .pickerStyle(.segmented)\n            }\n            \n            // Conditional LLM settings\n            if transformation.type == .llm {\n                Section(\"LLM Configuration\") {\n                    // Provider picker\n                    Picker(\"Provider\", selection: $transformation.provider) {\n                        ForEach(LLMProvider.allCases) { provider in\n                            Text(provider.displayName).tag(provider)\n                        }\n                    }\n                    \n                    // Model picker\n                    Picker(\"Model\", selection: $transformation.model) {\n                        ForEach(availableModels, id: \\.self) { model in\n                            Text(model).tag(model)\n                        }\n                    }\n                    \n                    // System prompt\n                    VStack(alignment: .leading) {\n                        Text(\"System Prompt:\")\n                            .font(.headline)\n                        \n                        TextEditor(text: $transformation.systemPrompt)\n                            .font(.system(.body, design: .monospaced))\n                            .frame(minHeight: 120)\n                            .border(Color.secondary.opacity(0.3))\n                    }\n                }\n            }\n        }\n        .formStyle(.grouped)\n        .padding()\n    }\n    \n    private var availableModels: [String] {\n        // Fetch models for selected provider\n        ModelRegistry.shared.models(for: transformation.provider)\n    }\n}\n```\n\n5. EMPTY STATE VIEW:\n```swift\nstruct TransformationEmptyStateView: View {\n    var body: some View {\n        VStack(spacing: 16) {\n            Image(systemName: \"wand.and.stars\")\n                .font(.system(size: 48))\n                .foregroundColor(.secondary)\n            \n            Text(\"No Transformation Selected\")\n                .font(.title2)\n            \n            Text(\"Select a transformation from the sidebar or create a new one.\")\n                .font(.body)\n                .foregroundColor(.secondary)\n                .multilineTextAlignment(.center)\n        }\n        .frame(maxWidth: .infinity, maxHeight: .infinity)\n    }\n}\n```\n\n6. TRANSFORMATIONCONFIG MODEL:\n```swift\nstruct TransformationConfig: Identifiable, Codable, Hashable {\n    var id: UUID\n    var name: String\n    var type: TransformationType\n    var isEnabled: Bool\n    var provider: LLMProvider?\n    var model: String?\n    var systemPrompt: String\n    \n    // Computed property for KeyboardShortcuts.Name\n    var shortcutName: KeyboardShortcuts.Name {\n        KeyboardShortcuts.Name(\"transformation_\\(id.uuidString)\")\n    }\n}\n\nenum TransformationType: String, Codable, CaseIterable {\n    case algorithmic\n    case llm\n    \n    var displayName: String {\n        switch self {\n        case .algorithmic: return \"Quick Fix\"\n        case .llm: return \"Smart Fix\"\n        }\n    }\n}\n```\n\n7. APPSTORAGE INTEGRATION (see oc-4tw.8):\n```swift\n// Custom property wrapper for Codable types\n@propertyWrapper\nstruct AppStorageCodable\u003cT: Codable\u003e: DynamicProperty {\n    @AppStorage private var data: Data?\n    \n    var wrappedValue: T {\n        get {\n            guard let data = data else { return defaultValue }\n            return (try? JSONDecoder().decode(T.self, from: data)) ?? defaultValue\n        }\n        nonmutating set {\n            data = try? JSONEncoder().encode(newValue)\n        }\n    }\n    \n    private let defaultValue: T\n    \n    init(wrappedValue defaultValue: T, _ key: String) {\n        self.defaultValue = defaultValue\n        self._data = AppStorage(wrappedValue: nil, key)\n    }\n}\n\n// Usage:\n@AppStorageCodable(\"transformations\") private var transformations: [TransformationConfig] = []\n```\n\nARCHITECTURAL CONNECTIONS:\n- Uses KeyboardShortcuts.Recorder (oc-4tw.9) for hotkey recording\n- Saves to @AppStorage (oc-4tw.8) for persistence\n- Calls HotkeyManager (oc-4tw.2) for registration\n- Part of SettingsView TabView (oc-4tw.3)\n- TransformationConfig used by TransformationEngine (Phase 4)\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. BINDING TO ARRAY ELEMENT:\n   - Standard @Binding doesn't work with array elements\n   - Need custom Array extension:\n   ```swift\n   extension Array where Element: Identifiable {\n       func binding(for id: Element.ID) -\u003e Binding\u003cElement\u003e? {\n           guard let index = firstIndex(where: { $0.id == id }) else { return nil }\n           return Binding(\n               get: { self[index] },\n               set: { _ in }  // Read-only, changes via @AppStorage\n           )\n       }\n   }\n   ```\n\n2. AUTO-SAVE BEHAVIOR:\n   - Changes save immediately to @AppStorage\n   - No \"Save\" or \"Cancel\" buttons needed\n   - Standard macOS settings behavior\n   - User expects this (matches System Settings)\n\n3. HOTKEY CONFLICTS:\n   - Two transformations can't have same hotkey\n   - KeyboardShortcuts.Recorder shows warning automatically\n   - Don't need manual conflict checking\n\n4. DELETING SELECTED ITEM:\n   - Must set selectedID = nil after deletion\n   - Otherwise app crashes (binding to deleted item)\n   - Show confirmation dialog for deletion (optional)\n\n5. DEFAULT TRANSFORMATIONS:\n   - First launch has no transformations\n   - Consider adding 1-2 default transformations\n   - Or show empty state with \"Add your first transformation\" CTA\n\n6. EMPTY NAME:\n   - Allow empty name temporarily (while editing)\n   - Validate on save/close (show error if empty)\n   - Or use placeholder: \"Unnamed Transformation\"\n\n7. LONG NAMES:\n   - Truncate in sidebar with .lineLimit(1)\n   - Full name visible in detail editor\n   - Consider max length (50 chars?)\n\n8. MODEL LIST LOADING:\n   - Models fetched asynchronously for some providers\n   - Show loading indicator while fetching\n   - Cache model lists (don't refetch every time)\n\nTESTING REQUIREMENTS:\n- Create new transformation\n- Edit transformation name\n- Record hotkey for transformation\n- Enable/disable transformation\n- Delete transformation\n- Switch between transformation types\n- Configure LLM settings (provider, model, prompt)\n- Select transformation in sidebar\n- Changes persist after closing settings\n- Hotkey works after configuration\n- Multiple transformations coexist\n- Empty state shows when no selection\n- Sidebar list updates immediately\n- No crashes when deleting selected item\n\nSUCCESS CRITERIA:\n- Users can create unlimited transformations\n- Hotkey recording works reliably\n- Enable/disable toggle responsive\n- LLM settings show/hide correctly\n- All changes persist automatically\n- UI feels native and responsive\n- No data loss or corruption\n\nCONFIGURATION OPTIONS:\n- Sidebar width (150-250pt adjustable)\n- Default transformation type (algorithmic)\n- Show/hide type badge in sidebar\n- Confirmation dialog on delete (optional)\n\nPERFORMANCE CONSIDERATIONS:\n- List renders 100+ transformations smoothly\n- Editor updates don't lag (debounce if needed)\n- Model list caching prevents API spam\n- @AppStorage writes debounced (automatic)\n\nSECURITY CONSIDERATIONS:\n- System prompts stored in UserDefaults (not encrypted)\n- Consider not logging prompts (may contain sensitive data)\n- Validate input lengths (prevent DOS via huge prompts)\n\nUI/UX DESIGN NOTES:\n- Sidebar should feel like Mail.app or Finder\n- Editor should have clear visual hierarchy\n- LLM settings hidden when algorithmic selected\n- System prompt uses monospace font (easier to read)\n- Enabled toggle prominent (frequently used)\n\nIMPLEMENTATION ORDER:\n1. Create TransformationConfig model\n2. Create sidebar view with list\n3. Add add/delete buttons\n4. Create detail editor view (basic fields)\n5. Add KeyboardShortcuts.Recorder integration\n6. Add type picker with conditional LLM settings\n7. Wire up @AppStorage persistence\n8. Test full CRUD workflow\n9. Add empty state view\n10. Polish UI (spacing, colors, etc.)\n\nCODE ORGANIZATION:\nSources/OptimusClip/Views/Settings/Transformations/TransformationsTabView.swift\nSources/OptimusClip/Views/Settings/Transformations/TransformationsSidebarView.swift\nSources/OptimusClip/Views/Settings/Transformations/TransformationEditorView.swift\nSources/OptimusClip/Views/Settings/Transformations/TransformationRowView.swift\nSources/OptimusClip/Models/TransformationConfig.swift\n\nPRIORITY: P2 (Core Phase 3 UI, most complex settings tab)\n\nESTIMATED TIME: 180-240 minutes (complex master-detail interface)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:34.577518-05:00","updated_at":"2025-12-13T11:17:09.399685-05:00","closed_at":"2025-12-13T11:17:09.399685-05:00","dependencies":[{"issue_id":"oc-4tw.4","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-12T22:05:34.578248-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.4","depends_on_id":"oc-4tw.3","type":"blocks","created_at":"2025-12-12T22:23:56.791081-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-4tw.5","title":"Providers Tab UI","description":"BACKGROUND \u0026 CONTEXT:\nThe Providers Tab is where users configure LLM API credentials for the five supported providers:\n1. OpenAI (GPT models)\n2. Anthropic (Claude models)\n3. OpenRouter (aggregator with many models)\n4. Ollama (local models)\n5. AWS Bedrock (enterprise cloud models)\n\nThis tab handles SENSITIVE DATA (API keys) and must follow security best practices:\n- Use SecureField for API key input (text masked)\n- Keys stored in macOS Keychain (Phase 6) - temporarily in @AppStorage for MVP\n- Never log API keys\n- Validate credentials without exposing keys in error messages\n\nEach provider has different configuration requirements:\n- OpenAI/Anthropic/OpenRouter: Simple API key\n- Ollama: Host and port configuration\n- AWS Bedrock: Multiple auth methods (profile vs explicit keys) + region\n\nREAL-WORLD PROBLEM/USE CASE:\nUser wants to use Claude for smart transformations:\n1. Opens Settings → Providers tab\n2. Sees 5 sections (one per provider)\n3. Scrolls to \"Anthropic\" section\n4. Pastes API key into SecureField (dots visible instead of key)\n5. Clicks \"Validate\" button\n6. App makes test API call to list models\n7. Success: Green checkmark appears, \"✓ Connected\" message\n8. Goes to Transformations tab\n9. Creates LLM transformation\n10. Selects Provider: Anthropic\n11. Model dropdown now populated with Claude models\n12. Transformation works\\!\n\nWithout proper provider configuration:\n- User creates LLM transformation\n- Selects provider but no API key configured\n- Transformation fails with confusing error\n- User doesn't know what went wrong\n- Frustration and app abandonment\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. OVERALL STRUCTURE:\n```swift\nstruct ProvidersTabView: View {\n    // API keys (temporarily in AppStorage, move to Keychain in Phase 6)\n    @AppStorage(\"openai_api_key\") private var openAIKey = \"\"\n    @AppStorage(\"anthropic_api_key\") private var anthropicKey = \"\"\n    @AppStorage(\"openrouter_api_key\") private var openRouterKey = \"\"\n    \n    // Ollama config\n    @AppStorage(\"ollama_host\") private var ollamaHost = \"http://localhost\"\n    @AppStorage(\"ollama_port\") private var ollamaPort = \"11434\"\n    \n    // AWS Bedrock config\n    @AppStorage(\"aws_auth_method\") private var awsAuthMethod: AWSAuthMethod = .profile\n    @AppStorage(\"aws_profile\") private var awsProfile = \"default\"\n    @AppStorage(\"aws_access_key\") private var awsAccessKey = \"\"\n    @AppStorage(\"aws_secret_key\") private var awsSecretKey = \"\"\n    @AppStorage(\"aws_region\") private var awsRegion = \"us-east-1\"\n    \n    // Validation state\n    @State private var validationStates: [LLMProvider: ValidationState] = [:]\n    \n    var body: some View {\n        Form {\n            OpenAIProviderSection(apiKey: $openAIKey, validationState: validationState(for: .openai))\n            AnthropicProviderSection(apiKey: $anthropicKey, validationState: validationState(for: .anthropic))\n            OpenRouterProviderSection(apiKey: $openRouterKey, validationState: validationState(for: .openRouter))\n            OllamaProviderSection(host: $ollamaHost, port: $ollamaPort, validationState: validationState(for: .ollama))\n            AWSBedrockProviderSection(\n                authMethod: $awsAuthMethod,\n                profile: $awsProfile,\n                accessKey: $awsAccessKey,\n                secretKey: $awsSecretKey,\n                region: $awsRegion,\n                validationState: validationState(for: .awsBedrock)\n            )\n        }\n        .formStyle(.grouped)\n    }\n    \n    private func validationState(for provider: LLMProvider) -\u003e Binding\u003cValidationState\u003e {\n        Binding(\n            get: { validationStates[provider] ?? .idle },\n            set: { validationStates[provider] = $0 }\n        )\n    }\n}\n\nenum ValidationState: Equatable {\n    case idle\n    case validating\n    case success(message: String)\n    case failure(error: String)\n}\n```\n\n2. OPENAI/ANTHROPIC/OPENROUTER SECTION (Similar Pattern):\n```swift\nstruct OpenAIProviderSection: View {\n    @Binding var apiKey: String\n    @Binding var validationState: ValidationState\n    \n    var body: some View {\n        Section(\"OpenAI\") {\n            // API Key field\n            HStack {\n                SecureField(\"API Key\", text: $apiKey, prompt: Text(\"sk-...\"))\n                    .textFieldStyle(.roundedBorder)\n                \n                // Validate button\n                Button(action: validateAPIKey) {\n                    switch validationState {\n                    case .validating:\n                        ProgressView()\n                            .scaleEffect(0.8)\n                    case .success:\n                        Image(systemName: \"checkmark.circle.fill\")\n                            .foregroundColor(.green)\n                    case .failure:\n                        Image(systemName: \"xmark.circle.fill\")\n                            .foregroundColor(.red)\n                    case .idle:\n                        Text(\"Validate\")\n                    }\n                }\n                .disabled(apiKey.isEmpty || validationState == .validating)\n                .buttonStyle(.bordered)\n            }\n            \n            // Status message\n            switch validationState {\n            case .success(let message):\n                Text(message)\n                    .font(.caption)\n                    .foregroundColor(.green)\n            case .failure(let error):\n                Text(error)\n                    .font(.caption)\n                    .foregroundColor(.red)\n            case .idle, .validating:\n                EmptyView()\n            }\n            \n            // Help text\n            Text(\"Get your API key from platform.openai.com\")\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n    }\n    \n    private func validateAPIKey() {\n        Task {\n            validationState = .validating\n            \n            do {\n                // Make minimal API call to test credentials\n                let client = OpenAIClient(apiKey: apiKey)\n                let models = try await client.listModels()\n                \n                validationState = .success(\"✓ Connected (\\(models.count) models available)\")\n            } catch {\n                validationState = .failure(\"✗ Invalid API key or network error\")\n            }\n        }\n    }\n}\n```\n\n3. OLLAMA SECTION (Host + Port):\n```swift\nstruct OllamaProviderSection: View {\n    @Binding var host: String\n    @Binding var port: String\n    @Binding var validationState: ValidationState\n    \n    var body: some View {\n        Section(\"Ollama (Local)\") {\n            // Host field\n            TextField(\"Host\", text: $host, prompt: Text(\"http://localhost\"))\n                .textFieldStyle(.roundedBorder)\n            \n            // Port field\n            TextField(\"Port\", text: $port, prompt: Text(\"11434\"))\n                .textFieldStyle(.roundedBorder)\n            \n            // Test connection button\n            HStack {\n                Button(action: testConnection) {\n                    switch validationState {\n                    case .validating:\n                        ProgressView()\n                            .scaleEffect(0.8)\n                        Text(\"Testing...\")\n                    case .success:\n                        Image(systemName: \"checkmark.circle.fill\")\n                            .foregroundColor(.green)\n                        Text(\"Test Connection\")\n                    case .failure:\n                        Image(systemName: \"xmark.circle.fill\")\n                            .foregroundColor(.red)\n                        Text(\"Test Connection\")\n                    case .idle:\n                        Text(\"Test Connection\")\n                    }\n                }\n                .buttonStyle(.bordered)\n                \n                Spacer()\n            }\n            \n            // Status message\n            switch validationState {\n            case .success(let message):\n                Text(message)\n                    .font(.caption)\n                    .foregroundColor(.green)\n            case .failure(let error):\n                Text(error)\n                    .font(.caption)\n                    .foregroundColor(.red)\n            case .idle, .validating:\n                EmptyView()\n            }\n            \n            // Help text\n            Text(\"Run `ollama serve` to start the local server\")\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n    }\n    \n    private func testConnection() {\n        Task {\n            validationState = .validating\n            \n            do {\n                let url = \"\\(host):\\(port)/api/tags\"\n                let client = OllamaClient(baseURL: url)\n                let models = try await client.listModels()\n                \n                validationState = .success(\"✓ Connected (\\(models.count) local models)\")\n            } catch {\n                validationState = .failure(\"✗ Cannot connect to Ollama server\")\n            }\n        }\n    }\n}\n```\n\n4. AWS BEDROCK SECTION (Complex Auth):\n```swift\nstruct AWSBedrockProviderSection: View {\n    @Binding var authMethod: AWSAuthMethod\n    @Binding var profile: String\n    @Binding var accessKey: String\n    @Binding var secretKey: String\n    @Binding var region: String\n    @Binding var validationState: ValidationState\n    \n    var body: some View {\n        Section(\"AWS Bedrock\") {\n            // Auth method picker\n            Picker(\"Authentication\", selection: $authMethod) {\n                Text(\"AWS Profile\").tag(AWSAuthMethod.profile)\n                Text(\"Access Keys\").tag(AWSAuthMethod.keys)\n            }\n            .pickerStyle(.segmented)\n            \n            // Conditional auth fields\n            if authMethod == .profile {\n                TextField(\"Profile Name\", text: $profile, prompt: Text(\"default\"))\n                    .textFieldStyle(.roundedBorder)\n                \n                Text(\"Uses credentials from ~/.aws/credentials\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            } else {\n                SecureField(\"Access Key ID\", text: $accessKey, prompt: Text(\"AKIA...\"))\n                    .textFieldStyle(.roundedBorder)\n                \n                SecureField(\"Secret Access Key\", text: $secretKey, prompt: Text(\"...\"))\n                    .textFieldStyle(.roundedBorder)\n            }\n            \n            // Region picker\n            Picker(\"Region\", selection: $region) {\n                ForEach(AWSRegion.allCases) { region in\n                    Text(region.displayName).tag(region.rawValue)\n                }\n            }\n            \n            // Validate button\n            Button(action: validateCredentials) {\n                switch validationState {\n                case .validating:\n                    ProgressView()\n                        .scaleEffect(0.8)\n                    Text(\"Validating...\")\n                case .success:\n                    Image(systemName: \"checkmark.circle.fill\")\n                        .foregroundColor(.green)\n                    Text(\"Validate\")\n                case .failure:\n                    Image(systemName: \"xmark.circle.fill\")\n                        .foregroundColor(.red)\n                    Text(\"Validate\")\n                case .idle:\n                    Text(\"Validate\")\n                }\n            }\n            .buttonStyle(.bordered)\n            \n            // Status message\n            switch validationState {\n            case .success(let message):\n                Text(message)\n                    .font(.caption)\n                    .foregroundColor(.green)\n            case .failure(let error):\n                Text(error)\n                    .font(.caption)\n                    .foregroundColor(.red)\n            case .idle, .validating:\n                EmptyView()\n            }\n        }\n    }\n    \n    private func validateCredentials() {\n        Task {\n            validationState = .validating\n            \n            do {\n                let client = BedrockClient(\n                    authMethod: authMethod,\n                    profile: profile,\n                    accessKey: accessKey,\n                    secretKey: secretKey,\n                    region: region\n                )\n                \n                let models = try await client.listFoundationModels()\n                validationState = .success(\"✓ Connected (\\(models.count) models available)\")\n            } catch {\n                validationState = .failure(\"✗ Invalid credentials or region\")\n            }\n        }\n    }\n}\n\nenum AWSAuthMethod: String, Codable, CaseIterable {\n    case profile\n    case keys\n}\n\nenum AWSRegion: String, Codable, CaseIterable, Identifiable {\n    case usEast1 = \"us-east-1\"\n    case usWest2 = \"us-west-2\"\n    case euWest1 = \"eu-west-1\"\n    // ... more regions\n    \n    var id: String { rawValue }\n    var displayName: String { rawValue }\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- Credentials used by LLM clients (Phase 5)\n- Model lists fetched and cached\n- Part of SettingsView TabView (oc-4tw.3)\n- Keys migrated to Keychain in Phase 6\n- Validation uses same API clients as transformations\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. API KEY VALIDATION:\n   - Don't send full request (expensive, slow)\n   - Use minimal endpoint (list models)\n   - Cache validation result (don't re-validate on every tab switch)\n   - Handle network errors gracefully\n\n2. EMPTY API KEYS:\n   - Disable validate button when empty\n   - Don't show error immediately (wait for user input)\n   - Clear validation state when key changes\n\n3. OLLAMA NOT RUNNING:\n   - Show helpful error: \"Cannot connect. Is Ollama running?\"\n   - Don't crash or hang\n   - Provide link to Ollama docs\n\n4. AWS PROFILE NOT FOUND:\n   - Check ~/.aws/credentials file exists\n   - Validate profile name exists in file\n   - Show helpful error message\n\n5. RATE LIMITING:\n   - Provider may rate-limit validation calls\n   - Debounce validation requests\n   - Don't auto-validate on every keystroke\n\n6. INVALID CHARACTERS:\n   - API keys may have special characters\n   - Don't trim or transform input\n   - SecureField handles this correctly\n\n7. PASTE BEHAVIOR:\n   - SecureField supports paste\n   - Pasted text is masked immediately\n   - Works as expected\n\nTESTING REQUIREMENTS:\n- Enter valid API key, validate succeeds\n- Enter invalid API key, validate fails\n- Empty API key disables validate button\n- Ollama test connection works when server running\n- Ollama test connection fails gracefully when server not running\n- AWS profile auth works\n- AWS keys auth works\n- Validation state persists across tab switches\n- SecureField masks input correctly\n- Paste into SecureField works\n- All providers can be configured independently\n- Form scrolls properly if too many providers\n\nSUCCESS CRITERIA:\n- All 5 providers configurable\n- API keys properly masked in UI\n- Validation provides clear feedback\n- Error messages helpful\n- Network errors handled gracefully\n- Configuration persists\n\nCONFIGURATION OPTIONS:\n- Validation timeout (30 seconds default)\n- Cache validation results (5 minutes)\n- Show/hide help text (optional)\n\nPERFORMANCE CONSIDERATIONS:\n- Validation API calls are async (don't block UI)\n- Cache model lists after validation\n- Debounce validation triggers\n- Small memory footprint\n\nSECURITY CONSIDERATIONS:\n- CRITICAL: Never log API keys\n- SecureField masks input (view protection)\n- Keys in Keychain (Phase 6) not UserDefaults\n- Validation errors don't leak key information\n- Consider auto-lock timeout (future)\n\nIMPLEMENTATION ORDER:\n1. Create provider section views\n2. Add SecureField for API keys\n3. Implement validation for OpenAI\n4. Duplicate pattern for Anthropic/OpenRouter\n5. Implement Ollama test connection\n6. Implement AWS Bedrock complex auth\n7. Add validation state management\n8. Test all providers\n9. Add help text and error messages\n10. Polish UI\n\nCODE ORGANIZATION:\nSources/OptimusClip/Views/Settings/Providers/ProvidersTabView.swift\nSources/OptimusClip/Views/Settings/Providers/OpenAIProviderSection.swift\nSources/OptimusClip/Views/Settings/Providers/AnthropicProviderSection.swift\nSources/OptimusClip/Views/Settings/Providers/OpenRouterProviderSection.swift\nSources/OptimusClip/Views/Settings/Providers/OllamaProviderSection.swift\nSources/OptimusClip/Views/Settings/Providers/AWSBedrockProviderSection.swift\n\nPRIORITY: P2 (Required for LLM transformations in Phase 5)\n\nESTIMATED TIME: 150-180 minutes (5 providers with validation)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:35.167877-05:00","updated_at":"2025-12-13T10:55:57.853951-05:00","closed_at":"2025-12-13T10:55:57.853951-05:00","dependencies":[{"issue_id":"oc-4tw.5","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-12T22:05:35.168516-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.5","depends_on_id":"oc-4tw.3","type":"blocks","created_at":"2025-12-12T22:23:57.17712-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-4tw.6","title":"General Tab UI","description":"BACKGROUND \u0026 CONTEXT:\nThe General Tab contains application-wide settings that don't fit into other categories. These are the \"miscellaneous\" settings that affect the overall behavior of Optimus Clip, not specific transformations or providers. This tab is typically the simplest, with fewer settings than other tabs.\n\nFor MVP, the General Tab includes:\n1. Launch at Login - Automatically start app when user logs in\n2. Sound Effects - Enable/disable audio feedback (beeps)\n3. Transformation Timeout - Maximum seconds to wait for LLM responses\n\nFuture settings might include:\n- Theme preference (light/dark/auto)\n- Notification preferences\n- History retention (how many entries to keep)\n- Update check frequency\n- Advanced: show debug logs\n\nThis follows the macOS pattern where \"General\" is catch-all for app-wide preferences (see System Settings → General).\n\nREAL-WORLD PROBLEM/USE CASE:\nUser's typical workflow with General settings:\n1. Installs Optimus Clip\n2. Opens Settings → General tab\n3. Enables \"Launch at Login\" (wants app always available)\n4. Disables \"Sound Effects\" (works in quiet office)\n5. Changes timeout from 30s to 60s (uses complex prompts)\n6. Closes settings\n7. Restarts Mac\n8. Optimus Clip launches automatically\n9. Presses transformation hotkey\n10. No beep sound (as configured)\n11. Waits 45 seconds for LLM response\n12. Transformation completes successfully (within 60s timeout)\n\nWithout Launch at Login:\n- User must manually launch app after every restart\n- Forgets app is available\n- Reaches for hotkey, nothing happens\n- Frustration and reduced usage\n\nWithout Timeout Configuration:\n- Default 30s timeout too short for complex prompts\n- Transformations fail prematurely\n- User doesn't understand why\n- Thinks app is broken\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. OVERALL STRUCTURE:\n```swift\nstruct GeneralTabView: View {\n    @AppStorage(\"launchAtLogin\") private var launchAtLogin = false\n    @AppStorage(\"soundEffectsEnabled\") private var soundEffectsEnabled = true\n    @AppStorage(\"transformationTimeout\") private var transformationTimeout = 30.0\n    \n    // For Launch at Login status\n    @State private var loginItemStatus: SMAppService.Status = .notRegistered\n    \n    var body: some View {\n        Form {\n            Section(\"Startup\") {\n                LaunchAtLoginToggle(isEnabled: $launchAtLogin, status: $loginItemStatus)\n            }\n            \n            Section(\"User Interface\") {\n                Toggle(\"Sound Effects\", isOn: $soundEffectsEnabled)\n                    .help(\"Play audio feedback when transformations succeed or fail\")\n            }\n            \n            Section(\"Performance\") {\n                TransformationTimeoutPicker(timeout: $transformationTimeout)\n            }\n            \n            Section(\"About\") {\n                AboutSection()\n            }\n        }\n        .formStyle(.grouped)\n        .padding()\n        .onAppear {\n            updateLoginItemStatus()\n        }\n    }\n    \n    private func updateLoginItemStatus() {\n        loginItemStatus = SMAppService.mainApp.status\n    }\n}\n```\n\n2. LAUNCH AT LOGIN TOGGLE (SMAppService):\n```swift\nstruct LaunchAtLoginToggle: View {\n    @Binding var isEnabled: Bool\n    @Binding var status: SMAppService.Status\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            Toggle(\"Launch at Login\", isOn: $isEnabled)\n                .onChange(of: isEnabled) { _, newValue in\n                    setLaunchAtLogin(newValue)\n                }\n            \n            // Status indicator\n            switch status {\n            case .enabled:\n                Label(\"Enabled\", systemImage: \"checkmark.circle.fill\")\n                    .font(.caption)\n                    .foregroundColor(.green)\n            case .requiresApproval:\n                Label(\"Requires Approval in System Settings\", systemImage: \"exclamationmark.triangle.fill\")\n                    .font(.caption)\n                    .foregroundColor(.orange)\n                Button(\"Open System Settings\") {\n                    openLoginItems()\n                }\n                .buttonStyle(.link)\n                .font(.caption)\n            case .notRegistered:\n                Label(\"Not Registered\", systemImage: \"circle\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            @unknown default:\n                EmptyView()\n            }\n        }\n    }\n    \n    private func setLaunchAtLogin(_ enabled: Bool) {\n        do {\n            if enabled {\n                try SMAppService.mainApp.register()\n            } else {\n                try SMAppService.mainApp.unregister()\n            }\n            \n            // Update status\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                status = SMAppService.mainApp.status\n            }\n        } catch {\n            print(\"Failed to \\(enabled ? \"enable\" : \"disable\") launch at login: \\(error)\")\n            \n            // Revert toggle on failure\n            isEnabled = !enabled\n        }\n    }\n    \n    private func openLoginItems() {\n        // macOS 13+: Open Login Items in System Settings\n        if let url = URL(string: \"x-apple.systempreferences:com.apple.LoginItems-Settings.extension\") {\n            NSWorkspace.shared.open(url)\n        }\n    }\n}\n```\n\n3. TRANSFORMATION TIMEOUT PICKER:\n```swift\nstruct TransformationTimeoutPicker: View {\n    @Binding var timeout: Double\n    \n    private let timeoutOptions: [Double] = [15, 30, 45, 60, 90, 120]\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            HStack {\n                Text(\"Transformation Timeout:\")\n                \n                Picker(\"\", selection: $timeout) {\n                    ForEach(timeoutOptions, id: \\.self) { seconds in\n                        Text(\"\\(Int(seconds)) seconds\").tag(seconds)\n                    }\n                }\n                .labelsHidden()\n                .frame(width: 150)\n            }\n            \n            Text(\"Maximum time to wait for LLM responses before failing\")\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n    }\n}\n```\n\n4. ABOUT SECTION (Optional but nice):\n```swift\nstruct AboutSection: View {\n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            HStack {\n                Text(\"Version:\")\n                    .foregroundColor(.secondary)\n                Text(Bundle.main.appVersion)\n            }\n            \n            HStack {\n                Text(\"Build:\")\n                    .foregroundColor(.secondary)\n                Text(Bundle.main.appBuild)\n            }\n            \n            HStack {\n                Button(\"View on GitHub\") {\n                    if let url = URL(string: \"https://github.com/yourname/optimus-clip\") {\n                        NSWorkspace.shared.open(url)\n                    }\n                }\n                .buttonStyle(.link)\n                \n                Button(\"Report Issue\") {\n                    if let url = URL(string: \"https://github.com/yourname/optimus-clip/issues\") {\n                        NSWorkspace.shared.open(url)\n                    }\n                }\n                .buttonStyle(.link)\n            }\n        }\n    }\n}\n\nextension Bundle {\n    var appVersion: String {\n        infoDictionary?[\"CFBundleShortVersionString\"] as? String ?? \"Unknown\"\n    }\n    \n    var appBuild: String {\n        infoDictionary?[\"CFBundleVersion\"] as? String ?? \"Unknown\"\n    }\n}\n```\n\n5. SMAPPSERVICE INTEGRATION DETAILS:\n```swift\nimport ServiceManagement\n\n// Check current status\nlet status = SMAppService.mainApp.status\n// Possible values:\n// - .notRegistered: Not added to login items\n// - .enabled: Successfully added and enabled\n// - .requiresApproval: Added but user must approve in System Settings\n// - .notFound: App bundle not found (error state)\n\n// Register (enable launch at login)\ntry SMAppService.mainApp.register()\n\n// Unregister (disable launch at login)\ntry SMAppService.mainApp.unregister()\n```\n\nARCHITECTURAL CONNECTIONS:\n- SMAppService.mainApp used for login item management\n- soundEffectsEnabled read by HotkeyManager (beep on error)\n- transformationTimeout read by TransformationEngine\n- Part of SettingsView TabView (oc-4tw.3)\n- @AppStorage for persistence (oc-4tw.8)\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. SMAPPSERVICE REQUIRES APPROVAL:\n   - macOS 13+ requires user approval for login items\n   - SMAppService.mainApp.register() succeeds but status is .requiresApproval\n   - Must guide user to System Settings → Login Items\n   - Open via: x-apple.systempreferences:com.apple.LoginItems-Settings.extension\n   - Show clear UI indicating approval needed\n\n2. REGISTER/UNREGISTER CAN THROW:\n   - Wrap in do-catch\n   - Handle errors gracefully\n   - Don't crash if registration fails\n   - Revert toggle state on failure\n\n3. STATUS CHECK TIMING:\n   - Status doesn't update immediately after register/unregister\n   - Add small delay (500ms) before checking\n   - Or poll status every 2 seconds while settings open\n\n4. APP BUNDLE LOCATION:\n   - Launch at login only works from /Applications\n   - If app run from Downloads or build folder, fails\n   - Show warning if not in /Applications (optional)\n\n5. MULTIPLE INSTANCES:\n   - Info.plist has LSMultipleInstancesProhibited=true\n   - Prevents multiple instances even with login item\n   - Correct behavior\n\n6. TIMEOUT TOO SHORT:\n   - User sets 15s timeout\n   - Complex LLM prompts take longer\n   - Transformations fail frequently\n   - Don't prevent (user choice) but show warning?\n\n7. TIMEOUT TOO LONG:\n   - User sets 120s timeout\n   - Hung API requests take forever to fail\n   - Bad UX but technically correct\n   - Consider max timeout (120s reasonable)\n\n8. SOUND EFFECTS PLATFORM:\n   - Use NSSound.beep() for system beep\n   - Or custom sound files (bundle sound assets)\n   - Respect system sound settings automatically\n\nTESTING REQUIREMENTS:\n- Enable launch at login, verify status updates\n- Restart Mac, verify app launches\n- Disable launch at login, restart, verify app doesn't launch\n- Change timeout, verify saved to @AppStorage\n- Toggle sound effects, verify saved\n- Test on fresh Mac (requires approval flow)\n- Test from /Applications folder\n- Test from non-/Applications folder (should work but warn?)\n- Verify register() error handling\n- Verify unregister() error handling\n\nSUCCESS CRITERIA:\n- Launch at login works reliably\n- Status indicator accurate\n- Timeout changes apply immediately\n- Sound effects toggle works\n- All settings persist\n- Clear UI for approval required state\n- No crashes on register/unregister errors\n\nCONFIGURATION OPTIONS:\n- Default timeout (30s recommended)\n- Timeout options list (customizable)\n- Sound effects enabled by default (true)\n- Launch at login default (false, user opts in)\n\nPERFORMANCE CONSIDERATIONS:\n- SMAppService calls are fast (\u003c10ms)\n- No network calls in this tab\n- Minimal memory usage\n- Status polling (if implemented) shouldn't impact performance\n\nSECURITY CONSIDERATIONS:\n- Launch at login requires user approval (macOS 13+)\n- No security risks in this tab\n- Settings stored in UserDefaults (not sensitive)\n\nUI/UX DESIGN NOTES:\n- Launch at Login should be first (most important)\n- Group related settings in sections\n- Use help text for clarity\n- Show status indicators (green checkmark, warnings)\n- About section optional but adds polish\n\nALTERNATIVE APPROACHES:\n\n1. LAUNCH AT LOGIN (Old Method - Deprecated):\n   - SMLoginItemSetEnabled (deprecated, don't use)\n   - LSSharedFileList (deprecated, don't use)\n   - Must use SMAppService on macOS 13+\n\n2. TIMEOUT UI:\n   - Slider instead of picker (less precise but flexible)\n   - Text field (error-prone, must validate)\n   - Picker is best (discrete sensible options)\n\nIMPLEMENTATION ORDER:\n1. Create GeneralTabView with Form\n2. Add launch at login toggle with SMAppService\n3. Add status indicator for login item\n4. Add sound effects toggle\n5. Add timeout picker\n6. Add About section\n7. Test launch at login workflow\n8. Test on fresh Mac (approval flow)\n9. Polish UI\n10. Document edge cases\n\nCODE ORGANIZATION:\nSources/OptimusClip/Views/Settings/General/GeneralTabView.swift\nSources/OptimusClip/Views/Settings/General/LaunchAtLoginToggle.swift\nSources/OptimusClip/Views/Settings/General/TransformationTimeoutPicker.swift\n\nMACOS VERSION COMPATIBILITY:\n- SMAppService: macOS 13.0+\n- Package.swift specifies: .macOS(.v15)\n- Safe to use SMAppService (no legacy support needed)\n\nPRIORITY: P2 (Important for UX but not blocking core functionality)\n\nESTIMATED TIME: 60-90 minutes (SMAppService requires testing)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:35.757611-05:00","updated_at":"2025-12-13T10:41:40.118332-05:00","closed_at":"2025-12-13T10:41:40.118332-05:00","dependencies":[{"issue_id":"oc-4tw.6","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-12T22:05:35.758848-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.6","depends_on_id":"oc-4tw.3","type":"blocks","created_at":"2025-12-12T22:23:57.622634-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-4tw.7","title":"Permissions Tab UI","description":"BACKGROUND \u0026 CONTEXT:\nThe Permissions Tab is CRITICAL for Optimus Clip to function. Without Accessibility permission, the app cannot:\n- Capture global hotkeys (KeyboardShortcuts package requires it)\n- Simulate paste events (CGEvent.post requires it)\n\nThis means without permission, the app is completely non-functional. The Permissions Tab serves two purposes:\n1. EDUCATION: Explain why permission is needed and what it does\n2. FACILITATION: Provide easy path to grant permission\n\nmacOS Accessibility permission is a security feature that prevents malicious apps from capturing keystrokes or simulating input. Legitimate apps like Optimus Clip, Rectangle, Alfred, etc. require this permission to provide their core functionality.\n\nThe UI must handle three states:\n- Permission NOT granted: Show prominent warning callout with action buttons\n- Permission granted: Show success indicator (green checkmark)\n- Permission status unknown: Checking (brief loading state)\n\nBecause macOS provides NO callback/notification when permission is granted, we must POLL the permission status (check every 2 seconds). This allows the UI to update immediately when user grants permission in System Settings.\n\nREAL-WORLD PROBLEM/USE CASE:\nNew user's first-time setup:\n1. Installs Optimus Clip\n2. Opens Settings → Permissions tab\n3. Sees large yellow warning banner:\n   ⚠️ \"Accessibility Permission Required\"\n   \"Optimus Clip needs Accessibility permission to capture hotkeys and simulate paste events.\"\n4. Clicks \"Grant Accessibility\" button\n5. macOS shows system permission prompt\n6. User clicks \"Open System Settings\"\n7. System Settings opens to Privacy \u0026 Security → Accessibility\n8. User clicks lock icon, enters password\n9. User checks checkbox next to \"Optimus Clip\"\n10. User returns to Optimus Clip (settings still open)\n11. Within 2 seconds, warning banner disappears\n12. Green checkmark appears: \"✓ Accessibility Permission Granted\"\n13. User closes settings\n14. Presses transformation hotkey → works!\n\nWithout this UI:\n- User doesn't know why hotkeys don't work\n- No guidance on what permission to grant\n- No feedback when permission granted\n- Frustration and app abandonment\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. OVERALL STRUCTURE:\n```swift\nstruct PermissionsTabView: View {\n    @StateObject private var permissionManager = AccessibilityPermissionManager.shared\n    \n    var body: some View {\n        VStack(spacing: 24) {\n            // Warning callout (shown when permission NOT granted)\n            if !permissionManager.isAccessibilityGranted {\n                AccessibilityCalloutView(permissionManager: permissionManager)\n            }\n            \n            // Status section (always shown)\n            PermissionStatusSection(isGranted: permissionManager.isAccessibilityGranted)\n            \n            // Explanation section\n            PermissionExplanationSection()\n            \n            Spacer()\n        }\n        .padding()\n        .onAppear {\n            permissionManager.startPolling()\n        }\n        .onDisappear {\n            permissionManager.stopPolling()\n        }\n    }\n}\n```\n\n2. ACCESSIBILITY CALLOUT (Prominent Warning):\n```swift\nstruct AccessibilityCalloutView: View {\n    @ObservedObject var permissionManager: AccessibilityPermissionManager\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 16) {\n            // Header with warning icon\n            HStack {\n                Image(systemName: \"exclamationmark.triangle.fill\")\n                    .font(.system(size: 32))\n                    .foregroundColor(.yellow)\n                \n                VStack(alignment: .leading, spacing: 4) {\n                    Text(\"Accessibility Permission Required\")\n                        .font(.headline)\n                    \n                    Text(\"Optimus Clip needs permission to function\")\n                        .font(.subheadline)\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            // Explanation\n            Text(\"Optimus Clip requires Accessibility permission to:\")\n                .font(.body)\n            \n            VStack(alignment: .leading, spacing: 8) {\n                BulletPoint(\"Capture global keyboard shortcuts\")\n                BulletPoint(\"Simulate paste events after transformations\")\n                BulletPoint(\"Read clipboard content securely\")\n            }\n            \n            // Action buttons\n            HStack(spacing: 12) {\n                Button(\"Grant Accessibility\") {\n                    permissionManager.requestPermission()\n                }\n                .buttonStyle(.borderedProminent)\n                .controlSize(.large)\n                \n                Button(\"Open System Settings\") {\n                    permissionManager.openSystemSettings()\n                }\n                .buttonStyle(.bordered)\n                .controlSize(.large)\n            }\n            \n            // Help text\n            Text(\"After granting permission, this message will disappear automatically.\")\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .padding()\n        .background(\n            RoundedRectangle(cornerRadius: 12)\n                .fill(Color.yellow.opacity(0.1))\n        )\n        .overlay(\n            RoundedRectangle(cornerRadius: 12)\n                .stroke(Color.yellow.opacity(0.5), lineWidth: 2)\n        )\n    }\n}\n\nstruct BulletPoint: View {\n    let text: String\n    \n    init(_ text: String) {\n        self.text = text\n    }\n    \n    var body: some View {\n        HStack(alignment: .top, spacing: 8) {\n            Text(\"•\")\n                .font(.body)\n            Text(text)\n                .font(.body)\n        }\n    }\n}\n```\n\n3. PERMISSION STATUS SECTION:\n```swift\nstruct PermissionStatusSection: View {\n    let isGranted: Bool\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            Text(\"Permission Status\")\n                .font(.headline)\n            \n            HStack {\n                if isGranted {\n                    Image(systemName: \"checkmark.circle.fill\")\n                        .font(.system(size: 24))\n                        .foregroundColor(.green)\n                    \n                    VStack(alignment: .leading) {\n                        Text(\"Accessibility Permission Granted\")\n                            .font(.body)\n                        Text(\"All features are fully functional\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                } else {\n                    Image(systemName: \"xmark.circle.fill\")\n                        .font(.system(size: 24))\n                        .foregroundColor(.red)\n                    \n                    VStack(alignment: .leading) {\n                        Text(\"Accessibility Permission Denied\")\n                            .font(.body)\n                        Text(\"Hotkeys and paste simulation will not work\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n4. EXPLANATION SECTION (Educational):\n```swift\nstruct PermissionExplanationSection: View {\n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            Text(\"About Accessibility Permission\")\n                .font(.headline)\n            \n            Text(\"Accessibility permission is a macOS security feature that allows apps to control your computer. Optimus Clip is open source and auditable - we only use this permission for clipboard transformations.\")\n                .font(.body)\n                .foregroundColor(.secondary)\n            \n            Text(\"You can revoke this permission at any time in System Settings.\")\n                .font(.body)\n                .foregroundColor(.secondary)\n        }\n    }\n}\n```\n\n5. ACCESSIBILITY PERMISSION MANAGER:\n```swift\nimport ApplicationServices\n\n@MainActor\nclass AccessibilityPermissionManager: ObservableObject {\n    static let shared = AccessibilityPermissionManager()\n    \n    @Published private(set) var isAccessibilityGranted = false\n    \n    private var pollingTimer: Timer?\n    private let pollingInterval: TimeInterval = 2.0\n    \n    private init() {\n        updatePermissionStatus()\n    }\n    \n    // Check current permission status\n    func updatePermissionStatus() {\n        isAccessibilityGranted = AXIsProcessTrusted()\n    }\n    \n    // Request permission (shows system prompt)\n    func requestPermission() {\n        let options: NSDictionary = [kAXTrustedCheckOptionPrompt.takeUnretainedValue(): true]\n        AXIsProcessTrustedWithOptions(options)\n        \n        // Update status after brief delay\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n            self.updatePermissionStatus()\n        }\n    }\n    \n    // Open System Settings to Accessibility pane\n    func openSystemSettings() {\n        // macOS 13+\n        if let url = URL(string: \"x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility\") {\n            NSWorkspace.shared.open(url)\n        }\n    }\n    \n    // Start polling for permission changes\n    func startPolling() {\n        stopPolling()  // Stop existing timer if any\n        \n        pollingTimer = Timer.scheduledTimer(withTimeInterval: pollingInterval, repeats: true) { [weak self] _ in\n            self?.updatePermissionStatus()\n        }\n        \n        // Fire immediately\n        updatePermissionStatus()\n    }\n    \n    // Stop polling\n    func stopPolling() {\n        pollingTimer?.invalidate()\n        pollingTimer = nil\n    }\n    \n    deinit {\n        stopPolling()\n    }\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- Used by HotkeyManager (checks before registering)\n- Used by PasteSimulator (checks before simulating)\n- Singleton accessible app-wide\n- @Published property updates UI automatically\n- Part of SettingsView TabView (oc-4tw.3)\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. NO CALLBACK FROM MACOS:\n   - macOS provides NO notification when permission granted\n   - MUST poll with Timer (2 second interval recommended)\n   - Polling is only way to detect permission change\n   - Start polling onAppear, stop onDisappear (performance)\n\n2. SYSTEM PROMPT BEHAVIOR:\n   - AXIsProcessTrustedWithOptions shows prompt ONCE per app install\n   - If user dismisses, won't show again automatically\n   - Must guide user to System Settings manually\n   - This is macOS behavior, can't override\n\n3. PERMISSION ALREADY GRANTED:\n   - User might grant before opening Permissions tab\n   - Don't show callout if already granted\n   - Just show success status\n   - Normal flow\n\n4. PERMISSION REVOKED:\n   - User can revoke in System Settings anytime\n   - Polling detects revocation\n   - UI updates to show warning again\n   - Hotkeys stop working\n\n5. MULTIPLE INSTANCES:\n   - Only one AccessibilityPermissionManager instance (singleton)\n   - Multiple views can observe same manager\n   - Polling runs once regardless of views\n\n6. APP IN BACKGROUND:\n   - Polling continues even when settings closed\n   - Consider pausing polling when app inactive (optional)\n   - Current approach: only poll when Permissions tab visible\n\n7. SYSTEM SETTINGS URL:\n   - URL scheme changed between macOS versions\n   - macOS 13+: x-apple.systempreferences:...\n   - macOS 12-: x-apple.systempreferences:com.apple.preference.security...\n   - Test on multiple versions or use latest only\n\nTESTING REQUIREMENTS:\n- Open Permissions tab without permission, see warning\n- Click \"Grant Accessibility\", system prompt appears\n- Grant permission in System Settings, UI updates within 2s\n- Revoke permission in System Settings, warning reappears\n- Click \"Open System Settings\", correct pane opens\n- Polling starts when tab appears\n- Polling stops when tab disappears\n- Multiple settings windows don't duplicate polling\n- Permission status persists across app restarts\n\nSUCCESS CRITERIA:\n- Clear visual indication of permission status\n- Prominent warning when permission not granted\n- Easy path to grant permission (1-2 clicks)\n- UI updates automatically when permission granted\n- Educational content explains why permission needed\n- Works on macOS 13+ (package requirement)\n\nCONFIGURATION OPTIONS:\n- Polling interval (2 seconds recommended)\n- Callout appearance (colors, size, icons)\n- Explanation text (can be customized)\n\nPERFORMANCE CONSIDERATIONS:\n- Polling every 2 seconds has minimal overhead\n- AXIsProcessTrusted() is very fast (\u003c1ms)\n- Timer runs on main thread (safe for UI updates)\n- Polling stops when tab not visible (efficient)\n\nSECURITY CONSIDERATIONS:\n- Permission request is transparent (user sees exactly what's requested)\n- macOS controls permission UI (can't be spoofed by app)\n- User can revoke anytime (good security model)\n- App explains usage clearly (builds trust)\n\nUI/UX DESIGN NOTES:\n- Warning callout should be IMPOSSIBLE to miss (large, yellow, top)\n- Success state should be reassuring (green, clear checkmark)\n- Action buttons should be prominent (borderedProminent style)\n- Explanation builds trust (open source, auditable)\n- Polling makes state changes feel instant\n\nALTERNATIVE APPROACHES CONSIDERED:\n1. Manual refresh button (rejected - poor UX, user must remember to click)\n2. Detect app activation (rejected - misses changes when app active)\n3. Notification API (rejected - macOS doesn't provide for accessibility)\n4. Polling is the only reliable approach\n\nMACOS API REFERENCE:\n```swift\n// Check permission (no UI)\nlet trusted: Bool = AXIsProcessTrusted()\n\n// Request permission (shows system prompt ONCE)\nlet options: NSDictionary = [kAXTrustedCheckOptionPrompt.takeUnretainedValue(): true]\nlet trusted: Bool = AXIsProcessTrustedWithOptions(options)\n\n// System Settings URL (macOS 13+)\nx-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility\n```\n\nIMPLEMENTATION ORDER:\n1. Create AccessibilityPermissionManager class\n2. Implement AXIsProcessTrusted() check\n3. Implement polling with Timer\n4. Create PermissionsTabView structure\n5. Create AccessibilityCalloutView (warning)\n6. Create PermissionStatusSection\n7. Wire up polling lifecycle (onAppear/onDisappear)\n8. Test full permission workflow\n9. Test revocation workflow\n10. Polish UI\n\nCODE ORGANIZATION:\nSources/OptimusClip/Views/Settings/Permissions/PermissionsTabView.swift\nSources/OptimusClip/Views/Settings/Permissions/AccessibilityCalloutView.swift\nSources/OptimusClip/Managers/AccessibilityPermissionManager.swift\n\nPRIORITY: P2 (CRITICAL for app functionality, but can be implemented in Phase 3)\n\nESTIMATED TIME: 90-120 minutes (includes polling logic and comprehensive UI)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:36.360284-05:00","updated_at":"2025-12-13T10:56:48.495504-05:00","closed_at":"2025-12-13T10:56:48.495504-05:00","dependencies":[{"issue_id":"oc-4tw.7","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-12T22:05:36.360734-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.7","depends_on_id":"oc-4tw.3","type":"blocks","created_at":"2025-12-12T22:23:58.047801-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-4tw.8","title":"Settings Persistence with @AppStorage","description":"BACKGROUND \u0026 CONTEXT:\nSettings persistence is the mechanism that saves user preferences to disk so they survive app restarts. In Optimus Clip, we use SwiftUI's @AppStorage property wrapper, which provides automatic persistence to UserDefaults with minimal code.\n\n@AppStorage advantages:\n- SwiftUI-native (integrates seamlessly)\n- Automatic synchronization (changes save immediately)\n- Type-safe (compile-time checking)\n- Supports basic types natively (Bool, Int, Double, String)\n- Can be extended to support custom types via RawRepresentable/Codable\n\nUserDefaults is appropriate for:\n- User preferences and settings\n- Non-sensitive configuration data\n- Small amounts of data (\u003c1MB)\n\nUserDefaults is NOT appropriate for:\n- Sensitive data (API keys) - use Keychain instead\n- Large data (history logs) - use SwiftData/SQLite instead\n- Binary data (images) - use file system instead\n\nFor MVP, we use @AppStorage for ALL settings including API keys (for simplicity). In Phase 6, we migrate API keys to Keychain while keeping other settings in @AppStorage.\n\nREAL-WORLD PROBLEM/USE CASE:\nUser configures app:\n1. Creates 3 transformations with custom hotkeys\n2. Configures OpenAI and Anthropic API keys\n3. Enables Launch at Login\n4. Sets timeout to 60 seconds\n5. Closes settings\n6. Uses app throughout day\n7. Restarts Mac\n8. Opens Optimus Clip\n9. ALL settings preserved:\n   - 3 transformations still configured\n   - Hotkeys work immediately\n   - API keys still set (don't need to re-enter)\n   - Launch at login setting remembered\n   - Timeout still 60 seconds\n\nWithout persistence:\n- User must reconfigure everything after restart\n- Transformations lost\n- API keys must be re-entered\n- Extremely poor UX\n- App unusable in practice\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. BASIC TYPES (Native Support):\n```swift\n// Boolean\n@AppStorage(\"launchAtLogin\") private var launchAtLogin = false\n\n// Integer\n@AppStorage(\"transformationTimeoutSeconds\") private var timeoutSeconds = 30\n\n// Double\n@AppStorage(\"animationSpeed\") private var animationSpeed = 1.0\n\n// String\n@AppStorage(\"openai_api_key\") private var openAIKey = \"\"\n\n// Usage in View\nToggle(\"Launch at Login\", isOn: $launchAtLogin)  // Saves automatically\n```\n\n2. ENUM TYPES (Via RawRepresentable):\n```swift\nenum TransformationType: String, Codable {\n    case algorithmic\n    case llm\n}\n\n// AppStorage works automatically because enum has String raw value\n@AppStorage(\"defaultTransformationType\") private var defaultType: TransformationType = .algorithmic\n```\n\n3. COMPLEX TYPES (Via Codable + Custom RawRepresentable):\n```swift\n// Extension to make any Codable type work with @AppStorage\nextension Array: RawRepresentable where Element: Codable {\n    public init?(rawValue: String) {\n        guard let data = rawValue.data(using: .utf8),\n              let result = try? JSONDecoder().decode([Element].self, from: data)\n        else {\n            return nil\n        }\n        self = result\n    }\n\n    public var rawValue: String {\n        guard let data = try? JSONEncoder().encode(self),\n              let result = String(data: data, encoding: .utf8)\n        else {\n            return \"[]\"\n        }\n        return result\n    }\n}\n\n// Now can use arrays of Codable types\n@AppStorage(\"transformations\") private var transformations: [TransformationConfig] = []\n```\n\n4. CUSTOM PROPERTY WRAPPER (Alternative Approach):\n```swift\n@propertyWrapper\nstruct AppStorageCodable\u003cT: Codable\u003e: DynamicProperty {\n    @AppStorage private var data: Data?\n    \n    private let defaultValue: T\n    \n    var wrappedValue: T {\n        get {\n            guard let data = data else { return defaultValue }\n            return (try? JSONDecoder().decode(T.self, from: data)) ?? defaultValue\n        }\n        nonmutating set {\n            data = try? JSONEncoder().encode(newValue)\n        }\n    }\n    \n    var projectedValue: Binding\u003cT\u003e {\n        Binding(\n            get: { wrappedValue },\n            set: { wrappedValue = $0 }\n        )\n    }\n    \n    init(wrappedValue defaultValue: T, _ key: String, store: UserDefaults = .standard) {\n        self.defaultValue = defaultValue\n        self._data = AppStorage(wrappedValue: nil, key, store: store)\n    }\n}\n\n// Usage:\n@AppStorageCodable(\"transformations\") private var transformations: [TransformationConfig] = []\n```\n\n5. SETTINGS KEYS (Constants Pattern):\n```swift\n// Define all keys as constants to prevent typos\nenum SettingsKey {\n    static let launchAtLogin = \"launchAtLogin\"\n    static let soundEffectsEnabled = \"soundEffectsEnabled\"\n    static let transformationTimeout = \"transformationTimeout\"\n    static let transformations = \"transformations\"\n    \n    // API Keys (temporary, move to Keychain in Phase 6)\n    static let openAIKey = \"openai_api_key\"\n    static let anthropicKey = \"anthropic_api_key\"\n    static let openRouterKey = \"openrouter_api_key\"\n    \n    // Ollama\n    static let ollamaHost = \"ollama_host\"\n    static let ollamaPort = \"ollama_port\"\n    \n    // AWS Bedrock\n    static let awsAuthMethod = \"aws_auth_method\"\n    static let awsProfile = \"aws_profile\"\n    static let awsRegion = \"aws_region\"\n}\n\n// Usage:\n@AppStorage(SettingsKey.launchAtLogin) private var launchAtLogin = false\n```\n\n6. CENTRALIZED SETTINGS MANAGER (Optional Pattern):\n```swift\n@MainActor\nclass SettingsManager: ObservableObject {\n    static let shared = SettingsManager()\n    \n    @AppStorage(SettingsKey.launchAtLogin) var launchAtLogin = false\n    @AppStorage(SettingsKey.soundEffectsEnabled) var soundEffectsEnabled = true\n    @AppStorage(SettingsKey.transformationTimeout) var transformationTimeout = 30.0\n    @AppStorageCodable(SettingsKey.transformations) var transformations: [TransformationConfig] = []\n    \n    private init() {}\n    \n    // Convenience methods\n    func resetToDefaults() {\n        launchAtLogin = false\n        soundEffectsEnabled = true\n        transformationTimeout = 30.0\n        transformations = []\n    }\n    \n    func exportSettings() -\u003e Data? {\n        // Export all settings as JSON\n        let settings = [\n            \"launchAtLogin\": launchAtLogin,\n            \"soundEffectsEnabled\": soundEffectsEnabled,\n            \"transformationTimeout\": transformationTimeout,\n            \"transformations\": transformations\n        ] as [String : Any]\n        \n        return try? JSONSerialization.data(withJSONObject: settings)\n    }\n}\n\n// Usage in views:\n@StateObject private var settings = SettingsManager.shared\nToggle(\"Launch at Login\", isOn: $settings.launchAtLogin)\n```\n\n7. DEFAULT VALUES STRATEGY:\n```swift\n// Define defaults in one place\nstruct DefaultSettings {\n    static let launchAtLogin = false\n    static let soundEffectsEnabled = true\n    static let transformationTimeout = 30.0\n    static let ollamaHost = \"http://localhost\"\n    static let ollamaPort = \"11434\"\n    static let awsRegion = \"us-east-1\"\n}\n\n// Use in @AppStorage declarations\n@AppStorage(SettingsKey.launchAtLogin) \nprivate var launchAtLogin = DefaultSettings.launchAtLogin\n```\n\n8. MIGRATION STRATEGY (Phase 6 - API Keys to Keychain):\n```swift\nclass SettingsMigration {\n    static func migrateAPIKeysToKeychain() {\n        // Read from UserDefaults\n        let openAIKey = UserDefaults.standard.string(forKey: SettingsKey.openAIKey) ?? \"\"\n        let anthropicKey = UserDefaults.standard.string(forKey: SettingsKey.anthropicKey) ?? \"\"\n        \n        // Write to Keychain (if not empty)\n        if !openAIKey.isEmpty {\n            KeychainManager.shared.save(openAIKey, for: .openAI)\n            UserDefaults.standard.removeObject(forKey: SettingsKey.openAIKey)\n        }\n        \n        if !anthropicKey.isEmpty {\n            KeychainManager.shared.save(anthropicKey, for: .anthropic)\n            UserDefaults.standard.removeObject(forKey: SettingsKey.anthropicKey)\n        }\n        \n        // Mark migration complete\n        UserDefaults.standard.set(true, forKey: \"apiKeysMigrated\")\n    }\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- Used by ALL settings views (Transformations, Providers, General, Permissions)\n- Read by HotkeyManager (transformations list)\n- Read by TransformationEngine (provider config)\n- Read by LLM clients (API keys)\n- Replaced by Keychain for API keys in Phase 6\n- Parallel to SwiftData for history (Phase 6)\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. IMMEDIATE PERSISTENCE:\n   - @AppStorage saves changes IMMEDIATELY\n   - No \"Save\" button needed\n   - Can't cancel changes (no undo)\n   - This is macOS standard behavior\n\n2. TYPE SAFETY:\n   - @AppStorage is type-safe at compile time\n   - Can't accidentally read String as Int\n   - Better than raw UserDefaults (runtime errors)\n\n3. DEFAULT VALUES:\n   - Default value used if key doesn't exist\n   - First read returns default\n   - First write creates key\n   - Can't distinguish \"default\" from \"user set to default\"\n\n4. CODABLE ENCODING:\n   - JSONEncoder can fail for some types\n   - Fallback to default value on decode failure\n   - Data corruption returns default (safe)\n\n5. PERFORMANCE:\n   - UserDefaults is in-memory cache\n   - Writes are asynchronous to disk\n   - Safe to write frequently (debounced internally)\n   - Reading is O(1) (hash map)\n\n6. SIZE LIMITS:\n   - UserDefaults suitable for \u003c1MB total\n   - Very large arrays should use SwiftData\n   - TransformationConfig array is small (dozens, not thousands)\n\n7. ICLOUD SYNC:\n   - UserDefaults does NOT sync to iCloud by default\n   - NSUbiquitousKeyValueStore for iCloud sync (future)\n   - Not needed for MVP (single-device app)\n\n8. CONCURRENT ACCESS:\n   - UserDefaults is thread-safe\n   - @AppStorage is @MainActor (safe)\n   - No locking needed\n\nTESTING REQUIREMENTS:\n- Set value, restart app, verify persisted\n- Change value, verify saves immediately\n- Delete UserDefaults, verify defaults load\n- Corrupt JSON, verify defaults fallback\n- Save 50 transformations, verify performance\n- Modify setting in one view, verify updates in another\n- Test all data types (Bool, Int, Double, String, Array)\n\nSUCCESS CRITERIA:\n- All settings persist across restarts\n- Changes save immediately (no Save button)\n- Type-safe access (compile-time checking)\n- Graceful handling of corrupt data\n- No performance issues\n- Works with complex types (arrays of structs)\n\nCONFIGURATION OPTIONS:\n- UserDefaults suite (default is .standard)\n- JSON encoder settings (pretty print, date strategy)\n- Key naming convention (snake_case vs camelCase)\n\nPERFORMANCE CONSIDERATIONS:\n- @AppStorage reads are fast (O(1))\n- @AppStorage writes are debounced automatically\n- JSON encoding is fast for small objects (\u003c1ms)\n- No network calls\n- Minimal memory overhead\n\nSECURITY CONSIDERATIONS:\n- UserDefaults stored in ~/Library/Preferences/\n- Not encrypted (plain text plist)\n- Readable by user and any process running as user\n- OK for preferences, NOT OK for sensitive data\n- API keys MUST move to Keychain in Phase 6\n\nDEBUGGING TIPS:\n```bash\n# View UserDefaults file\ndefaults read com.yourname.optimusclip\n\n# Delete all UserDefaults (reset)\ndefaults delete com.yourname.optimusclip\n\n# Set value manually (testing)\ndefaults write com.yourname.optimusclip launchAtLogin -bool true\n```\n\nUSERDEFAULTS FILE LOCATION:\n~/Library/Preferences/com.yourname.optimusclip.plist\n\nALTERNATIVE APPROACHES:\n\n1. Manual UserDefaults (more verbose):\n```swift\nvar launchAtLogin: Bool {\n    get { UserDefaults.standard.bool(forKey: \"launchAtLogin\") }\n    set { UserDefaults.standard.set(newValue, forKey: \"launchAtLogin\") }\n}\n```\nRejected: @AppStorage is simpler and SwiftUI-native.\n\n2. Codable + JSON file (more control):\n```swift\nstruct Settings: Codable {\n    var launchAtLogin: Bool\n    // ... all settings\n}\n\nfunc saveSettings(_ settings: Settings) {\n    let data = try? JSONEncoder().encode(settings)\n    try? data?.write(to: settingsURL)\n}\n```\nRejected: UserDefaults is simpler and more appropriate for settings.\n\n3. Property list (manual):\nRejected: UserDefaults abstracts this already.\n\nIMPLEMENTATION ORDER:\n1. Define SettingsKey constants\n2. Add RawRepresentable extension for Array\u003cCodable\u003e\n3. Test @AppStorage with basic types\n4. Test @AppStorage with TransformationConfig array\n5. Verify persistence across restarts\n6. Add SettingsManager (optional)\n7. Document all settings keys\n8. Plan migration to Keychain (Phase 6)\n\nCODE ORGANIZATION:\nSources/OptimusClip/Settings/SettingsKey.swift\nSources/OptimusClip/Settings/SettingsManager.swift (optional)\nSources/OptimusClip/Extensions/Array+RawRepresentable.swift\n\nPRIORITY: P2 (Required for ALL settings to work, foundational)\n\nESTIMATED TIME: 60-90 minutes (includes RawRepresentable extension and testing)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:36.986857-05:00","updated_at":"2025-12-13T11:43:31.823225-05:00","closed_at":"2025-12-13T11:43:31.823225-05:00","dependencies":[{"issue_id":"oc-4tw.8","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-12T22:05:36.987289-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.8","depends_on_id":"oc-4tw.4","type":"blocks","created_at":"2025-12-12T23:54:18.531406-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.8","depends_on_id":"oc-4tw.5","type":"blocks","created_at":"2025-12-12T23:54:19.002309-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.8","depends_on_id":"oc-4tw.6","type":"blocks","created_at":"2025-12-12T23:54:19.558915-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.8","depends_on_id":"oc-4tw.7","type":"blocks","created_at":"2025-12-12T23:54:20.055987-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-4tw.9","title":"Hotkey Recorder Integration","description":"BACKGROUND \u0026 CONTEXT:\nThe KeyboardShortcuts.Recorder is a pre-built SwiftUI component from the KeyboardShortcuts package that provides a native macOS UI for recording keyboard shortcuts. It handles ALL the complex logic:\n- Capturing key combinations\n- Displaying shortcuts in human-readable format (\"⌘⌥V\" instead of \"Command Option V\")\n- Detecting conflicts with system shortcuts\n- Validating shortcuts (some combinations are invalid)\n- Providing visual feedback during recording\n- Integrating with package's persistence system\n\nThis component is THE reason we use the KeyboardShortcuts package instead of building hotkey support from scratch. It would take days to replicate this functionality correctly.\n\nWHAT IT LOOKS LIKE:\n- Before recording: Rounded rectangle with \"Record Shortcut\" text\n- During recording: Pulsing border, \"Press keys...\" text\n- After recording: Shows shortcut (e.g., \"⌘⌥V\"), X button to clear\n- If conflict: Yellow warning badge, tooltip explains conflict\n\nThe Recorder integrates into the TransformationEditorView (oc-4tw.4) where users configure each transformation's hotkey.\n\nREAL-WORLD PROBLEM/USE CASE:\nUser configuring transformation hotkey:\n1. Opens Transformations tab\n2. Selects \"Quick Fix\" transformation\n3. Sees Recorder component showing current shortcut: \"⌘⌥V\"\n4. Clicks Recorder to change shortcut\n5. Recorder enters recording mode: \"Press keys...\"\n6. User presses Cmd+Shift+X\n7. Recorder validates: not a system shortcut ✓\n8. Recorder displays: \"⌘⇧X\"\n9. Shortcut automatically saved to package storage\n10. HotkeyManager automatically updates registration\n11. User closes settings\n12. Presses Cmd+Shift+X → transformation executes!\n\nWithout Recorder component:\n- Must build custom key capture UI\n- Must convert keycodes to symbols (complex)\n- Must detect system shortcut conflicts (hard)\n- Must validate key combinations (many edge cases)\n- Must persist shortcuts manually\n- Weeks of development, many bugs\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. BASIC USAGE (Built-in Transformations):\n```swift\nimport KeyboardShortcuts\n\n// In TransformationEditorView\nKeyboardShortcuts.Recorder(\n    \"Keyboard Shortcut:\",\n    name: .quickFix  // KeyboardShortcuts.Name.quickFix\n)\n```\n\nThat's it! The package handles everything else.\n\n2. DYNAMIC USAGE (User-Created Transformations):\n```swift\nstruct TransformationEditorView: View {\n    @Binding var transformation: TransformationConfig\n    \n    var body: some View {\n        Form {\n            // ... other fields\n            \n            // Hotkey Recorder\n            KeyboardShortcuts.Recorder(\n                \"Keyboard Shortcut:\",\n                name: transformation.shortcutName\n            )\n        }\n    }\n}\n\n// TransformationConfig model\nstruct TransformationConfig: Identifiable, Codable {\n    var id: UUID\n    var name: String\n    // ... other properties\n    \n    // Computed property generates unique Name\n    var shortcutName: KeyboardShortcuts.Name {\n        KeyboardShortcuts.Name(\"transformation_\\(id.uuidString)\")\n    }\n}\n```\n\n3. WITH CUSTOM STYLING:\n```swift\nKeyboardShortcuts.Recorder(\n    \"Hotkey:\",\n    name: transformation.shortcutName\n)\n.frame(width: 200)  // Fixed width\n.help(\"Press the key combination you want to use\")  // Tooltip\n```\n\n4. PROGRAMMATICALLY SET SHORTCUT:\n```swift\n// Set default shortcut for built-in transformation\nKeyboardShortcuts.setShortcut(\n    .init(.v, modifiers: [.command, .option]),\n    for: .quickFix\n)\n\n// Clear shortcut\nKeyboardShortcuts.reset(.quickFix)\n\n// Check if shortcut is set\nif let shortcut = KeyboardShortcuts.getShortcut(for: .quickFix) {\n    print(\"Current shortcut: \\(shortcut)\")\n}\n```\n\n5. ENABLE/DISABLE SHORTCUT:\n```swift\n// Disable shortcut (won't fire, but still recorded)\nKeyboardShortcuts.disable(.quickFix)\n\n// Enable shortcut\nKeyboardShortcuts.enable(.quickFix)\n```\n\n6. HANDLING RECORDER STATE:\n```swift\n// The Recorder automatically:\n// - Saves to UserDefaults when user records shortcut\n// - Updates immediately (no Save button needed)\n// - Syncs with HotkeyManager's registrations\n// - Shows conflicts (yellow badge)\n\n// We don't need to handle onChange - package does it all\n```\n\n7. CREATING DYNAMIC NAMES:\n```swift\nextension KeyboardShortcuts.Name {\n    // Built-in transformations (static)\n    static let quickFix = Self(\"quickFix\", default: .init(.v, modifiers: [.command, .option]))\n    static let smartFix = Self(\"smartFix\", default: .init(.s, modifiers: [.command, .option]))\n    \n    // Dynamic transformations (runtime)\n    // Note: Don't create Names repeatedly - cache in model\n    static func transformation(_ id: UUID) -\u003e Self {\n        Self(\"transformation_\\(id.uuidString)\")\n    }\n}\n\n// Usage with dynamic transformations:\nKeyboardShortcuts.Recorder(\n    \"Hotkey:\",\n    name: .transformation(transformation.id)\n)\n```\n\n8. INTEGRATION WITH HOTKEYMANAGER:\n```swift\n// When user records shortcut via Recorder:\n// 1. Recorder saves to UserDefaults automatically\n// 2. HotkeyManager must RE-REGISTER handler\n\n// In TransformationEditorView:\nKeyboardShortcuts.Recorder(\"Hotkey:\", name: transformation.shortcutName)\n    .onChange(of: transformation.id) { _, _ in\n        // Re-register when transformation changes\n        HotkeyManager.shared.register(transformation: transformation)\n    }\n\n// OR: HotkeyManager observes UserDefaults changes (better)\nclass HotkeyManager {\n    init() {\n        // Observe shortcut changes\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(shortcutChanged),\n            name: UserDefaults.didChangeNotification,\n            object: nil\n        )\n    }\n    \n    @objc private func shortcutChanged() {\n        // Re-register all shortcuts\n        registerAll()\n    }\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- Used in TransformationsTabView (oc-4tw.4) for hotkey configuration\n- Requires KeyboardShortcuts package (oc-4tw.1)\n- Shortcuts used by HotkeyManager (oc-4tw.2) for registration\n- Persists to UserDefaults automatically (oc-4tw.8)\n- Part of Phase 3 hotkey infrastructure\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. SYSTEM SHORTCUT CONFLICTS:\n   - Recorder detects conflicts automatically\n   - Shows yellow warning badge\n   - Tooltip explains which system shortcut conflicts\n   - Shortcut still records (user choice to override)\n   - Handler may not fire if system captures first\n\n2. DUPLICATE SHORTCUTS:\n   - Package does NOT detect conflicts between our own shortcuts\n   - Two transformations can have same shortcut\n   - Last-registered handler wins (KeyboardShortcuts behavior)\n   - Must manually validate before allowing duplicate\n\n3. INVALID KEY COMBINATIONS:\n   - Some combinations invalid (e.g., just Shift, just Cmd)\n   - Recorder rejects invalid combinations automatically\n   - Shows \"Invalid shortcut\" message briefly\n   - User must try different combination\n\n4. NAME LIFECYCLE:\n   - Name must exist for lifetime of Recorder\n   - Dynamic Names should be created once, cached\n   - Don't create new Name on every View refresh (memory leak)\n   - Store in TransformationConfig (computed property OK)\n\n5. RECORDER IN LIST:\n   - Can have multiple Recorders visible simultaneously\n   - Each operates independently\n   - No interference between instances\n   - Performance fine even with 50+ transformations\n\n6. CLEAR SHORTCUT:\n   - X button on Recorder clears shortcut\n   - Sets value to nil in storage\n   - Handler automatically unregistered\n   - Transformation still exists (just no hotkey)\n\n7. MISSING ACCESSIBILITY PERMISSION:\n   - Recorder works fine (can record shortcuts)\n   - Handlers won't fire (no accessibility permission)\n   - Show warning in Permissions tab, not on Recorder\n   - Separation of concerns\n\n8. LOCALIZATION:\n   - Recorder uses system locale automatically\n   - Shortcuts display correctly in all languages\n   - \"⌘\" vs \"Cmd\" depending on locale\n   - No manual localization needed\n\nTESTING REQUIREMENTS:\n- Record shortcut, verify saves immediately\n- Record shortcut, restart app, verify persisted\n- Record conflicting shortcut, verify warning shown\n- Clear shortcut with X button, verify cleared\n- Record same shortcut for two transformations, verify conflict\n- Record invalid combination, verify rejection\n- Test with 10+ Recorders visible, verify performance\n- Test without accessibility permission, verify recording still works\n- Test shortcut firing after recording\n\nSUCCESS CRITERIA:\n- Shortcut recording works reliably\n- Conflicts detected and shown\n- Invalid shortcuts rejected\n- Shortcuts persist across restarts\n- Clear button removes shortcuts\n- No performance issues with many Recorders\n- Integrates seamlessly with HotkeyManager\n\nCONFIGURATION OPTIONS:\n- Label text (\"Keyboard Shortcut:\" or \"Hotkey:\" or \"\")\n- Frame width (optional, default auto-sizes)\n- Tooltip/help text (optional)\n\nPERFORMANCE CONSIDERATIONS:\n- Recorder is lightweight (\u003c1MB memory each)\n- Recording doesn't block UI\n- Persistence automatic and fast\n- 50+ Recorders on screen: no performance issues\n\nSECURITY CONSIDERATIONS:\n- Shortcuts stored in UserDefaults (not sensitive)\n- Readable by user (expected, not a security issue)\n- No API keys or passwords in shortcuts\n- Recording requires accessibility permission (system protection)\n\nUI/UX DESIGN NOTES:\n- Recorder has native macOS appearance (matches system)\n- Light/dark mode support automatic\n- Focus ring when recording (standard)\n- Recording state visually distinct (pulsing border)\n- Clear affordance (X button appears on hover)\n\nRECORDER APPEARANCE STATES:\n1. Empty: \"Record Shortcut\" text, gray border\n2. Focused: Blue focus ring (standard macOS)\n3. Recording: Pulsing border, \"Press keys...\" text\n4. Recorded: Shows shortcut symbols, X button on hover\n5. Conflict: Yellow badge, warning tooltip\n6. Invalid: Brief error message, returns to previous state\n\nSHORTCUT SYMBOL MAPPING:\n- Command: ⌘\n- Option/Alt: ⌥\n- Shift: ⇧\n- Control: ⌃\n- Function: fn\n- Caps Lock: ⇪\n- Letters: A-Z (uppercase)\n- Numbers: 0-9\n- Arrows: ← ↑ → ↓\n- Special: Space, Tab, Return, Delete, Escape\n\nALTERNATIVE APPROACHES (DON'T USE):\n1. Manual key capture with CGEventTap (hundreds of lines, buggy)\n2. NSEvent.addLocalMonitorForEvents (doesn't capture global shortcuts)\n3. Carbon Event Manager (deprecated)\n\nKeyboardShortcuts.Recorder is THE way to do this. Don't reinvent.\n\nPACKAGE VERSION:\n- Minimum: 2.0.0\n- Latest: Check GitHub releases\n- Stable: Yes (battle-tested in many apps)\n\nDOCUMENTATION:\n- README: https://github.com/sindresorhus/KeyboardShortcuts\n- Example app: Included in repository\n- API docs: Generated from code comments\n\nIMPLEMENTATION ORDER:\n1. Ensure KeyboardShortcuts package added (oc-4tw.1)\n2. Create Name extensions for built-in transformations\n3. Add Recorder to TransformationEditorView\n4. Test recording with single transformation\n5. Implement dynamic Names for user transformations\n6. Test recording with multiple transformations\n7. Verify integration with HotkeyManager\n8. Test conflict detection\n9. Test clear functionality\n10. Document usage patterns\n\nCODE ORGANIZATION:\nSources/OptimusClip/Views/Settings/Transformations/TransformationEditorView.swift\nSources/OptimusClip/Settings/HotkeyNames.swift\n\nCOMMON BUGS TO AVOID:\n1. Creating new Name on every render (memory leak)\n2. Not re-registering handler after shortcut change\n3. Allowing duplicate shortcuts (confusing UX)\n4. Forgetting to import KeyboardShortcuts\n5. Using wrong initializer for Name\n\nPRIORITY: P2 (Required for hotkey configuration, blocks Phase 3 completion)\n\nESTIMATED TIME: 45-60 minutes (mostly integration and testing)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:37.59248-05:00","updated_at":"2025-12-13T11:46:34.13137-05:00","closed_at":"2025-12-13T11:46:34.13137-05:00","dependencies":[{"issue_id":"oc-4tw.9","depends_on_id":"oc-4tw","type":"parent-child","created_at":"2025-12-12T22:05:37.592978-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.9","depends_on_id":"oc-4tw.1","type":"blocks","created_at":"2025-12-12T22:23:56.406279-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-4tw.9","depends_on_id":"oc-4tw.4","type":"blocks","created_at":"2025-12-12T23:54:21.325494-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-57r","title":"SECURITY: Missing clipboard input size validation","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-16T19:54:51.201579-05:00","updated_at":"2025-12-16T20:35:11.29853-05:00","closed_at":"2025-12-16T20:35:11.29853-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T20:05:29.841364-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-5uo","title":"Add AWS_BEARER_TOKEN_BEDROCK auth mechanism","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-14T00:31:37.533342-05:00","updated_at":"2025-12-14T20:23:11.000032-05:00","closed_at":"2025-12-14T20:23:11.000032-05:00"}
{"id":"oc-5xm","title":"Add menu bar icon to OptimusClip","description":"Add menu bar icon and app icon to OptimusClip. Source icons in ~/Downloads/optimus-clip-icon/. App icon: use apple-devices/AppIcon.appiconset. Menu bar: create 18x18, 36x36, 54x54 template images from robot character.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-27T22:41:46.928585-05:00","created_by":"Chris Edwards","updated_at":"2025-12-27T22:42:24.873008-05:00"}
{"id":"oc-63a","title":"Implement HUD notification system for transformation progress","description":"HUD overlay at bottom of screen showing transformation progress during LLM calls. Shows: transformation name, connection status, elapsed time, success/error states. Supports Esc to cancel. Brief flash for instant transforms. Subtle sound on paste.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-16T10:18:09.192881-05:00","updated_at":"2025-12-16T20:35:11.305951-05:00","closed_at":"2025-12-16T20:35:11.305951-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T14:14:45.957621-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"feature"}
{"id":"oc-6fh","title":"Inconsistent raw values across LLMProviderKind, LLMProvider, and ModelProvider enums","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-16T19:06:58.80545-05:00","updated_at":"2025-12-16T20:35:11.309293-05:00","closed_at":"2025-12-16T20:35:11.309293-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:14:15.633731-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-6pt","title":"Remove history section from General tab (now has dedicated History tab)","status":"open","priority":3,"issue_type":"chore","created_at":"2025-12-16T20:37:53.032577-05:00","updated_at":"2025-12-16T20:37:53.032577-05:00"}
{"id":"oc-74q","title":"Phase 2 - Clipboard \u0026 Paste","description":"BACKGROUND \u0026 CONTEXT:\nPhase 2 implements the core clipboard manipulation functionality that makes Optimus Clip useful. This phase transforms the app from a basic menu bar presence (Phase 1) into functional clipboard middleware that can intercept, transform, and paste content.\n\nWHY THIS IS CRITICAL:\n- This is the value proposition of Optimus Clip - intelligent clipboard transformations\n- Without this, the app is just a menu bar icon with no functionality\n- All future phases (AI, rules, UI) build on this foundation\n\nARCHITECTURE OVERVIEW:\nThe clipboard manipulation flow follows this sequence:\n1. Monitor clipboard for changes (ClipboardMonitor polling at 150ms)\n2. Detect when user wants transformation (hotkey trigger from Phase 1)\n3. Read clipboard content with safety checks (binary detection, self-write marker)\n4. Transform content (via TransformationEngine - simple pass-through for now, LLM later)\n5. Write transformed content back to clipboard (with self-write marker)\n6. Simulate paste (CGEvent API with Cmd+V simulation)\n\nKEY TECHNICAL CHALLENGES:\n- Avoiding infinite loops (solved via self-write marker system)\n- Binary safety (prevent crashes from images/files sent to text processors)\n- Accessibility permissions (required for paste simulation)\n- Race conditions with promised pasteboard data (80ms grace delay)\n- Power efficiency (DispatchSourceTimer with 50ms leeway)\n\nDEPENDENCIES:\n- Requires Phase 1 (menu bar, hotkey system) to be complete\n- Phase 3 (AI transformations) and Phase 4 (rule system) will extend the transform step\n\nSUCCESS CRITERIA:\n- Can read text from clipboard reliably\n- Self-write marker prevents reprocessing loops\n- Binary data detected and skipped safely\n- Paste simulation works with accessibility permission\n- Full end-to-end flow: hotkey → read → transform → write → paste","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-12T22:04:42.418783-05:00","updated_at":"2025-12-13T11:12:52.81266-05:00","closed_at":"2025-12-13T11:12:52.81266-05:00","dependencies":[{"issue_id":"oc-74q","depends_on_id":"oc-uzt","type":"blocks","created_at":"2025-12-12T22:18:09.241328-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-74q.1","title":"Implement ClipboardMonitor Class","description":"BACKGROUND \u0026 CONTEXT:\nThe ClipboardMonitor is responsible for continuously checking the system clipboard for changes. macOS doesn't provide clipboard change notifications, so we must poll NSPasteboard.general.changeCount to detect when content changes.\n\nWHY THIS IS NEEDED:\n- Foundation for detecting when clipboard content changes\n- Enables triggering transformations on clipboard changes (future feature)\n- Must be efficient to avoid draining battery on laptops\n- Must be reliable to catch all clipboard changes\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. POLLING MECHANISM - DispatchSourceTimer:\n   - Use DispatchSourceTimer (not Timer) for better power efficiency\n   - Poll interval: 150ms (7 checks per second)\n   - Leeway: 50ms (allows system to coalesce timer events for power savings)\n   - This balance gives responsive detection without excessive CPU usage\n\n2. CHANGE DETECTION - NSPasteboard.changeCount:\n   - Track NSPasteboard.general.changeCount across poll cycles\n   - When changeCount increases, clipboard content has changed\n   - Store previous changeCount to detect deltas\n   - changeCount is a simple Int that increments on every clipboard write\n\n3. GRACE DELAY - 80ms wait for promised data:\n   - Some apps use NSPasteboard \"promised\" data (lazy loading)\n   - They write to clipboard but data isn't immediately available\n   - Wait 80ms after detecting change before reading content\n   - Use DispatchQueue.main.asyncAfter(deadline:) for grace delay\n   - This prevents reading empty/incomplete data\n\n4. TEXT READING WITH FALLBACKS:\n   - Primary: NSPasteboard.string(forType: .string)\n   - Fallback 1: readObjects(forClasses: [NSString.self]) for public.utf8-plain-text\n   - Fallback 2: data(forType: NSPasteboard.PasteboardType(\"public.utf16-external-plain-text\"))\n   - Fallback 3: data(forType: NSPasteboard.PasteboardType(\"public.text\"))\n   - Different apps write different UTI types, fallbacks ensure compatibility\n\n5. LIFECYCLE MANAGEMENT:\n   - Start monitoring when app launches\n   - Stop monitoring gracefully on app termination\n   - Suspend/resume capability for performance tuning\n   - Must be safe to call start/stop multiple times\n\nCODE PATTERNS:\n```swift\nclass ClipboardMonitor {\n    private var timer: DispatchSourceTimer?\n    private var lastChangeCount: Int = 0\n    private let pollInterval: TimeInterval = 0.15  // 150ms\n    private let leeway: DispatchTimeInterval = .milliseconds(50)\n    private let graceDelay: TimeInterval = 0.08  // 80ms\n    \n    func startMonitoring() {\n        let timer = DispatchSource.makeTimerSource(queue: .main)\n        timer.schedule(deadline: .now(), repeating: pollInterval, leeway: leeway)\n        timer.setEventHandler { [weak self] in\n            self?.checkClipboard()\n        }\n        timer.resume()\n        self.timer = timer\n    }\n    \n    private func checkClipboard() {\n        let currentCount = NSPasteboard.general.changeCount\n        if currentCount != lastChangeCount {\n            lastChangeCount = currentCount\n            // Wait grace period for promised data\n            DispatchQueue.main.asyncAfter(deadline: .now() + graceDelay) {\n                self.readClipboardContent()\n            }\n        }\n    }\n}\n```\n\nARCHITECTURE CONNECTIONS:\n- Called by TransformationFlowCoordinator when hotkey pressed\n- Provides clipboard content to TransformationEngine\n- Works alongside self-write marker system to prevent loops\n- Foundation for future automatic transformation triggers\n\nIMPORTANT CONSIDERATIONS:\n- Must be memory efficient (no retained clipboard history)\n- Timer must be properly invalidated to prevent leaks\n- Weak self references in closures to prevent retain cycles\n- Main queue for UI safety and NSPasteboard access","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:02.266967-05:00","updated_at":"2025-12-13T10:08:45.823483-05:00","closed_at":"2025-12-13T10:08:45.823483-05:00","dependencies":[{"issue_id":"oc-74q.1","depends_on_id":"oc-74q","type":"parent-child","created_at":"2025-12-12T22:05:02.267735-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.1","depends_on_id":"oc-uzt","type":"blocks","created_at":"2025-12-12T23:53:54.475143-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-74q.2","title":"Implement Self-Write Marker System","description":"## Task: Implement Self-Write Marker System\n\n### Background \u0026 The Infinite Loop Problem\n\nThis is one of the most critical safety mechanisms in Optimus Clip. Without it, the app would enter an infinite loop:\n\n```\n1. User copies text → clipboard changes\n2. App detects change → reads clipboard\n3. App transforms text → writes to clipboard\n4. Clipboard changes → app detects change (ITS OWN WRITE!)\n5. App reads clipboard → transforms again\n6. GOTO 4 (infinite loop until crash)\n```\n\nThe self-write marker solves this by \"tagging\" clipboard writes from Optimus Clip so the app can recognize and ignore them.\n\n### How It Works\n\n**The Marker:** A custom pasteboard type that contains no useful data - it exists purely as a flag.\n\n```swift\nlet marker = NSPasteboard.PasteboardType(\"com.optimusclip.marker\")\n```\n\n**When Writing to Clipboard:**\n```swift\nfunc writeToClipboard(_ text: String) {\n    let pasteboard = NSPasteboard.general\n    pasteboard.clearContents()\n\n    // Declare BOTH the text type AND our marker\n    pasteboard.declareTypes([.string, marker], owner: nil)\n\n    // Write the actual text\n    pasteboard.setString(text, forType: .string)\n\n    // Write empty data for the marker (just its presence matters)\n    pasteboard.setData(Data(), forType: marker)\n}\n```\n\n**When Reading from Clipboard:**\n```swift\nfunc shouldProcessClipboard() -\u003e Bool {\n    let pasteboard = NSPasteboard.general\n\n    // If OUR marker is present, this is our own write - SKIP IT\n    if pasteboard.types?.contains(marker) == true {\n        return false  // Don't process our own writes\n    }\n\n    return true  // Safe to process - this is external content\n}\n```\n\n### Why This Approach Works\n\n1. **Pasteboard types persist** - Until another app clears the pasteboard, all types remain\n2. **Other apps don't use our marker** - Custom type is unique to Optimus Clip\n3. **Marker survives paste** - When user pastes, clipboard still has marker (content consumed, clipboard unchanged)\n4. **No timing issues** - Marker check is synchronous and atomic with read\n\n### Alternative Approaches (And Why They're Worse)\n\n**Alternative 1: Change Count Tracking**\n```swift\n// After writing, remember the changeCount\nlastWriteChangeCount = NSPasteboard.general.changeCount\n\n// When checking, compare\nif NSPasteboard.general.changeCount == lastWriteChangeCount {\n    return false  // Our write\n}\n```\n**Problem:** Race condition. If user copies something between our write and our check, we miss it.\n\n**Alternative 2: Content Hash Comparison**\n```swift\n// Store hash of what we wrote\nlastWrittenHash = transformedText.hashValue\n\n// Compare when reading\nif clipboardText.hashValue == lastWrittenHash {\n    return false  // Probably our write\n}\n```\n**Problem:** Hash collision (unlikely but possible). Also fails if transformation is idempotent (same input → same output).\n\n**Alternative 3: Timestamp-based**\n```swift\n// Ignore changes within 100ms of our write\nif Date().timeIntervalSince(lastWriteTime) \u003c 0.1 {\n    return false\n}\n```\n**Problem:** Arbitrary timing. User could paste very fast, or system could be slow.\n\n**The Marker Approach is Best Because:**\n- No race conditions\n- No timing dependencies\n- 100% deterministic\n- Zero false positives\n- Used by professional clipboard apps (Paste, Maccy, etc.)\n\n### Implementation Details\n\n**Custom Pasteboard Type String:**\n- Format: Reverse DNS (`com.optimusclip.marker`)\n- Must be unique across all apps on the system\n- Doesn't need to be registered anywhere - just use it\n\n**Thread Safety:**\n- NSPasteboard operations should be on main thread\n- Marker check and content read should be atomic (no other ops between)\n\n**Multiple Types:**\n- We write BOTH `.string` AND marker\n- Other apps only read `.string` - marker is invisible to them\n- When pasting, only `.string` content is inserted\n\n### Code Pattern for ClipboardManager\n\n```swift\nfinal class ClipboardManager {\n    static let shared = ClipboardManager()\n\n    private let pasteboard = NSPasteboard.general\n    private let selfWriteMarker = NSPasteboard.PasteboardType(\"com.optimusclip.marker\")\n\n    /// Check if clipboard content is safe to process (not our own write)\n    func isSafeToProcess() -\u003e Bool {\n        guard let types = pasteboard.types else { return false }\n        return !types.contains(selfWriteMarker)\n    }\n\n    /// Read text if safe to process\n    func readTextIfSafe() -\u003e String? {\n        guard isSafeToProcess() else { return nil }\n        return pasteboard.string(forType: .string)\n    }\n\n    /// Write text with self-write marker\n    func write(_ text: String) {\n        pasteboard.clearContents()\n        pasteboard.declareTypes([.string, selfWriteMarker], owner: nil)\n        pasteboard.setString(text, forType: .string)\n        pasteboard.setData(Data(), forType: selfWriteMarker)\n    }\n}\n```\n\n### Edge Cases \u0026 Gotchas\n\n1. **clearContents() is required** - Must clear before declaring new types\n2. **declareTypes before setString** - Order matters for NSPasteboard\n3. **Marker is app-specific** - Different marker for different apps if you make multiple\n4. **Marker survives app restart** - Clipboard persists, marker persists until another copy\n5. **Rich text handling** - May need to declare multiple content types alongside marker\n\n### Testing Checklist\n\n- [ ] Write text with marker → verify marker present in `pasteboard.types`\n- [ ] Read immediately after write → verify `isSafeToProcess()` returns false\n- [ ] External app copies text → verify `isSafeToProcess()` returns true\n- [ ] Rapid write-read cycles → verify no infinite loops\n- [ ] User pastes our content → verify clipboard still has marker (didn't trigger reprocess)\n- [ ] App restart → verify old marker still detected\n\n### Success Criteria\n- Zero infinite loop scenarios in testing\n- Marker correctly identifies all self-writes\n- External clipboard content always processed\n- No false positives (external content incorrectly skipped)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:05:28.816472-05:00","updated_at":"2025-12-13T10:11:37.354851-05:00","closed_at":"2025-12-13T10:11:37.354851-05:00","dependencies":[{"issue_id":"oc-74q.2","depends_on_id":"oc-74q","type":"parent-child","created_at":"2025-12-12T22:05:28.817039-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-74q.3","title":"Implement Clipboard Binary Safety","description":"## Task: Implement Clipboard Binary Safety\n\n### Background \u0026 The Problem\n\nLLM providers expect text input. Sending binary data (images, PDFs, files) to a text-only API causes:\n1. **API Errors:** Most providers return 400 Bad Request for non-text\n2. **Crashes:** Some SDKs crash on malformed input\n3. **Wasted API Calls:** You get billed even for failed requests\n4. **User Confusion:** Transformation fails with cryptic error\n\n**Real Scenario:**\nUser takes screenshot (Cmd+Shift+4) → clipboard contains image data → user hits transformation hotkey → app tries to send PNG bytes to GPT-4 → chaos\n\n### What Can Be on the Clipboard\n\nmacOS clipboard (`NSPasteboard`) can hold multiple types simultaneously:\n\n| Type | Example | Action |\n|------|---------|--------|\n| `public.utf8-plain-text` | \"Hello world\" | Process ✓ |\n| `public.rtf` | Formatted text | Strip formatting, process ✓ |\n| `public.png` | Screenshot | REJECT |\n| `public.jpeg` | Photo | REJECT |\n| `public.tiff` | Image | REJECT |\n| `public.file-url` | /path/to/file.pdf | REJECT |\n| `public.html` | Web content | Extract text, process ✓ |\n\n### Detection Strategy\n\n**Priority-Based Type Checking:**\n```swift\nfunc detectClipboardContentType() -\u003e ClipboardContentType {\n    let pasteboard = NSPasteboard.general\n    guard let types = pasteboard.types else { return .empty }\n\n    // Check for binary types FIRST (they should block processing)\n    let binaryTypes: [NSPasteboard.PasteboardType] = [\n        .png, .tiff,\n        NSPasteboard.PasteboardType(\"public.jpeg\"),\n        NSPasteboard.PasteboardType(\"public.heic\"),\n        .fileURL,\n        NSPasteboard.PasteboardType(\"public.file-url\"),\n        .pdf,\n    ]\n\n    for binaryType in binaryTypes {\n        if types.contains(binaryType) {\n            return .binary(type: binaryType.rawValue)\n        }\n    }\n\n    // Check for text types\n    if types.contains(.string) || types.contains(.rtf) || types.contains(.html) {\n        return .text\n    }\n\n    return .unknown\n}\n\nenum ClipboardContentType {\n    case text\n    case binary(type: String)\n    case empty\n    case unknown\n}\n```\n\n### User Feedback for Binary Content\n\nWhen binary content is detected, DON'T just silently fail. Provide clear feedback:\n\n```swift\nfunc handleBinaryClipboard(type: String) {\n    // 1. Play system alert sound\n    NSSound.beep()\n\n    // 2. Flash menu bar icon red briefly\n    MenuBarStateManager.shared.flashError()\n\n    // 3. Show notification (optional, can be disabled)\n    if UserDefaults.standard.bool(forKey: \"showBinaryWarnings\") {\n        let notification = UNMutableNotificationContent()\n        notification.title = \"Cannot Transform\"\n        notification.body = \"Clipboard contains \\(friendlyTypeName(type)) - only text can be transformed\"\n        // Post notification...\n    }\n\n    // 4. Do NOT modify clipboard - preserve user's content\n    // 5. Do NOT simulate paste - nothing to paste\n}\n\nfunc friendlyTypeName(_ type: String) -\u003e String {\n    switch type {\n    case \"public.png\", \"public.jpeg\", \"public.tiff\", \"public.heic\":\n        return \"an image\"\n    case \"public.file-url\", \"com.apple.finder.node\":\n        return \"a file\"\n    case \"com.adobe.pdf\":\n        return \"a PDF\"\n    default:\n        return \"non-text content\"\n    }\n}\n```\n\n### Edge Cases \u0026 Special Handling\n\n**1. Rich Text (RTF)**\n- Contains text, just with formatting\n- Strip formatting and process as plain text\n- `NSAttributedString(rtf:)` → `.string` property\n\n**2. HTML Content**\n- Often contains useful text (copied from web)\n- Extract text content, strip tags\n- Or pass to LLM with \"clean up this HTML\" prompt\n\n**3. Multiple Types Present**\n- Clipboard often has BOTH image AND text\n- Example: Copy from web page = HTML + text + sometimes image preview\n- Check for text types AFTER confirming no binary types\n\n**4. Promised Data**\n- Some apps write \"promises\" - data loaded lazily\n- NSPasteboard.types may show type before data is ready\n- Our grace delay (80ms) helps with this\n\n**5. File References vs File Contents**\n- `fileURL` type contains path, not contents\n- We should NOT read file contents (security risk)\n- Treat file references as binary → reject\n\n### Implementation in ClipboardManager\n\n```swift\nfinal class ClipboardManager {\n    static let shared = ClipboardManager()\n\n    private let pasteboard = NSPasteboard.general\n\n    // Binary types that should NOT be processed\n    private let binaryTypes: Set\u003cNSPasteboard.PasteboardType\u003e = [\n        .png, .tiff, .pdf, .fileURL,\n        NSPasteboard.PasteboardType(\"public.jpeg\"),\n        NSPasteboard.PasteboardType(\"public.heic\"),\n        NSPasteboard.PasteboardType(\"public.file-url\"),\n        NSPasteboard.PasteboardType(\"com.apple.finder.node\"),\n    ]\n\n    /// Returns text if clipboard contains processable text, nil otherwise\n    func readTextIfSafe() -\u003e String? {\n        guard let types = pasteboard.types else { return nil }\n\n        // Reject if ANY binary type is present\n        for type in types {\n            if binaryTypes.contains(type) {\n                return nil  // Binary content detected\n            }\n        }\n\n        // Try to read text\n        return pasteboard.string(forType: .string)\n    }\n\n    /// Check if clipboard contains binary data\n    func containsBinaryData() -\u003e Bool {\n        guard let types = pasteboard.types else { return false }\n        return types.contains { binaryTypes.contains($0) }\n    }\n\n    /// Get description of binary content for user feedback\n    func binaryContentDescription() -\u003e String? {\n        guard let types = pasteboard.types else { return nil }\n        for type in types {\n            if binaryTypes.contains(type) {\n                return friendlyTypeName(type.rawValue)\n            }\n        }\n        return nil\n    }\n}\n```\n\n### Testing Matrix\n\n| Clipboard Content | Expected Behavior |\n|-------------------|-------------------|\n| Plain text | Transform and paste |\n| Rich text (RTF) | Strip formatting, transform, paste |\n| Screenshot (PNG) | Reject, show message, preserve clipboard |\n| Photo (JPEG) | Reject, show message |\n| PDF | Reject, show message |\n| File from Finder | Reject, show message |\n| Multiple files | Reject, show message |\n| HTML from browser | Extract text, transform, paste |\n| Empty clipboard | Do nothing silently |\n\n### Integration with Transformation Flow\n\n```\nHotkey pressed\n      │\n      ▼\nCheck for self-write marker\n      │\n      ▼\nCheck for binary content ← THIS TASK\n      │\n      ├─── Binary detected ──→ Show warning, abort\n      │\n      ▼ (text content)\nRead text from clipboard\n      │\n      ▼\nTransform\n      │\n      ▼\nWrite result + paste\n```\n\n### Success Criteria\n- [ ] Images never sent to LLM APIs\n- [ ] Files never processed\n- [ ] User gets clear feedback when binary detected\n- [ ] Rich text handled gracefully (formatted → plain)\n- [ ] No crashes on any clipboard content type\n- [ ] Original clipboard preserved on rejection","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:06:00.330084-05:00","updated_at":"2025-12-13T10:13:33.328053-05:00","closed_at":"2025-12-13T10:13:33.328053-05:00","dependencies":[{"issue_id":"oc-74q.3","depends_on_id":"oc-74q","type":"parent-child","created_at":"2025-12-12T22:06:00.330638-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-74q.4","title":"Implement CGEvent Paste Simulation","description":"## Task: Implement CGEvent Paste Simulation\n\n### Background \u0026 Purpose\n\nAfter transforming clipboard content, Optimus Clip needs to paste it into the user's active application. macOS doesn't provide a public API for \"paste into any app\" - we must simulate the keyboard shortcut Cmd+V using low-level CGEvent APIs.\n\n**Why This Matters:**\n- The whole point of Optimus Clip is seamless transformation → paste\n- Without paste simulation, user would need to manually Cmd+V after every transformation\n- That defeats the \"one hotkey does everything\" UX promise\n\n### How CGEvent Paste Simulation Works\n\n**The Flow:**\n1. Create a CGEventSource (represents keyboard state)\n2. Create key-down event for 'V' with Command modifier\n3. Post the event to the system\n4. Create and post key-up event\n5. macOS routes these events to the frontmost app → paste happens\n\n**The Code:**\n```swift\nimport Carbon.HIToolbox\nimport CoreGraphics\n\nfunc simulatePaste() {\n    // 1. Create event source\n    guard let source = CGEventSource(stateID: .combinedSessionState) else {\n        print(\"Failed to create CGEventSource\")\n        return\n    }\n\n    // 2. Get the key code for 'V'\n    let keyCode = CGKeyCode(kVK_ANSI_V)  // 9 on US keyboard\n\n    // 3. Create key-down event\n    guard let keyDown = CGEvent(keyboardEventSource: source, virtualKey: keyCode, keyDown: true) else {\n        return\n    }\n    keyDown.flags = .maskCommand  // Add Cmd modifier\n\n    // 4. Create key-up event\n    guard let keyUp = CGEvent(keyboardEventSource: source, virtualKey: keyCode, keyDown: false) else {\n        return\n    }\n    keyUp.flags = .maskCommand\n\n    // 5. Post events to the HID event tap\n    keyDown.post(tap: .cghidEventTap)\n    keyUp.post(tap: .cghidEventTap)\n}\n```\n\n### Why Carbon.HIToolbox?\n\n`kVK_ANSI_V` comes from Carbon's HIToolbox - it's the virtual key code for the 'V' key on ANSI keyboards. While Carbon is deprecated, these key code constants are still the official way to reference keys.\n\n**Key Codes We Need:**\n- `kVK_ANSI_V` = 9 (for Cmd+V paste)\n- Could also use `kVK_ANSI_C` = 8 (for Cmd+C copy, if needed)\n\n**Why not hardcode 9?**\n- Using the constant is self-documenting\n- Protects against Apple changing values (unlikely but possible)\n- Other developers understand the code immediately\n\n### Accessibility Permission Requirement\n\n**CRITICAL:** CGEvent posting requires Accessibility permission. Without it, events are silently dropped - no error, just nothing happens.\n\n**Check Before Posting:**\n```swift\nimport ApplicationServices\n\nfunc canSimulatePaste() -\u003e Bool {\n    return AXIsProcessTrusted()\n}\n\nfunc simulatePasteIfAllowed() {\n    guard AXIsProcessTrusted() else {\n        // Show permission prompt or notification\n        NotificationManager.shared.showAccessibilityRequired()\n        return\n    }\n    simulatePaste()\n}\n```\n\n**Why .cghidEventTap?**\n- `CGEventTapLocation.cghidEventTap` = system-wide event tap\n- Events go to whatever app has focus\n- Alternative `.cgSessionEventTap` only works within current session\n- We need `.cghidEventTap` for cross-app paste\n\n### Timing Considerations\n\n**Event Delivery is Asynchronous:**\nThe paste doesn't happen instantly - there's a brief delay as the event routes through the system. This is usually fine, but be aware:\n\n```swift\nfunc transformAndPaste() async {\n    // 1. Transform clipboard content\n    let transformed = await transform(clipboardText)\n\n    // 2. Write to clipboard\n    ClipboardManager.shared.write(transformed)\n\n    // 3. Small delay to ensure clipboard is ready\n    // (Usually not needed, but can help with slow apps)\n    try? await Task.sleep(nanoseconds: 10_000_000)  // 10ms\n\n    // 4. Simulate paste\n    simulatePaste()\n}\n```\n\n### Edge Cases \u0026 Gotchas\n\n**1. Keyboard Layout Independence:**\n`kVK_ANSI_V` is a physical key position, not a character. Works regardless of keyboard layout (QWERTY, Dvorak, etc.).\n\n**2. Focus Stealing:**\nIf Optimus Clip's Settings window is open, paste goes there! Ensure transformation flow doesn't open any windows.\n\n**3. Secure Input Fields:**\nSome apps enable \"secure input mode\" (password fields, 1Password, etc.). CGEvents may be blocked in these contexts - this is by design for security.\n\n**4. Full-Screen Apps:**\nPaste simulation works in full-screen apps as long as accessibility permission is granted.\n\n**5. Remote Desktop:**\nEvents go to local system, not remote. Users on Remote Desktop may experience issues.\n\n**6. Key Repeat:**\nWe post both key-down and key-up. Don't forget key-up or you'll get key repeat behavior.\n\n### Implementation in Context\n\n```swift\nfinal class PasteSimulator {\n    static let shared = PasteSimulator()\n\n    func paste() {\n        // Pre-flight check\n        guard AXIsProcessTrusted() else {\n            // This should never happen if UI is guiding user correctly\n            assertionFailure(\"Paste simulation called without accessibility permission\")\n            return\n        }\n\n        guard let source = CGEventSource(stateID: .combinedSessionState) else {\n            return\n        }\n\n        let keyCode = CGKeyCode(kVK_ANSI_V)\n\n        guard let keyDown = CGEvent(keyboardEventSource: source, virtualKey: keyCode, keyDown: true),\n              let keyUp = CGEvent(keyboardEventSource: source, virtualKey: keyCode, keyDown: false) else {\n            return\n        }\n\n        keyDown.flags = .maskCommand\n        keyUp.flags = .maskCommand\n\n        keyDown.post(tap: .cghidEventTap)\n        keyUp.post(tap: .cghidEventTap)\n    }\n}\n```\n\n### Testing Checklist\n\n- [ ] Paste works in TextEdit\n- [ ] Paste works in Terminal\n- [ ] Paste works in VS Code\n- [ ] Paste works in Safari URL bar\n- [ ] Paste works in full-screen apps\n- [ ] Paste does nothing without accessibility permission (no crash)\n- [ ] Paste works with different keyboard layouts\n- [ ] No key repeat issues (verify key-up is posted)\n\n### Integration with Transformation Flow\n\n```\nUser presses hotkey (Cmd+Option+V)\n         │\n         ▼\n  Read clipboard content\n         │\n         ▼\n  Apply transformation\n         │\n         ▼\n  Write result to clipboard (with marker)\n         │\n         ▼\n  Simulate Cmd+V paste ← THIS TASK\n         │\n         ▼\n  Result appears in user's app\n```\n\n### Success Criteria\n- Paste simulation works in all major macOS apps\n- Zero crashes when accessibility permission is missing\n- No interference with normal keyboard usage\n- Works regardless of keyboard layout","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:37.168483-05:00","updated_at":"2025-12-13T10:41:01.660788-05:00","closed_at":"2025-12-13T10:41:01.660788-05:00","dependencies":[{"issue_id":"oc-74q.4","depends_on_id":"oc-74q","type":"parent-child","created_at":"2025-12-12T22:06:37.169062-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.4","depends_on_id":"oc-74q.5","type":"blocks","created_at":"2025-12-12T23:53:55.402214-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-74q.5","title":"Implement AccessibilityPermissionManager","description":"## Task: Implement AccessibilityPermissionManager\n\n### Background \u0026 Why Accessibility Permission is Required\n\nmacOS requires explicit user permission for apps to:\n1. **Monitor keyboard events globally** (for hotkeys)\n2. **Simulate keyboard input** (for paste simulation via CGEvent)\n\nWithout Accessibility permission, Optimus Clip cannot:\n- Detect global hotkey presses (KeyboardShortcuts package needs this)\n- Simulate Cmd+V to paste transformed content\n\n**This is a macOS security feature, not a limitation we can bypass.**\n\n### The User Experience Challenge\n\nAccessibility permission is often confusing for users:\n- They don't understand why a clipboard app needs \"accessibility\"\n- The system dialog is vague and scary-sounding\n- Many users deny permission then wonder why the app doesn't work\n\n**Our job is to educate and guide, not just request.**\n\n### Permission Flow\n\n```\nApp Launch\n    │\n    ▼\nCheck AXIsProcessTrusted()\n    │\n    ├─── TRUE ──→ Proceed normally\n    │\n    ▼ (FALSE)\nShow in-app explainer UI\n    │\n    ▼\nUser clicks \"Grant Permission\"\n    │\n    ▼\nCall AXIsProcessTrustedWithOptions (shows system dialog)\n    │\n    ▼\nStart polling for permission grant\n    │\n    ├─── Permission granted ──→ Dismiss UI, proceed\n    │\n    └─── Still denied ──→ Show \"Open System Settings\" button\n```\n\n### Implementation\n\n```swift\nimport ApplicationServices\nimport Combine\n\n@MainActor\nfinal class AccessibilityPermissionManager: ObservableObject {\n    static let shared = AccessibilityPermissionManager()\n\n    @Published var isGranted: Bool = false\n    @Published var hasBeenRequested: Bool = false\n\n    private var pollTimer: Timer?\n\n    init() {\n        checkPermission()\n        startPolling()\n    }\n\n    /// Check current permission state\n    func checkPermission() {\n        isGranted = AXIsProcessTrusted()\n    }\n\n    /// Request permission (shows system dialog)\n    func requestPermission() {\n        hasBeenRequested = true\n\n        // This triggers the system permission dialog\n        let options = [kAXTrustedCheckOptionPrompt.takeUnretainedValue(): true] as CFDictionary\n        AXIsProcessTrustedWithOptions(options)\n\n        // Check immediately after request\n        checkPermission()\n    }\n\n    /// Open System Settings to Accessibility pane\n    func openSystemSettings() {\n        let url = URL(string: \"x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility\")!\n        NSWorkspace.shared.open(url)\n    }\n\n    /// Start polling for permission changes (user may grant in Settings)\n    private func startPolling() {\n        pollTimer = Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { [weak self] _ in\n            Task { @MainActor in\n                self?.checkPermission()\n            }\n        }\n    }\n\n    deinit {\n        pollTimer?.invalidate()\n    }\n}\n```\n\n### Settings UI Component\n\n```swift\nstruct AccessibilityPermissionCallout: View {\n    @ObservedObject var permissionManager = AccessibilityPermissionManager.shared\n\n    var body: some View {\n        if !permissionManager.isGranted {\n            VStack(alignment: .leading, spacing: 12) {\n                // Warning header\n                HStack {\n                    Image(systemName: \"exclamationmark.triangle.fill\")\n                        .foregroundColor(.yellow)\n                        .font(.title2)\n                    Text(\"Accessibility Permission Required\")\n                        .font(.headline)\n                }\n\n                // Explanation\n                Text(\"Optimus Clip needs Accessibility permission to:\")\n                    .foregroundColor(.secondary)\n\n                VStack(alignment: .leading, spacing: 4) {\n                    Label(\"Detect global keyboard shortcuts\", systemImage: \"keyboard\")\n                    Label(\"Paste transformed text automatically\", systemImage: \"doc.on.clipboard\")\n                }\n                .font(.subheadline)\n                .foregroundColor(.secondary)\n\n                // Action buttons\n                HStack {\n                    Button(action: {\n                        permissionManager.requestPermission()\n                    }) {\n                        Label(\"Grant Permission\", systemImage: \"lock.open\")\n                    }\n                    .buttonStyle(.borderedProminent)\n\n                    Button(action: {\n                        permissionManager.openSystemSettings()\n                    }) {\n                        Label(\"Open Settings\", systemImage: \"gear\")\n                    }\n                    .buttonStyle(.bordered)\n                }\n\n                // Help text\n                if permissionManager.hasBeenRequested {\n                    Text(\"If the dialog didn't appear, click 'Open Settings' and add Optimus Clip to the Accessibility list.\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n            }\n            .padding()\n            .background(Color.yellow.opacity(0.1))\n            .cornerRadius(8)\n        }\n    }\n}\n```\n\n### Graceful Degradation\n\nEven without permission, the app should:\n1. **Launch successfully** (don't crash)\n2. **Show clear guidance** (not cryptic errors)\n3. **Allow Settings configuration** (API keys, transformations)\n4. **Explain what won't work** (hotkeys, auto-paste)\n\n```swift\nfunc handleHotkeyPress() {\n    guard AccessibilityPermissionManager.shared.isGranted else {\n        // Don't silently fail - show notification\n        showPermissionRequiredNotification()\n        return\n    }\n\n    // Proceed with transformation\n}\n```\n\n### URL Scheme Details\n\n**Open Accessibility Settings:**\n```swift\nlet url = URL(string: \"x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility\")!\n```\n\nThis URL:\n- Opens System Settings (née System Preferences)\n- Navigates directly to Security \u0026 Privacy → Privacy → Accessibility\n- Works on macOS 13+ (Ventura and later)\n\n### Polling Strategy\n\n**Why Poll?**\n- No system notification when permission changes\n- User may grant permission in System Settings while app is running\n- Need to detect and respond to permission grant\n\n**Polling Interval: 2 seconds**\n- Fast enough to feel responsive\n- Slow enough to not waste CPU\n- Standard practice for permission polling\n\n### Edge Cases \u0026 Gotchas\n\n**1. First Launch Experience:**\n- Don't immediately request permission on first launch\n- Show onboarding/explainer first\n- Let user choose when to grant\n\n**2. Permission Revoked:**\n- User can revoke permission at any time\n- App must handle this gracefully\n- Re-check permission before critical operations\n\n**3. Multiple Clicks:**\n- User may click \"Grant Permission\" multiple times\n- `AXIsProcessTrustedWithOptions` is idempotent (safe to call repeatedly)\n\n**4. App Restart After Grant:**\n- Some users expect to restart after granting\n- Actually not required - polling detects grant\n- But don't discourage restart if user wants to\n\n**5. Terminal vs App Permission:**\n- If running via `swift run` (terminal), terminal gets permission request\n- Packaged .app gets its own permission\n- This can confuse during development\n\n### Testing Checklist\n\n- [ ] Permission status correctly detected on launch\n- [ ] System dialog appears when \"Grant Permission\" clicked\n- [ ] \"Open Settings\" opens correct settings pane\n- [ ] Polling detects permission grant without restart\n- [ ] App works correctly after permission granted\n- [ ] Clear error/guidance when permission denied\n- [ ] No crashes when permission revoked while running\n\n### Success Criteria\n- [ ] Clear, non-scary permission explanation\n- [ ] Easy path to grant permission\n- [ ] Polling detects permission changes\n- [ ] App degrades gracefully without permission\n- [ ] Settings UI shows current permission status","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:07:18.468899-05:00","updated_at":"2025-12-13T10:34:40.400922-05:00","closed_at":"2025-12-13T10:34:40.400922-05:00","dependencies":[{"issue_id":"oc-74q.5","depends_on_id":"oc-74q","type":"parent-child","created_at":"2025-12-12T22:07:18.469721-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.5","depends_on_id":"oc-uzt","type":"blocks","created_at":"2025-12-12T23:53:55.71425-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-74q.6","title":"Implement Clipboard Write Operations","description":"BACKGROUND \u0026 CONTEXT:\nAfter transforming clipboard content, Optimus Clip must write the transformed text back to the system clipboard. This write operation MUST include the self-write marker to prevent infinite reprocessing loops. The write must be atomic, safe, and handle failures gracefully.\n\nWHY THIS IS NEEDED:\n- Completes the transformation pipeline: read → transform → write\n- Places transformed content where user expects it (clipboard)\n- Enables paste simulation (paste reads from clipboard)\n- Self-write marker prevents ClipboardMonitor from reprocessing\n\nTHE CHALLENGE:\n- Write must be atomic (all-or-nothing)\n- Must include self-write marker without fail\n- Must handle concurrent clipboard access\n- Must preserve clipboard if write fails\n- Must not corrupt clipboard with partial writes\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. BASIC CLIPBOARD WRITE:\n   ```swift\n   func writeToClipboard(_ text: String) -\u003e Bool {\n       let pasteboard = NSPasteboard.general\n       \n       // Clear clipboard and declare types\n       // This is atomic - either succeeds completely or fails\n       pasteboard.clearContents()\n       \n       // Write text\n       return pasteboard.setString(text, forType: .string)\n   }\n   ```\n   - clearContents() removes all existing types\n   - setString() writes text with .string type\n   - Returns Bool indicating success\n\n2. WRITE WITH SELF-WRITE MARKER (CRITICAL):\n   ```swift\n   func writeToClipboardWithMarker(_ text: String) -\u003e Bool {\n       let pasteboard = NSPasteboard.general\n       let markerType = NSPasteboard.PasteboardType(\"com.optimusclip.marker\")\n       \n       // Declare both types atomically\n       // This clears clipboard and sets up for both types\n       pasteboard.declareTypes([.string, markerType], owner: nil)\n       \n       // Write text\n       guard pasteboard.setString(text, forType: .string) else {\n           print(\"Failed to write text to clipboard\")\n           return false\n       }\n       \n       // Write marker (empty data)\n       guard pasteboard.setData(Data(), forType: markerType) else {\n           print(\"Failed to write marker to clipboard\")\n           // Text is already written but no marker - this is BAD\n           // Consider clearing clipboard here\n           return false\n       }\n       \n       return true\n   }\n   ```\n   - declareTypes() is critical - announces both types upfront\n   - setString() and setData() called in sequence\n   - If either fails, write is incomplete\n\n3. IMPROVED ERROR HANDLING:\n   ```swift\n   func writeToClipboardWithMarker(_ text: String) -\u003e Result\u003cVoid, ClipboardError\u003e {\n       let pasteboard = NSPasteboard.general\n       let markerType = NSPasteboard.PasteboardType(\"com.optimusclip.marker\")\n       \n       // Store previous contents for rollback\n       let previousChangeCount = pasteboard.changeCount\n       let previousContents = pasteboard.string(forType: .string)\n       \n       // Declare types\n       pasteboard.declareTypes([.string, markerType], owner: nil)\n       \n       // Write text\n       guard pasteboard.setString(text, forType: .string) else {\n           // Rollback by restoring previous contents\n           if let previous = previousContents {\n               pasteboard.clearContents()\n               pasteboard.setString(previous, forType: .string)\n           }\n           return .failure(.textWriteFailed)\n       }\n       \n       // Write marker\n       guard pasteboard.setData(Data(), forType: markerType) else {\n           // Marker write failed - text is already written\n           // This is problematic but not catastrophic\n           // ClipboardMonitor might reprocess, but that's better than losing user's transformation\n           return .failure(.markerWriteFailed)\n       }\n       \n       return .success(())\n   }\n   \n   enum ClipboardError: Error {\n       case textWriteFailed\n       case markerWriteFailed\n       case clipboardUnavailable\n   }\n   ```\n\n4. THREAD SAFETY:\n   NSPasteboard is NOT thread-safe. All operations must be on main thread:\n   ```swift\n   func writeToClipboardSafe(_ text: String, completion: @escaping (Bool) -\u003e Void) {\n       DispatchQueue.main.async {\n           let success = writeToClipboardWithMarker(text)\n           completion(success)\n       }\n   }\n   ```\n\n5. COMPLETE CLIPBOARD WRITER CLASS:\n   ```swift\n   class ClipboardWriter {\n       static let shared = ClipboardWriter()\n       private let markerType = NSPasteboard.PasteboardType(\"com.optimusclip.marker\")\n       \n       func write(_ text: String, completion: @escaping (Result\u003cVoid, ClipboardError\u003e) -\u003e Void) {\n           DispatchQueue.main.async { [weak self] in\n               guard let self = self else {\n                   completion(.failure(.clipboardUnavailable))\n                   return\n               }\n               \n               let result = self.writeWithMarker(text)\n               completion(result)\n           }\n       }\n       \n       private func writeWithMarker(_ text: String) -\u003e Result\u003cVoid, ClipboardError\u003e {\n           let pasteboard = NSPasteboard.general\n           \n           // Declare types atomically\n           pasteboard.declareTypes([.string, markerType], owner: nil)\n           \n           // Write text\n           guard pasteboard.setString(text, forType: .string) else {\n               return .failure(.textWriteFailed)\n           }\n           \n           // Write marker\n           guard pasteboard.setData(Data(), forType: markerType) else {\n               return .failure(.markerWriteFailed)\n           }\n           \n           return .success(())\n       }\n   }\n   ```\n\nDETAILED FLOW:\n\nSUCCESSFUL WRITE:\n1. TransformationFlowCoordinator calls ClipboardWriter.write()\n2. Ensures on main thread\n3. Calls declareTypes([.string, marker]) → clears clipboard\n4. Writes text with setString() → success\n5. Writes marker with setData() → success\n6. Returns .success(())\n7. Clipboard now contains transformed text + marker\n8. Ready for paste simulation\n\nFAILED WRITE (text write fails):\n1. declareTypes() clears clipboard\n2. setString() fails → clipboard is empty\n3. Return .failure(.textWriteFailed)\n4. TransformationFlowCoordinator handles error\n5. User notified: \"Failed to write to clipboard\"\n6. Original clipboard content is lost (can't be avoided if setString fails)\n\nFAILED WRITE (marker write fails):\n1. declareTypes() clears clipboard\n2. setString() succeeds → text is on clipboard\n3. setData() fails → marker missing\n4. Return .failure(.markerWriteFailed)\n5. Problem: text is written but no marker\n6. ClipboardMonitor might reprocess this content\n7. Decision: Accept this as edge case (rare) or clear clipboard entirely\n\nEDGE CASES TO HANDLE:\n\n1. EMPTY TEXT:\n   - Should we write empty string to clipboard?\n   - Decision: Yes, write it (user might want empty clipboard)\n   - Alternative: Don't write, keep original content\n\n2. EXTREMELY LONG TEXT:\n   - NSPasteboard has no documented size limit\n   - Practically limited by memory\n   - Consider warning if text \u003e 10MB (unusual)\n\n3. CONCURRENT WRITES:\n   - Another app writes to clipboard while we're writing\n   - Our declareTypes() clears their write\n   - This is normal clipboard behavior (last write wins)\n   - No special handling needed\n\n4. MARKER WRITE FAILS:\n   - Text is written but marker is missing\n   - ClipboardMonitor will detect change and might reprocess\n   - Options:\n     a) Clear clipboard entirely (lose transformation)\n     b) Keep text (risk reprocessing)\n     c) Temporarily disable ClipboardMonitor\n   - RECOMMENDED: Option C - pause ClipboardMonitor during write\n\n5. CLIPBOARD LOCKED BY OTHER APP:\n   - Rare, but some apps lock clipboard temporarily\n   - setString() returns false\n   - Retry once after 100ms delay\n   - If still fails, error out\n\nPREVENTING REPROCESSING LOOP:\n\nThe marker write failure scenario is dangerous. Solution:\n```swift\nclass ClipboardWriter {\n    var isWriting = false  // Flag to prevent monitoring during write\n    \n    func write(_ text: String, completion: @escaping (Result\u003cVoid, ClipboardError\u003e) -\u003e Void) {\n        DispatchQueue.main.async { [weak self] in\n            guard let self = self else { return }\n            \n            // Set flag BEFORE writing\n            self.isWriting = true\n            \n            let result = self.writeWithMarker(text)\n            \n            // Clear flag after short delay (let clipboard settle)\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {\n                self.isWriting = false\n            }\n            \n            completion(result)\n        }\n    }\n}\n\n// In ClipboardMonitor:\nfunc checkClipboard() {\n    // Skip if write is in progress\n    if ClipboardWriter.shared.isWriting { return }\n    // ... rest of monitoring logic\n}\n```\n\nRICH TEXT CONSIDERATIONS:\n\nFuture enhancement: Support writing rich text (RTF, HTML):\n```swift\nfunc writeRichText(_ attributedString: NSAttributedString) -\u003e Bool {\n    let pasteboard = NSPasteboard.general\n    pasteboard.clearContents()\n    return pasteboard.writeObjects([attributedString])\n}\n```\n- Not needed for Phase 2 (plain text only)\n- Phase 3+ might support rich text transformations\n\nSECURITY CONSIDERATIONS:\n- No sensitive data in marker (just empty Data())\n- Text written to clipboard is accessible to all apps (normal behavior)\n- No encryption (clipboard is inherently insecure)\n- Self-write marker is app-specific, won't leak info\n\nTESTING REQUIREMENTS:\n- Write text → verify clipboard contains text + marker\n- Write empty string → verify clipboard is empty + marker\n- Write very long text (10MB+) → verify success\n- Simulate write failure → verify error handling\n- Concurrent writes from other apps → verify no crashes\n- Rapid successive writes → verify all succeed\n\nPERFORMANCE CONSIDERATIONS:\n- declareTypes() + setString() + setData() is fast (~1ms)\n- Main thread required but not blocking (async)\n- No retained memory (clipboard owns the data)\n\nARCHITECTURE CONNECTIONS:\n- Called by TransformationFlowCoordinator after transformation\n- Must include self-write marker (coordinate with Self-Write Marker System task)\n- Triggers ClipboardMonitor detection (must handle gracefully)\n- Precedes paste simulation\n\nIMPORTANT VALUES:\n- Marker type: \"com.optimusclip.marker\"\n- Write settling delay: 200ms (pause monitoring)\n- Retry delay on failure: 100ms\n\nCODE LOCATION:\nCreate ClipboardWriter class in Services/ or Utilities/ directory.\n\nPRIORITY: P2 (required for Phase 2 completion)\nThis is in the critical path of the transformation flow.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:07:59.692074-05:00","updated_at":"2025-12-13T10:21:11.992386-05:00","closed_at":"2025-12-13T10:21:11.992386-05:00","dependencies":[{"issue_id":"oc-74q.6","depends_on_id":"oc-74q","type":"parent-child","created_at":"2025-12-12T22:07:59.692701-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.6","depends_on_id":"oc-74q.2","type":"blocks","created_at":"2025-12-12T23:53:56.339919-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-74q.7","title":"Implement Transformation Flow Coordinator","description":"BACKGROUND \u0026 CONTEXT:\nThe TransformationFlowCoordinator is the central orchestrator that ties together all Phase 2 components. When a hotkey is pressed, it coordinates the entire flow: read clipboard → check safety → transform content → write clipboard → simulate paste. It handles errors at every stage and ensures the system remains in a consistent state.\n\nWHY THIS IS CRITICAL:\n- Single point of control for the entire transformation pipeline\n- Handles complex error scenarios and edge cases\n- Ensures atomic operations (complete success or clean rollback)\n- Manages timeouts (prevents hanging on slow transformations)\n- Provides user feedback at each stage\n- Prevents race conditions between components\n\nTHE CHALLENGE:\nThe transformation flow has many potential failure points:\n1. Clipboard might be empty or binary\n2. Transformation might fail or timeout\n3. Clipboard write might fail\n4. Accessibility permission might be missing\n5. Paste simulation might fail\n\nEach failure requires different handling and user feedback.\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. HIGH-LEVEL FLOW:\n   ```\n   User presses hotkey\n   ↓\n   Coordinator triggered\n   ↓\n   1. Check accessibility permission (required for paste)\n   2. Read clipboard content (with safety checks)\n   3. Check if content is safe to process (not binary, no self-marker)\n   4. Transform content (via TransformationEngine)\n   5. Write transformed content (with self-write marker)\n   6. Simulate paste (Cmd+V)\n   ↓\n   Success or Error feedback\n   ```\n\n2. COORDINATOR CLASS STRUCTURE:\n   ```swift\n   class TransformationFlowCoordinator {\n       static let shared = TransformationFlowCoordinator()\n       \n       private let clipboardMonitor = ClipboardMonitor.shared\n       private let clipboardWriter = ClipboardWriter.shared\n       private let permissionManager = AccessibilityPermissionManager.shared\n       private let transformationEngine = TransformationEngine.shared\n       \n       private var isProcessing = false  // Prevent concurrent transformations\n       \n       func handleHotkeyTrigger() {\n           // Main entry point when hotkey pressed\n       }\n   }\n   ```\n\n3. COMPLETE FLOW IMPLEMENTATION:\n   ```swift\n   func handleHotkeyTrigger() {\n       // Prevent concurrent transformations\n       guard !isProcessing else {\n           print(\"Transformation already in progress\")\n           return\n       }\n       \n       isProcessing = true\n       \n       // Step 1: Check accessibility permission\n       guard permissionManager.checkPermission() else {\n           showPermissionRequiredAlert()\n           isProcessing = false\n           return\n       }\n       \n       // Step 2: Read clipboard with safety checks\n       guard let clipboardContent = readClipboardSafely() else {\n           // Either empty, binary, or self-write marker present\n           isProcessing = false\n           return\n       }\n       \n       // Step 3: Transform content\n       transformContent(clipboardContent) { [weak self] result in\n           guard let self = self else { return }\n           \n           switch result {\n           case .success(let transformedText):\n               // Step 4: Write to clipboard\n               self.writeAndPaste(transformedText)\n               \n           case .failure(let error):\n               self.handleTransformationError(error)\n               self.isProcessing = false\n           }\n       }\n   }\n   ```\n\n4. CLIPBOARD READING WITH SAFETY:\n   ```swift\n   func readClipboardSafely() -\u003e String? {\n       let pasteboard = NSPasteboard.general\n       \n       // Check 1: Self-write marker (prevent reprocessing)\n       let markerType = NSPasteboard.PasteboardType(\"com.optimusclip.marker\")\n       if pasteboard.types?.contains(markerType) == true {\n           print(\"Self-write marker detected, skipping\")\n           return nil\n       }\n       \n       // Check 2: Binary content (images, files, etc.)\n       if isBinaryContent(pasteboard) {\n           print(\"Binary content detected, skipping\")\n           showBinaryContentNotification()\n           return nil\n       }\n       \n       // Check 3: Text content exists\n       guard let text = pasteboard.string(forType: .string), !text.isEmpty else {\n           print(\"No text content on clipboard\")\n           return nil\n       }\n       \n       return text\n   }\n   \n   func isBinaryContent(_ pasteboard: NSPasteboard) -\u003e Bool {\n       guard let types = pasteboard.types else { return false }\n       \n       let binaryTypes: Set\u003cNSPasteboard.PasteboardType\u003e = [\n           .png, .tiff, .pdf, .fileURL\n       ]\n       \n       return !types.intersection(binaryTypes).isEmpty\n   }\n   ```\n\n5. TRANSFORMATION WITH TIMEOUT:\n   ```swift\n   func transformContent(_ text: String, completion: @escaping (Result\u003cString, TransformationError\u003e) -\u003e Void) {\n       let timeoutDuration: TimeInterval = 30.0  // 30 seconds for LLM calls\n       var hasCompleted = false\n       \n       // Set timeout\n       DispatchQueue.main.asyncAfter(deadline: .now() + timeoutDuration) {\n           if !hasCompleted {\n               hasCompleted = true\n               completion(.failure(.timeout))\n           }\n       }\n       \n       // Perform transformation\n       transformationEngine.transform(text) { result in\n           if !hasCompleted {\n               hasCompleted = true\n               completion(result)\n           }\n       }\n   }\n   \n   enum TransformationError: Error {\n       case timeout\n       case networkError\n       case apiError(String)\n       case emptyResult\n   }\n   ```\n\n6. WRITE AND PASTE:\n   ```swift\n   func writeAndPaste(_ text: String) {\n       // Write to clipboard with marker\n       clipboardWriter.write(text) { [weak self] result in\n           guard let self = self else { return }\n           \n           switch result {\n           case .success:\n               // Wait brief moment for clipboard to settle\n               DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n                   self.simulatePaste()\n                   self.isProcessing = false\n               }\n               \n           case .failure(let error):\n               self.handleClipboardWriteError(error)\n               self.isProcessing = false\n           }\n       }\n   }\n   \n   func simulatePaste() {\n       // Create CGEvent for Cmd+V\n       guard let source = CGEventSource(stateID: .combinedSessionState),\n             let keyDown = CGEvent(keyboardEventSource: source, virtualKey: CGKeyCode(kVK_ANSI_V), keyDown: true),\n             let keyUp = CGEvent(keyboardEventSource: source, virtualKey: CGKeyCode(kVK_ANSI_V), keyDown: false) else {\n           print(\"Failed to create paste events\")\n           return\n       }\n       \n       keyDown.flags = .maskCommand\n       keyUp.flags = .maskCommand\n       \n       keyDown.post(tap: .cghidEventTap)\n       keyUp.post(tap: .cghidEventTap)\n   }\n   ```\n\n7. ERROR HANDLING:\n   ```swift\n   func handleTransformationError(_ error: TransformationError) {\n       switch error {\n       case .timeout:\n           showAlert(title: \"Transformation Timeout\", message: \"The transformation took too long. Please try again.\")\n           \n       case .networkError:\n           showAlert(title: \"Network Error\", message: \"Could not connect to transformation service. Check your internet connection.\")\n           \n       case .apiError(let details):\n           showAlert(title: \"Transformation Error\", message: details)\n           \n       case .emptyResult:\n           showAlert(title: \"Empty Result\", message: \"The transformation returned no content.\")\n       }\n   }\n   \n   func handleClipboardWriteError(_ error: ClipboardError) {\n       showAlert(title: \"Clipboard Error\", message: \"Failed to write to clipboard. Original content preserved.\")\n   }\n   \n   func showPermissionRequiredAlert() {\n       let alert = NSAlert()\n       alert.messageText = \"Accessibility Permission Required\"\n       alert.informativeText = \"Optimus Clip needs accessibility permission to simulate paste. Grant permission in System Preferences.\"\n       alert.addButton(withTitle: \"Open Settings\")\n       alert.addButton(withTitle: \"Cancel\")\n       \n       if alert.runModal() == .alertFirstButtonReturn {\n           permissionManager.openSystemPreferences()\n       }\n   }\n   ```\n\nDETAILED FLOW SCENARIOS:\n\nSCENARIO 1 - SUCCESSFUL TRANSFORMATION:\n1. User copies \"hello world\"\n2. User presses hotkey (e.g., Cmd+Shift+T)\n3. Coordinator: isProcessing = true\n4. Check accessibility permission ✓\n5. Read clipboard: \"hello world\"\n6. Check safety: not binary, no marker ✓\n7. Transform: \"HELLO WORLD\" (example transformation)\n8. Write to clipboard with marker ✓\n9. Simulate paste ✓\n10. Coordinator: isProcessing = false\n11. \"HELLO WORLD\" pasted into active application ✓\n\nSCENARIO 2 - BINARY CONTENT (image copied):\n1. User copies image in browser\n2. User presses hotkey\n3. Coordinator: isProcessing = true\n4. Read clipboard: detects .png type\n5. isBinaryContent() = true\n6. Show notification: \"Cannot transform images\"\n7. Coordinator: isProcessing = false\n8. Clipboard unchanged, no paste ✓\n\nSCENARIO 3 - NO ACCESSIBILITY PERMISSION:\n1. User copies \"hello\"\n2. User presses hotkey\n3. Coordinator: isProcessing = true\n4. Check accessibility permission ✗\n5. Show alert: \"Permission required\"\n6. User clicks \"Open Settings\"\n7. System Preferences opens\n8. Coordinator: isProcessing = false\n9. User grants permission\n10. User presses hotkey again\n11. Transformation succeeds ✓\n\nSCENARIO 4 - TRANSFORMATION TIMEOUT:\n1. User copies long text\n2. User presses hotkey\n3. Coordinator: isProcessing = true\n4. Checks pass ✓\n5. Transform starts (calls LLM API)\n6. 30 seconds pass, no response\n7. Timeout fires: completion(.failure(.timeout))\n8. Show alert: \"Transformation timeout\"\n9. Coordinator: isProcessing = false\n10. Clipboard unchanged ✓\n\nSCENARIO 5 - RAPID DOUBLE HOTKEY PRESS:\n1. User presses hotkey\n2. Coordinator: isProcessing = true\n3. Transformation in progress...\n4. User presses hotkey again (impatient)\n5. Coordinator: guard !isProcessing → return early\n6. First transformation completes\n7. Coordinator: isProcessing = false\n8. User can press hotkey again now ✓\n\nSCENARIO 6 - SELF-WRITE MARKER DETECTED:\n1. Previous transformation completed\n2. Clipboard has marker\n3. ClipboardMonitor detects change\n4. User accidentally presses hotkey again\n5. Coordinator: isProcessing = true\n6. Read clipboard: marker detected\n7. readClipboardSafely() returns nil\n8. Coordinator: isProcessing = false\n9. No transformation, no error (silent skip) ✓\n\nCONCURRENCY CONSIDERATIONS:\n\n1. isProcessing flag prevents concurrent transformations\n2. All clipboard operations on main thread (NSPasteboard requirement)\n3. Transformation engine may use background threads (for API calls)\n4. Callbacks always dispatched to main thread for UI updates\n\nPERFORMANCE CONSIDERATIONS:\n\n1. Fast path for safety checks (\u003c 1ms)\n2. Transformation is slowest part (100ms - 30s depending on method)\n3. Clipboard write is fast (\u003c 5ms)\n4. Paste simulation is immediate (\u003c 1ms)\n5. Total latency: ~100ms for simple transformations, up to 30s for LLM\n\nUSER FEEDBACK:\n\nConsider adding:\n1. Menu bar icon animation during processing\n2. Progress indicator for long transformations\n3. Sound feedback on success/failure\n4. Visual flash on paste\n5. Status message in menu\n\nARCHITECTURE CONNECTIONS:\n- Entry point: Called by HotkeyManager when hotkey pressed\n- Uses: ClipboardMonitor, ClipboardWriter, AccessibilityPermissionManager\n- Uses: TransformationEngine (Phase 3 will implement AI transformations)\n- Provides: Error handling, user feedback, flow control\n\nIMPORTANT VALUES:\n- Transformation timeout: 30 seconds (configurable)\n- Clipboard settling delay: 100ms\n- isProcessing flag: prevents concurrent transformations\n\nERROR RECOVERY:\n- If transformation fails: clipboard unchanged, user notified\n- If write fails: clipboard may be cleared (NSPasteboard limitation)\n- If paste fails: clipboard has transformed content (user can manually paste)\n\nTESTING REQUIREMENTS:\n- End-to-end flow: copy → hotkey → paste works\n- Binary content skipped gracefully\n- Self-write marker prevents reprocessing\n- Permission denial handled gracefully\n- Timeout works correctly\n- Concurrent hotkey presses handled\n- Error scenarios show appropriate alerts\n\nCODE LOCATION:\nCreate TransformationFlowCoordinator.swift in Services/ or Coordinators/ directory.\n\nPRIORITY: P2 (orchestrates all Phase 2 components)\nThis is the glue that makes Phase 2 functional.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:08:46.187381-05:00","updated_at":"2025-12-13T10:50:04.835513-05:00","closed_at":"2025-12-13T10:50:04.835513-05:00","dependencies":[{"issue_id":"oc-74q.7","depends_on_id":"oc-74q","type":"parent-child","created_at":"2025-12-12T22:08:46.188006-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.7","depends_on_id":"oc-74q.1","type":"blocks","created_at":"2025-12-12T23:53:56.568884-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.7","depends_on_id":"oc-74q.3","type":"blocks","created_at":"2025-12-12T23:53:56.738601-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.7","depends_on_id":"oc-74q.4","type":"blocks","created_at":"2025-12-12T23:53:56.990144-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.7","depends_on_id":"oc-74q.6","type":"blocks","created_at":"2025-12-12T23:53:57.186154-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-74q.8","title":"Phase 2 Verification \u0026 Testing","description":"BACKGROUND \u0026 CONTEXT:\nThis task verifies that ALL Phase 2 components work correctly both individually and as an integrated system. It ensures the core clipboard manipulation functionality is solid before building Phase 3 (AI transformations) and Phase 4 (rule system) on top of this foundation.\n\nWHY THIS IS CRITICAL:\n- Catches integration issues between components\n- Validates error handling and edge cases\n- Ensures system is ready for production use\n- Prevents bugs from propagating to future phases\n- Provides confidence in the core architecture\n\nTHE SCOPE:\nThis verification covers:\n1. ClipboardMonitor - polling, change detection, grace delay\n2. Self-Write Marker System - prevents reprocessing loops\n3. Binary Safety - detects and skips non-text content\n4. Accessibility Permission - grants and checks permission\n5. Clipboard Write - writes with marker atomically\n6. Paste Simulation - CGEvent Cmd+V works\n7. Flow Coordinator - orchestrates entire pipeline\n8. Error Handling - graceful failures at every stage\n\nTESTING METHODOLOGY:\n\nUse both:\n- Unit tests (XCTest for individual components)\n- Manual testing (real-world usage scenarios)\n- Integration tests (full end-to-end flows)\n\nDETAILED TEST CASES:\n\n═══════════════════════════════════════════════════════════\n1. CLIPBOARD MONITORING\n═══════════════════════════════════════════════════════════\n\nTEST 1.1: Change Detection\n- Start ClipboardMonitor\n- Copy text in another app\n- Verify: changeCount increases\n- Verify: Monitor detects change\n- Expected: Change detected within 150ms\n\nTEST 1.2: Grace Delay\n- Copy text that uses promised data (e.g., from Safari)\n- Verify: 80ms delay before reading\n- Verify: Content is fully available after delay\n- Expected: No empty/partial reads\n\nTEST 1.3: Text Reading Fallbacks\n- Copy from apps with different UTI types:\n  - TextEdit (.string)\n  - Terminal (public.utf8-plain-text)\n  - Web browser (public.utf16-external-plain-text)\n- Verify: All read successfully\n- Expected: Fallback chain works\n\nTEST 1.4: Polling Efficiency\n- Monitor running for 1 minute\n- Measure CPU usage\n- Expected: \u003c 1% CPU usage average\n\n═══════════════════════════════════════════════════════════\n2. SELF-WRITE MARKER SYSTEM\n═══════════════════════════════════════════════════════════\n\nTEST 2.1: Marker Prevents Reprocessing\n- Copy \"hello\"\n- Transform and write with marker\n- Verify: Clipboard has marker type\n- Try to read with marker check\n- Expected: Returns nil (skipped)\n\nTEST 2.2: Marker Clears on New Copy\n- Clipboard has marker from previous write\n- Copy new text \"world\"\n- Verify: Marker no longer present\n- Expected: New text can be processed\n\nTEST 2.3: Marker Doesn't Affect Other Apps\n- Write clipboard with marker\n- Paste into TextEdit, Notes, Terminal\n- Verify: Pastes correctly (marker ignored by other apps)\n- Expected: Normal paste behavior\n\nTEST 2.4: Rapid Transformations\n- Copy \"a\"\n- Transform (writes with marker)\n- Copy \"b\" immediately\n- Transform again\n- Verify: No reprocessing of \"a\"\n- Expected: Each transformation happens once\n\nTEST 2.5: No Infinite Loop\n- Remove marker check (temporarily)\n- Trigger transformation\n- Expected: Would loop infinitely (proves marker necessity)\n- Re-enable marker check\n- Expected: No loop\n\n═══════════════════════════════════════════════════════════\n3. BINARY SAFETY\n═══════════════════════════════════════════════════════════\n\nTEST 3.1: Image Detection\n- Copy image from browser\n- Press hotkey\n- Verify: isBinaryContent() returns true\n- Verify: Transformation skipped\n- Expected: Clipboard unchanged, no crash\n\nTEST 3.2: File Detection\n- Copy file in Finder\n- Press hotkey\n- Verify: fileURL type detected\n- Expected: Transformation skipped\n\nTEST 3.3: PDF Detection\n- Copy PDF content\n- Press hotkey\n- Verify: .pdf type detected\n- Expected: Transformation skipped\n\nTEST 3.4: Text Processing\n- Copy plain text \"hello\"\n- Press hotkey\n- Verify: isTextContent() returns true\n- Verify: Transformation proceeds\n- Expected: Text transformed and pasted\n\nTEST 3.5: Mixed Content\n- Copy content with both text and image (e.g., from Word)\n- Verify: Binary detection takes precedence\n- Expected: Skipped (or text extracted, depending on implementation)\n\nTEST 3.6: Empty Clipboard\n- Clear clipboard (no content)\n- Press hotkey\n- Expected: Graceful skip (no crash)\n\n═══════════════════════════════════════════════════════════\n4. ACCESSIBILITY PERMISSION\n═══════════════════════════════════════════════════════════\n\nTEST 4.1: Permission Check\n- Call AXIsProcessTrusted()\n- Expected: Returns true if granted, false if not\n\nTEST 4.2: Permission Request\n- Reset permission: sudo tccutil reset Accessibility com.optimusclip.app\n- Call requestPermission()\n- Verify: System dialog appears\n- Expected: Prompt shows app name and explanation\n\nTEST 4.3: Open System Preferences\n- Call openSystemPreferences()\n- Verify: System Preferences opens to Accessibility pane\n- Expected: Optimus Clip listed in apps\n\nTEST 4.4: Polling Detection\n- Request permission\n- Grant in System Preferences\n- Verify: Polling detects grant within 2 seconds\n- Expected: Callback fires with true\n\nTEST 4.5: Paste Without Permission\n- Deny accessibility permission\n- Try to simulate paste\n- Expected: Events silently ignored (no crash)\n\n═══════════════════════════════════════════════════════════\n5. CLIPBOARD WRITE OPERATIONS\n═══════════════════════════════════════════════════════════\n\nTEST 5.1: Basic Write\n- Write \"transformed\" to clipboard\n- Read clipboard\n- Verify: Contains \"transformed\"\n- Expected: Write succeeds\n\nTEST 5.2: Write With Marker\n- Write \"text\" with marker\n- Verify: Clipboard types include marker\n- Verify: Text readable\n- Expected: Both types present\n\nTEST 5.3: Atomic Write\n- Write long text (10MB)\n- Verify: All content present (no truncation)\n- Expected: Complete write or complete failure\n\nTEST 5.4: Write Failure Handling\n- Simulate write failure (mock NSPasteboard)\n- Verify: Returns error\n- Expected: Error propagated to coordinator\n\nTEST 5.5: Thread Safety\n- Write from background thread\n- Verify: Operation dispatched to main thread\n- Expected: No crashes\n\nTEST 5.6: Concurrent Writes\n- Write \"a\" and \"b\" in rapid succession\n- Verify: Last write wins (normal behavior)\n- Expected: Clipboard has \"b\"\n\n═══════════════════════════════════════════════════════════\n6. PASTE SIMULATION\n═══════════════════════════════════════════════════════════\n\nTEST 6.1: Basic Paste\n- Write \"test\" to clipboard\n- Focus TextEdit\n- Call simulatePaste()\n- Verify: \"test\" pasted in TextEdit\n- Expected: Paste works\n\nTEST 6.2: Paste in Different Apps\n- Test paste into:\n  - TextEdit\n  - Safari (input field)\n  - Terminal\n  - Xcode\n  - Slack\n- Expected: Paste works in all\n\nTEST 6.3: Paste With Accessibility Permission\n- Grant permission\n- Simulate paste\n- Expected: Works\n\nTEST 6.4: Paste Without Permission\n- Deny permission\n- Simulate paste\n- Expected: Fails silently (no paste occurs)\n\nTEST 6.5: Rapid Successive Pastes\n- Simulate paste 10 times rapidly\n- Expected: All pastes queue and execute\n\nTEST 6.6: CGEvent Creation\n- Verify: keyDown event created with .maskCommand\n- Verify: keyUp event created with .maskCommand\n- Verify: Events posted to .cghidEventTap\n- Expected: Proper event structure\n\n═══════════════════════════════════════════════════════════\n7. TRANSFORMATION FLOW COORDINATOR\n═══════════════════════════════════════════════════════════\n\nTEST 7.1: End-to-End Success Flow\n- Copy \"hello\"\n- Press hotkey\n- Expected:\n  1. Permission check passes\n  2. Clipboard read: \"hello\"\n  3. Safety checks pass\n  4. Transform: \"HELLO\" (uppercase for testing)\n  5. Write with marker\n  6. Paste simulated\n  7. \"HELLO\" appears in active app\n\nTEST 7.2: Binary Content Skipped\n- Copy image\n- Press hotkey\n- Expected: Transformation skipped, clipboard unchanged\n\nTEST 7.3: Self-Write Marker Skipped\n- Clipboard has marker\n- Press hotkey\n- Expected: Transformation skipped (no reprocessing)\n\nTEST 7.4: Permission Denial\n- Deny accessibility permission\n- Press hotkey\n- Expected: Alert shown, transformation aborted\n\nTEST 7.5: Transformation Timeout\n- Mock slow transformation (35 seconds)\n- Press hotkey\n- Expected: Timeout at 30 seconds, alert shown\n\nTEST 7.6: Clipboard Write Failure\n- Mock clipboard write failure\n- Press hotkey\n- Expected: Error handled, alert shown\n\nTEST 7.7: Concurrent Hotkey Presses\n- Press hotkey\n- While processing, press again\n- Expected: Second press ignored (isProcessing gate)\n\nTEST 7.8: Empty Clipboard\n- Clear clipboard\n- Press hotkey\n- Expected: Gracefully skipped\n\n═══════════════════════════════════════════════════════════\n8. ERROR HANDLING \u0026 EDGE CASES\n═══════════════════════════════════════════════════════════\n\nTEST 8.1: Network Failure (for future LLM)\n- Mock network error\n- Expected: Alert shown, clipboard unchanged\n\nTEST 8.2: Empty Transformation Result\n- Mock transformation returning empty string\n- Expected: Write empty string or show error (TBD)\n\nTEST 8.3: Very Long Text (10MB)\n- Copy 10MB of text\n- Transform\n- Expected: Handles without crash\n\nTEST 8.4: Special Characters\n- Copy text with emojis, unicode, newlines\n- Transform\n- Expected: All characters preserved\n\nTEST 8.5: App Backgrounded\n- Trigger transformation\n- Immediately background app\n- Expected: Transformation completes in background\n\nTEST 8.6: Clipboard Changed During Processing\n- Start transformation\n- Another app writes to clipboard\n- Expected: Write overwrites (last write wins)\n\n═══════════════════════════════════════════════════════════\n9. PERFORMANCE \u0026 RELIABILITY\n═══════════════════════════════════════════════════════════\n\nTEST 9.1: Latency\n- Measure time from hotkey press to paste\n- Expected: \u003c 200ms for simple transformations\n\nTEST 9.2: Memory Usage\n- Monitor memory during 100 transformations\n- Expected: No memory leaks\n\nTEST 9.3: CPU Usage\n- ClipboardMonitor running for 1 hour\n- Expected: \u003c 1% average CPU usage\n\nTEST 9.4: Battery Impact\n- Run app for 2 hours on laptop battery\n- Expected: Minimal battery drain (\u003c 2%)\n\nTEST 9.5: Crash Resilience\n- Force various component failures\n- Expected: App never crashes, always recovers\n\n═══════════════════════════════════════════════════════════\n10. INTEGRATION \u0026 USER EXPERIENCE\n═══════════════════════════════════════════════════════════\n\nTEST 10.1: First-Time User Flow\n- Fresh install\n- Press hotkey without permission\n- Grant permission\n- Press hotkey again\n- Expected: Smooth onboarding experience\n\nTEST 10.2: Daily Usage Scenarios\n- Copy text → transform → paste (10 times)\n- Copy image → hotkey → nothing happens (correct)\n- Copy file → hotkey → nothing happens (correct)\n- Expected: Reliable, predictable behavior\n\nTEST 10.3: Error Recovery\n- Trigger various errors\n- Verify: User always knows what happened\n- Verify: System returns to working state\n- Expected: Clear error messages, recovery possible\n\nAUTOMATED TEST COVERAGE:\n\nCreate XCTest suite:\n```swift\nclass Phase2IntegrationTests: XCTestCase {\n    func testClipboardMonitorDetectsChanges() { ... }\n    func testSelfWriteMarkerPreventsReprocessing() { ... }\n    func testBinaryContentSkipped() { ... }\n    func testAccessibilityPermissionCheck() { ... }\n    func testClipboardWriteWithMarker() { ... }\n    func testPasteSimulation() { ... }\n    func testEndToEndFlow() { ... }\n    func testErrorHandling() { ... }\n}\n```\n\nMANUAL TESTING CHECKLIST:\n\n□ Copy text from 5 different apps → transform → paste works\n□ Copy image → hotkey → nothing happens (correct)\n□ Copy file → hotkey → nothing happens (correct)\n□ Press hotkey rapidly 5 times → no crash, no duplicate pastes\n□ Deny accessibility permission → clear error message\n□ Grant permission → paste works immediately\n□ Clipboard monitoring runs for 10 minutes → no performance issues\n□ Transform while app backgrounded → works correctly\n\nSUCCESS CRITERIA:\n\nPhase 2 is complete when:\n✓ Can read text from clipboard reliably across different apps\n✓ Self-write marker prevents infinite reprocessing loops\n✓ Binary data (images, files) detected and skipped safely\n✓ Accessibility permission requested and granted smoothly\n✓ Transformed text written to clipboard with marker\n✓ Paste simulation works in all major applications\n✓ End-to-end flow (read → transform → write → paste) works\n✓ All error scenarios handled gracefully\n✓ No crashes, no memory leaks, no performance issues\n✓ User experience is smooth and predictable\n\nREGRESSION TESTING:\n\nAfter Phase 2 completion:\n- Run full test suite before each commit\n- Test on different macOS versions (12, 13, 14, 15)\n- Test with different default apps for different file types\n- Test under load (rapid transformations)\n\nDOCUMENTATION:\n\nAfter verification:\n- Document known limitations\n- Document performance characteristics\n- Document error scenarios and recovery\n- Update README with Phase 2 completion status\n\nPRIORITY: P2 (must complete before Phase 3)\nWithout thorough verification, Phase 3 (AI) and Phase 4 (Rules) will inherit bugs.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:09:43.824276-05:00","updated_at":"2025-12-13T11:12:01.77228-05:00","closed_at":"2025-12-13T11:12:01.77228-05:00","dependencies":[{"issue_id":"oc-74q.8","depends_on_id":"oc-74q","type":"parent-child","created_at":"2025-12-12T22:09:43.824914-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.8","depends_on_id":"oc-74q.1","type":"blocks","created_at":"2025-12-12T23:53:57.499876-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.8","depends_on_id":"oc-74q.2","type":"blocks","created_at":"2025-12-12T23:53:57.778938-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.8","depends_on_id":"oc-74q.3","type":"blocks","created_at":"2025-12-12T23:53:58.161908-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.8","depends_on_id":"oc-74q.4","type":"blocks","created_at":"2025-12-12T23:53:58.298418-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.8","depends_on_id":"oc-74q.5","type":"blocks","created_at":"2025-12-12T23:53:58.518504-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.8","depends_on_id":"oc-74q.6","type":"blocks","created_at":"2025-12-12T23:53:58.636422-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-74q.8","depends_on_id":"oc-74q.7","type":"blocks","created_at":"2025-12-12T23:53:58.799753-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-7nz","title":"AWS Bedrock SigV4 auth not implemented but UI allows configuration","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-16T19:31:30.887568-05:00","updated_at":"2025-12-16T20:35:11.303614-05:00","closed_at":"2025-12-16T20:35:11.303614-05:00","close_reason":"Closing tombstone issues - already resolved","comments":[{"id":13,"issue_id":"oc-7nz","author":"Chris Edwards","text":"## Root Cause Analysis\n\nAWSBedrockProviderClient.swift line 85-88 shows:\n```swift\ncase .sigV4:\n    // SigV4 signing requires complex HMAC-SHA256 computation that is not yet implemented.\n    throw LLMProviderError.authenticationError\n```\n\nBut the UI in ProviderSections.swift allows users to configure:\n- AWS Access Key ID  \n- AWS Secret Access Key\n\nUsers can enter valid credentials, save them, and try to use Bedrock - but it will ALWAYS fail with a generic 'authenticationError'.\n\n## User Impact\n- Confusing error message (\"Authentication failed\" vs \"SigV4 not implemented\")\n- Users may think their credentials are wrong when they're correct\n- Users waste time troubleshooting a config that can never work\n\n## Recommended Fix\nOption 1: Implement SigV4 signing\nOption 2: Hide/disable Access Key fields until SigV4 is implemented\nOption 3: Show clear message that only Bearer Token auth is supported","created_at":"2025-12-17T00:31:58Z"}],"deleted_at":"2025-12-16T19:36:00.753836-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-86z","title":"Security: EncryptedStorageService uses weak key derivation","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-16T19:31:30.206121-05:00","updated_at":"2025-12-16T20:35:11.300525-05:00","closed_at":"2025-12-16T20:35:11.300525-05:00","close_reason":"Closing tombstone issues - already resolved","comments":[{"id":12,"issue_id":"oc-86z","author":"Chris Edwards","text":"## Root Cause Analysis\n\nThe EncryptedStorageService at Sources/OptimusClip/Services/EncryptedStorageService.swift derives its encryption key from:\n1. A hardcoded seed string: \"com.optimusclip.secure.storage.v1\" (line 19)\n2. The device's hardware UUID (retrievable by any process on the system)\n\nThis means the encryption key is:\n- **Deterministic**: Anyone with access to the source code can compute it\n- **Not secret**: Device UUID is queryable via IOKit\n- **Stored in unprotected location**: UserDefaults is a plain plist file\n\n## Security Impact\n- API keys for OpenAI, Anthropic, AWS, etc. are effectively stored in cleartext\n- Any malware on the system can recover credentials\n- This is obfuscation, not encryption\n\n## Recommended Fix\nOption 1: Use Keychain in release builds (ifdef DEBUG for EncryptedStorage)\nOption 2: Derive key from a random value stored in Keychain (key protects key)\nOption 3: Accept trade-off and document it clearly for users","created_at":"2025-12-17T00:31:57Z"}],"deleted_at":"2025-12-16T19:38:47.659284-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-8m8","title":"Phase 0 - Project Scaffolding","description":"Epic tracking all foundational scaffolding work for Optimus Clip.\n\n## Background\nPhase 0 establishes the project foundation before any feature development begins. This includes:\n- Xcode project setup with proper Swift/SwiftUI configuration\n- Package management via Swift Package Manager\n- Build system integration with pnpm for a unified developer workflow\n- Basic app structure and entitlements\n\n## Why This Matters\nWithout proper scaffolding:\n- Build inconsistencies across developer machines\n- Missing entitlements will cause runtime failures\n- Poor project structure leads to technical debt\n- Integration issues between Node.js tooling and Xcode builds\n\n## Architecture Connection\nPhase 0 is the foundation layer. All subsequent phases build on top of this scaffolding:\n- Phase 1 (Menu Bar Shell) requires the app structure and build system\n- Phase 2 (Settings) requires SwiftUI window management\n- Phase 3+ (Core features) require proper entitlements and IPC setup\n\n## Technical Requirements\n- Xcode project with macOS deployment target 13.0+\n- Swift Package Manager for dependency management\n- pnpm scripts for build/run/test workflows\n- Info.plist with LSUIElement=true preparation\n- Code signing and entitlements setup\n- Basic app lifecycle hooks\n\n## Success Criteria\n- pnpm start launches the app successfully\n- App has proper bundle identifier\n- Code signing works (even if just ad-hoc for development)\n- Project structure follows macOS app conventions","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-12-12T22:04:39.773955-05:00","updated_at":"2025-12-12T22:17:25.964098-05:00","closed_at":"2025-12-12T22:17:25.964098-05:00"}
{"id":"oc-8v9","title":"Menu bar icon does not pulse during transformation","description":"When a transformation runs, the menu bar icon should pulse/animate to provide visual feedback. HotkeyManager calls menuBarStateManager?.startProcessing() and stopProcessing() but no visual effect shows. The MenuBarStateManager reference may not be set, or the pulse animation may not be implemented.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-13T21:12:09.266893Z","updated_at":"2025-12-16T09:40:59.744751-05:00","closed_at":"2025-12-16T09:40:59.744751-05:00"}
{"id":"oc-9bo","title":"Fix Ollama provider input alignment","description":"Host/Port row labels are misaligned with the Model row. Need consistent label width and alignment across all rows.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T20:24:28.397593-05:00","updated_at":"2025-12-14T20:28:40.685077-05:00","closed_at":"2025-12-14T20:28:40.685077-05:00"}
{"id":"oc-9g6","title":"Phase 0 - Project Scaffolding \u0026 Agent Configuration","description":"## Epic: Phase 0 - Project Scaffolding \u0026 Agent Configuration\n\n### Context \u0026 Purpose\nThis epic covers all pre-development infrastructure setup for Optimus Clip, a macOS menu bar app that transforms clipboard content intelligently. The goal is to establish a \"release-ready\" foundation BEFORE writing application code - this means setting up proper versioning, build scripts, CI/CD, linting, testing infrastructure, and developer documentation.\n\n### Why This Matters\n- **First Impressions**: A well-structured project signals professionalism and maintainability\n- **Prevents Technical Debt**: Establishing patterns early prevents costly refactoring later\n- **Developer Experience**: Good tooling makes development faster and more enjoyable\n- **Release Confidence**: Automated checks and versioning ensure safe deployments\n- **AI Assistant Effectiveness**: Clear structure and documentation helps AI assistants work more effectively\n\n### Technical Foundation\nThis phase establishes:\n1. **Build System**: Swift Package Manager with proper dependency management\n2. **Version Management**: Single source of truth (version.env) for semantic versioning\n3. **Quality Gates**: SwiftFormat, SwiftLint, and automated testing\n4. **Developer Workflow**: NPM scripts for common tasks, build scripts for packaging\n5. **CI/CD**: GitHub Actions for automated validation\n6. **Documentation**: CLAUDE.md for AI assistant context and developer onboarding\n\n### Success Criteria\nAll subtasks completed, and:\n- `swift build` succeeds\n- `swift test` passes\n- `pnpm check` (lint + format check) passes\n- `pnpm start` launches the app\n- `pnpm package` creates .app bundle with correct version from version.env\n- CI pipeline passes on push\n\n### Dependencies\nThis epic blocks all Phase 1+ work. No application features should be built until this foundation is solid.","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-12-12T22:04:39.562728-05:00","updated_at":"2025-12-13T08:50:47.865294-05:00","closed_at":"2025-12-13T08:50:47.865294-05:00"}
{"id":"oc-9g6.1","title":"Repository Structure","description":"## Task: Repository Structure\n\n### Purpose\nCreate the complete directory structure for a Swift Package Manager (SPM) executable that builds into a macOS app bundle.\n\n### Directory Layout\n```\noptimus-clip/\n├── CLAUDE.md              # AI assistant context and developer docs\n├── Package.swift          # SPM manifest\n├── package.json           # NPM scripts for developer workflow\n├── version.env            # Single source of truth for versions\n├── .swiftformat           # Code formatting rules\n├── .swiftlint.yml         # Linting rules and style guide\n├── .gitignore             # Git exclusions\n├── Info.plist             # macOS bundle metadata template\n├── Sources/\n│   ├── OptimusClip/       # Main executable target\n│   └── OptimusClipCore/   # Core library (reusable, testable)\n├── Tests/\n│   └── OptimusClipTests/  # Unit and integration tests\n├── Scripts/               # Build and utility scripts\n│   ├── compile_and_run.sh\n│   ├── package_app.sh\n│   └── kill_optimusclip.sh\n└── .github/workflows/     # CI/CD automation\n    └── ci.yml\n```\n\n### Architectural Decisions\n\n**Why OptimusClip + OptimusClipCore split?**\n- **OptimusClip** (executable): Thin entry point, just app lifecycle and UI setup\n- **OptimusClipCore** (library): All business logic, fully testable without app runtime\n- **Benefits**:\n  - Can unit test Core without launching app\n  - Core could be reused in other contexts (CLI tool, framework)\n  - Faster test cycles - no app bundle needed\n  - Clean separation of concerns\n\n**Why Scripts/ directory?**\n- SPM doesn't provide built-in app bundling (it's designed for libs/tools)\n- We need custom scripts to:\n  - Build executable with `swift build`\n  - Create `.app` bundle structure\n  - Copy executable into bundle\n  - Inject Info.plist with version\n  - Code sign (later phase)\n  - Package for distribution (later phase)\n\n**Why Info.plist at root?**\n- Not a source file, it's a template for bundle metadata\n- `package_app.sh` reads template, substitutes variables, writes to `.app/Contents/`\n- Keeps it visible and easy to edit\n\n**Why package.json in Swift project?**\n- NPM scripts provide cross-platform, memorable commands\n- `pnpm start` is more intuitive than `./Scripts/compile_and_run.sh`\n- Developer experience: consistency with web projects\n- Can add JS-based tooling later (docs generation, release notes)\n\n**Why CLAUDE.md?**\n- Context file for AI assistants (Claude, Cursor, etc.)\n- Documents architecture decisions, patterns, gotchas\n- Living documentation that evolves with codebase\n- Reduces repetitive explanations to AI assistants\n\n### Git Exclusions (.gitignore)\nEssential ignores:\n- `.build/` - SPM build artifacts\n- `*.xcodeproj` - Generated Xcode projects (use `swift package generate-xcodeproj`)\n- `OptimusClip.app/` - Built app bundles\n- `.DS_Store` - macOS metadata\n- `node_modules/` - NPM dependencies (if any JS tooling added)\n\n### Gotchas\n- SPM requires `Sources/` and `Tests/` naming - don't rename\n- Executable target MUST have a `main.swift` or `@main` struct\n- Info.plist is NOT in Sources/ - it's a bundle resource, not compiled\n\n### Acceptance Criteria\n- [ ] All directories created\n- [ ] .gitignore includes build artifacts\n- [ ] Structure matches SPM conventions\n- [ ] Ready for Package.swift and source files","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:05:14.820692-05:00","updated_at":"2025-12-13T00:11:03.254048-05:00","closed_at":"2025-12-13T00:11:03.254048-05:00","dependencies":[{"issue_id":"oc-9g6.1","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:05:14.821472-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.10","title":"Placeholder Code Files","description":"BACKGROUND \u0026 CONTEXT:\nPlaceholder code files serve a critical purpose in Phase 0: **proving the build system works end-to-end without implementing actual features**. This is the \"Hello World\" validation that:\n- Package.swift is configured correctly (targets, dependencies, platforms)\n- Swift 6 strict concurrency is enabled and working\n- SwiftFormat and SwiftLint rules are compatible with Swift 6 syntax\n- Test infrastructure can discover and run tests\n- Scripts can build, package, and launch the app\n- CI pipeline can build and test without errors\n\nThese files establish the **minimal contract** for the codebase:\n1. **OptimusClipApp.swift** - Proves the app can launch as a macOS executable\n2. **Transformation.swift** - Proves the Core library can be imported by tests\n3. **TransformationTests.swift** - Proves the test infrastructure works\n\nThink of this as \"infrastructure code\" not \"feature code\". The goal is to validate tooling, not solve problems. These files will be expanded (not replaced) in later phases, so they must be:\n- **Syntactically correct** (compiles without warnings)\n- **Architecturally sound** (establishes good patterns)\n- **Minimally functional** (doesn't crash, tests pass)\n\nThis approach follows the principle: **\"Make it build, make it right, make it fast\"**. Phase 0 is \"make it build\".\n\nREAL-WORLD PROBLEM/USE CASE:\n**Scenario: Developer sets up project, CI fails on first push**\n\n**Without placeholder code:**\n1. Developer creates Package.swift, .swiftformat, .swiftlint.yml\n2. Commits and pushes to GitHub\n3. CI runs: `swift build` → ERROR: \"No source files found\"\n4. Developer adds empty OptimusClipApp.swift\n5. CI runs: `swift build` → ERROR: \"Missing @main entry point\"\n6. Developer adds @main attribute\n7. CI runs: `swift build` → ERROR: \"OptimusClipCore module has no source files\"\n8. Developer adds empty Transformation.swift\n9. CI runs: `swift test` → ERROR: \"No tests found\"\n10. Developer adds empty test file\n11. CI runs: `swift test` → ERROR: \"Test target cannot find OptimusClipCore\"\n12. Developer fixes Package.swift dependencies\n13. CI finally passes after 13 commits of \"fix build\" noise\n\n**With placeholder code (this task):**\n1. Developer completes Phase 0 tasks (including placeholder code)\n2. Commits and pushes to GitHub\n3. CI runs: All checks pass ✅\n4. Developer moves to Phase 1 with confidence\n\n**Scenario: AI assistant generates code that breaks build**\n\n**Without placeholder patterns:**\n1. AI generates transformation using class instead of struct\n2. AI forgets @MainActor on UI code\n3. AI uses force unwrapping (!)\n4. Build fails or linter complains\n5. Developer fixes manually\n\n**With placeholder patterns:**\n1. AI reads placeholder code as examples\n2. Sees: struct, Sendable, @MainActor usage, explicit self\n3. Generates code matching patterns\n4. Build succeeds on first try\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n**File 1: Sources/OptimusClip/OptimusClipApp.swift**\n\nThis is the **@main entry point** for the executable. It must:\n- Conform to SwiftUI's App protocol\n- Launch without crashing (even if it does nothing visible yet)\n- Use correct macOS 15 patterns (MenuBarExtra will be added in Phase 1)\n- Be marked with @MainActor (required for UI code in Swift 6)\n\n```swift\nimport SwiftUI\n\n/// Main entry point for Optimus Clip.\n///\n/// Phase 0: Minimal app structure to verify build system.\n/// Phase 1: Add MenuBarExtra and status item.\n@main\nstruct OptimusClipApp: App {\n    var body: some Scene {\n        // Placeholder: Empty scene to satisfy App protocol\n        // Phase 1 will replace this with MenuBarExtra\n        WindowGroup {\n            Text(\"Optimus Clip\")\n                .frame(width: 200, height: 100)\n        }\n    }\n}\n```\n\n**Why this structure?**\n- `@main` attribute: Marks this as the app entry point (required for executables)\n- `App` protocol: SwiftUI's modern app lifecycle (not AppDelegate)\n- `WindowGroup`: Simplest Scene type (won't be visible in Phase 1 when we switch to menu bar only)\n- Placeholder text: Proves UI rendering works\n- No explicit @MainActor: App protocol implies it (but safe to add)\n\n**Alternative for pure validation (if SwiftUI causes issues):**\n```swift\nimport Cocoa\n\n@main\nstruct OptimusClipApp {\n    static func main() {\n        let app = NSApplication.shared\n        app.setActivationPolicy(.regular)\n        app.run()\n    }\n}\n```\nUse SwiftUI version unless SwiftUI imports cause problems.\n\n---\n\n**File 2: Sources/OptimusClipCore/Transformation.swift**\n\nThis is the **core abstraction** for clipboard transformations. It must:\n- Define a clear protocol for all transformations\n- Use async (support LLM network calls)\n- Use throws (support error handling)\n- Be Sendable (support Swift 6 concurrency)\n- Be documented (sets pattern for all protocols)\n\n```swift\nimport Foundation\n\n/// A clipboard transformation that processes text input and produces text output.\n///\n/// Transformations can be either algorithmic (local processing) or LLM-based (API calls).\n/// All transformations must be thread-safe and support Swift 6 strict concurrency.\n///\n/// Example implementations:\n/// - Whitespace stripping (algorithmic)\n/// - Line unwrapping (algorithmic)\n/// - Format as Jira ticket (LLM-based)\n///\n/// - Phase 0: Protocol definition only (minimal)\n/// - Phase 4: Algorithmic implementations (WhitespaceStripTransformation, UnwrapTransformation)\n/// - Phase 5: LLM implementations (OpenAITransformation, AnthropicTransformation)\npublic protocol Transformation: Sendable {\n    /// Transform the input text according to this transformation's logic.\n    ///\n    /// - Parameter input: The text to transform (clipboard content)\n    /// - Returns: The transformed text (to be written to clipboard)\n    /// - Throws: TransformationError if processing fails\n    func transform(_ input: String) async throws -\u003e String\n}\n\n/// Errors that can occur during transformation.\npublic enum TransformationError: Error, Sendable {\n    /// Input is empty or whitespace-only\n    case emptyInput\n\n    /// Transformation timed out (LLM calls)\n    case timeout\n\n    /// Network error (LLM API unreachable)\n    case networkError(String)\n\n    /// Invalid API key or auth failure\n    case authenticationError\n\n    /// Generic processing error\n    case processingError(String)\n}\n\n// MARK: - Placeholder Implementation\n\n/// Minimal placeholder transformation for Phase 0 testing.\n///\n/// Simply returns the input unchanged. Used to verify:\n/// - Protocol can be implemented\n/// - Tests can instantiate conforming types\n/// - Async/await works correctly\n///\n/// Phase 4 will add real algorithmic transformations.\npublic struct IdentityTransformation: Transformation {\n    public init() {}\n\n    public func transform(_ input: String) async throws -\u003e String {\n        // Phase 0: No-op transformation for testing\n        // Validates async/throws/Sendable semantics\n        if input.isEmpty {\n            throw TransformationError.emptyInput\n        }\n        return input\n    }\n}\n```\n\n**Why this structure?**\n- `public`: Core library is separate module, needs public API\n- `Sendable`: Required by Swift 6 for types used across concurrency boundaries\n- `async throws`: Future-proof for LLM calls (even if not used in Phase 0)\n- Well-documented: Sets pattern for all future protocols\n- Error enum: Establishes error handling pattern\n- Placeholder impl: Provides concrete type for testing\n\n**Key architectural decisions:**\n1. **Protocol not base class**: Prefer protocol-oriented design (more flexible, supports value types)\n2. **Async by default**: Even algorithmic transformations use async (consistent interface)\n3. **String in/String out**: Simple contract (clipboard is text)\n4. **Explicit error type**: Not just `Error` (better error handling in UI)\n\n---\n\n**File 3: Tests/OptimusClipTests/TransformationTests.swift**\n\nThis is the **test infrastructure validation**. It must:\n- Use Swift Testing framework (not XCTest)\n- Import OptimusClipCore with @testable\n- Test the Transformation protocol via placeholder impl\n- Verify async/await works in tests\n- Establish testing patterns for future tests\n\n```swift\nimport Testing\n@testable import OptimusClipCore\n\n/// Test suite for Transformation protocol and implementations.\n///\n/// Phase 0: Validates test infrastructure with minimal placeholder.\n/// Phase 4: Comprehensive tests for algorithmic transformations.\n/// Phase 5: Tests for LLM transformations (with mocking).\n@Suite(\"Transformation Tests\")\nstruct TransformationTests {\n\n    // MARK: - Phase 0: Infrastructure Validation\n\n    @Test(\"IdentityTransformation returns input unchanged\")\n    func testIdentityTransformation() async throws {\n        let transformation = IdentityTransformation()\n        let input = \"Hello, World!\"\n        let output = try await transformation.transform(input)\n\n        #expect(output == input)\n    }\n\n    @Test(\"IdentityTransformation throws on empty input\")\n    func testIdentityTransformationEmptyInput() async {\n        let transformation = IdentityTransformation()\n        let input = \"\"\n\n        await #expect(throws: TransformationError.self) {\n            try await transformation.transform(input)\n        }\n    }\n\n    @Test(\"Transformation protocol supports async/await\")\n    func testTransformationAsync() async throws {\n        // Verify async semantics work correctly\n        let transformation = IdentityTransformation()\n\n        let task = Task {\n            try await transformation.transform(\"Async test\")\n        }\n\n        let result = try await task.value\n        #expect(result == \"Async test\")\n    }\n\n    // MARK: - Phase 4: Algorithmic Transformation Tests (TODO)\n\n    // TODO: Phase 4 - Add tests for WhitespaceStripTransformation\n    // TODO: Phase 4 - Add tests for UnwrapTransformation\n\n    // MARK: - Phase 5: LLM Transformation Tests (TODO)\n\n    // TODO: Phase 5 - Add tests for OpenAI integration (with mocking)\n    // TODO: Phase 5 - Add tests for Anthropic integration (with mocking)\n}\n```\n\n**Why this structure?**\n- `@Suite`: Swift Testing's organization unit (like XCTest's test case)\n- `@Test`: Individual test with descriptive name\n- `#expect`: Swift Testing's assertion (more powerful than XCTAssert)\n- `throws:` variant: Tests error conditions cleanly\n- `async throws`: Tests asynchronous code naturally\n- TODO comments: Mark future expansion points\n\n**Swift Testing advantages over XCTest:**\n1. **Better async support**: No completion handlers or expectations needed\n2. **Better error testing**: `#expect(throws:)` is cleaner than XCTAssertThrowsError\n3. **Parameterized tests**: Can pass arrays of test cases (not shown here, but useful later)\n4. **Parallel by default**: Tests run concurrently (faster CI)\n5. **Better organization**: Suites and tags for filtering\n\n**Testing strategy:**\n- Phase 0: Prove infrastructure works (3 simple tests)\n- Phase 4: Test algorithmic transformations exhaustively (edge cases, Unicode, empty input)\n- Phase 5: Test LLM integrations with mocks (no real API calls in tests)\n- Phase 6: Test Keychain operations (with temporary keychain)\n\nARCHITECTURAL CONNECTIONS:\n- OptimusClipApp.swift → Entry point for Scripts/compile_and_run.sh\n- Transformation.swift → Imported by future transformation implementations (Phase 4-5)\n- Transformation.swift → Imported by OptimusClip for UI (Phase 3-5)\n- TransformationTests.swift → Run by `swift test` and CI pipeline\n- All three files validated by CI (format, lint, build, test)\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. **@main Attribute Required:**\n   - Problem: Executable target needs entry point\n   - Solution: Exactly one file must have `@main`\n   - Error if missing: \"Entry point not found\"\n   - Error if duplicate: \"Multiple @main attributes\"\n\n2. **Sendable Conformance:**\n   - Problem: Swift 6 requires explicit Sendable for protocols\n   - Solution: Add `: Sendable` to Transformation protocol\n   - Error if missing: \"Type does not conform to Sendable\"\n\n3. **Public vs Internal:**\n   - Problem: Tests can't see OptimusClipCore types\n   - Solution: Mark protocol/types `public`, or use `@testable import`\n   - Used `public` for protocol (it's API), `@testable` for tests (access internals)\n\n4. **Empty Test Target:**\n   - Problem: Swift Package Manager errors if no tests\n   - Solution: At least one test suite required\n   - CI would fail: \"No tests found\"\n\n5. **Async Test Syntax:**\n   - Problem: XCTest makes async testing awkward\n   - Solution: Use Swift Testing framework (supports async natively)\n   - Benefits: Cleaner syntax, no expectation.fulfill()\n\n6. **SwiftFormat Explicit Self:**\n   - Problem: Closures need `self.` but placeholder has none\n   - Solution: Placeholder is simple enough to avoid closures\n   - Future: All closures must use `self.property` (enforced by swiftformat)\n\n7. **SwiftLint Force Unwrap:**\n   - Problem: No `!` operators allowed\n   - Solution: Placeholder doesn't need any\n   - Future: Use `guard let` or `if let` instead\n\n8. **Module Visibility:**\n   - Problem: OptimusClip can't import OptimusClipCore\n   - Solution: Package.swift must declare dependency\n   - Verify: Add `import OptimusClipCore` test to OptimusClipApp.swift later\n\nTESTING REQUIREMENTS:\n1. **Build Verification:**\n   - `swift build` succeeds (no errors, no warnings)\n   - `swift build -c release` succeeds\n   - Both debug and release configurations work\n\n2. **Test Verification:**\n   - `swift test` succeeds\n   - All 3 placeholder tests pass\n   - Test output shows \"3 tests passed\"\n   - No test failures, no test crashes\n\n3. **Format/Lint Verification:**\n   - `swiftformat Sources Tests --lint` passes (no unformatted files)\n   - `swiftlint lint --strict` passes (no warnings or errors)\n\n4. **Script Verification:**\n   - `pnpm start` completes without errors\n   - OptimusClip.app launches (shows placeholder window)\n   - No crash on launch\n   - Can quit normally\n\n5. **CI Verification:**\n   - GitHub Actions CI passes all jobs\n   - Format check passes\n   - Lint check passes\n   - Build check passes\n   - Test check passes\n\nSUCCESS CRITERIA:\n- [ ] `Sources/OptimusClip/OptimusClipApp.swift` created with @main entry point\n- [ ] `Sources/OptimusClipCore/Transformation.swift` created with protocol definition\n- [ ] `Tests/OptimusClipTests/TransformationTests.swift` created with 3 passing tests\n- [ ] `swift build` succeeds (debug config)\n- [ ] `swift build -c release` succeeds (release config)\n- [ ] `swift test` succeeds (all tests pass)\n- [ ] `pnpm check` passes (format and lint)\n- [ ] `pnpm start` launches app without crash\n- [ ] CI pipeline passes (all jobs green)\n- [ ] No compiler warnings\n- [ ] No linter warnings\n- [ ] Files follow Swift 6 concurrency rules (Sendable, async)\n\nCONFIGURATION OPTIONS:\n- **Window size (placeholder):** 200x100 default (won't matter in Phase 1)\n- **Test timeout:** Default (no explicit timeout needed for simple tests)\n- **Error messages:** Keep generic for Phase 0 (detailed in Phase 4+)\n\nPERFORMANCE CONSIDERATIONS:\n- Placeholder code should compile in \u003c 5 seconds\n- Tests should run in \u003c 1 second\n- App should launch in \u003c 500ms\n- No heavy dependencies yet (just Foundation + SwiftUI)\n\nSECURITY CONSIDERATIONS:\n- No security implications in Phase 0\n- No API keys or secrets\n- No clipboard access yet\n- No network calls yet\n\nIMPLEMENTATION ORDER:\n1. Create `Sources/OptimusClip/` directory\n2. Write `OptimusClipApp.swift` (simplest possible @main)\n3. Run `swift build` → Should succeed\n4. Create `Sources/OptimusClipCore/` directory\n5. Write `Transformation.swift` (protocol + placeholder impl)\n6. Run `swift build` → Should succeed\n7. Create `Tests/OptimusClipTests/` directory\n8. Write `TransformationTests.swift` (3 simple tests)\n9. Run `swift test` → Should pass (3/3)\n10. Run `pnpm check` → Should pass (format + lint)\n11. Run `pnpm start` → Should launch app\n12. Verify CI passes on push\n\nCODE ORGANIZATION:\n```\noptimus-clip/\n├── Sources/\n│   ├── OptimusClip/\n│   │   └── OptimusClipApp.swift        # @main entry point (50 lines)\n│   └── OptimusClipCore/\n│       └── Transformation.swift        # Protocol + placeholder (100 lines)\n├── Tests/\n│   └── OptimusClipTests/\n│       └── TransformationTests.swift   # Test suite (80 lines)\n└── Package.swift                       # Must declare all targets/dependencies\n```\n\nPRIORITY: P0 (Required to prove build system works before feature development)\n\nESTIMATED TIME: 30-45 minutes (write + test + iterate)\n\nFUTURE EVOLUTION:\n**Phase 1:**\n- OptimusClipApp.swift: Replace WindowGroup with MenuBarExtra\n- Add NSApplicationDelegateAdaptor\n- Add status icon and menu items\n\n**Phase 4:**\n- Transformation.swift: Add algorithmic implementations\n- WhitespaceStripTransformation struct\n- UnwrapTransformation struct\n- TransformationTests.swift: Add comprehensive test cases\n\n**Phase 5:**\n- Transformation.swift: Add LLM implementations\n- OpenAITransformation struct\n- AnthropicTransformation struct\n- TransformationTests.swift: Add mocked API tests\n\n**Phase 6:**\n- No changes to placeholder files (isolated in Core)\n\nDEPENDENCIES:\n- Requires Package.swift with targets defined\n- Requires directory structure (Sources/, Tests/)\n- Requires .swiftformat and .swiftlint.yml (for validation)\n- Should be last task in Phase 0 (proves all scaffolding works)\n\nCOMMON FAILURE MODES:\n1. **\"Cannot find 'App' in scope\"** → Missing `import SwiftUI`\n2. **\"Type does not conform to Sendable\"** → Add `: Sendable` to protocol\n3. **\"No such module 'OptimusClipCore'\"** → Package.swift target misconfigured\n4. **\"No tests found\"** → Test file not in correct directory\n5. **\"@testable import failed\"** → Target not declared as testable in Package.swift\n\nVALIDATION COMMANDS:\n```bash\n# Build validation\nswift build                     # Debug config\nswift build -c release          # Release config\n\n# Test validation\nswift test                      # Run all tests\nswift test --filter \"Transformation\"  # Run specific suite\n\n# Format validation\nswiftformat Sources Tests --lint  # Check formatting\n\n# Lint validation\nswiftlint lint --strict         # Check style rules\n\n# Integration validation\npnpm check                      # Format + lint\npnpm test                       # Build + test\npnpm start                      # Build + package + launch\n```\n\nREFERENCE MATERIALS:\n- Swift Package Manager targets: https://www.swift.org/documentation/package-manager/\n- Swift Testing framework: https://developer.apple.com/documentation/testing\n- Swift 6 Sendable: https://www.swift.org/migration/documentation/swift-6-concurrency-migration-guide/sendable\n- SwiftUI App lifecycle: https://developer.apple.com/documentation/swiftui/app\n\nBLOCKERS/RISKS:\n- Blocked by Package.swift creation (must define targets first)\n- Risk: Swift 6 concurrency errors (mitigated by using Sendable everywhere)\n- Risk: Test framework confusion (use Swift Testing, not XCTest)\n\nVERIFICATION CHECKLIST:\nAfter creating placeholder files, verify:\n- [ ] Files are in correct directories\n- [ ] `swift build` succeeds (no warnings)\n- [ ] `swift test` succeeds (3 tests pass)\n- [ ] `pnpm check` passes (format + lint)\n- [ ] `pnpm start` launches app\n- [ ] CI passes (all jobs green)\n- [ ] Git diff shows expected files only\n- [ ] No unintended changes to other files","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:06:15.639859-05:00","updated_at":"2025-12-13T01:02:08.263042-05:00","closed_at":"2025-12-13T01:02:08.263042-05:00","dependencies":[{"issue_id":"oc-9g6.10","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:06:15.640333-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.10","depends_on_id":"oc-9g6.3","type":"blocks","created_at":"2025-12-12T23:53:57.514369-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.11","title":"Phase 0 Verification","description":"## Task: Phase 0 Verification\n\n### Background \u0026 Purpose\n\nPhase 0 Verification is the quality gate before proceeding to Phase 1 feature development. It ensures all scaffolding, build tooling, and CI infrastructure works correctly. Skipping this verification risks building features on a broken foundation.\n\n**Why Verification Matters:**\n- A broken build caught in Phase 4 costs hours to debug\n- A broken build caught in Phase 0 costs minutes to fix\n- CI failures discovered late block the entire team\n- Scaffolding issues compound with every added file\n\n**Philosophy:**\n\u003e \"Measure twice, cut once\" - Verify the foundation before building on it.\n\n### Verification Checklist\n\nEach check must pass before Phase 1 begins. Any failure requires returning to the relevant Phase 0 task.\n\n#### 1. Swift Build Verification\n\n**What to Check:**\n```bash\nswift build 2\u003e\u00261\n```\n\n**Expected:**\n- Exit code 0\n- No warnings (or only expected deprecation warnings from dependencies)\n- Builds complete successfully\n\n**Common Issues:**\n- Package resolution failure: Delete `.build` and retry\n- Missing dependencies: Check Package.swift\n- Swift version mismatch: Verify `.swift-version` file\n\n**Acceptance Criteria:**\n- [ ] `swift build` completes with exit code 0\n- [ ] No compile errors\n- [ ] Warnings are documented (if any)\n\n#### 2. Swift Test Verification\n\n**What to Check:**\n```bash\nswift test 2\u003e\u00261\n```\n\n**Expected:**\n- At least one test runs\n- All tests pass (green)\n- Test output shows \"All tests passed\"\n\n**Why at Least One Test?**\n- Proves test infrastructure works\n- Placeholder test catches if testing breaks later\n- Establishes pattern for adding more tests\n\n**Sample Verification Test:**\n```swift\nimport Testing\n@testable import OptimusClipCore\n\n@Test func projectScaffoldingWorks() async throws {\n    // If this test runs, our test infrastructure is working\n    #expect(1 + 1 == 2)\n}\n```\n\n**Acceptance Criteria:**\n- [ ] `swift test` exits with code 0\n- [ ] At least 1 test executed\n- [ ] All tests pass\n\n#### 3. Code Quality Verification\n\n**What to Check:**\n```bash\npnpm check\n```\n\n**Expected:**\nThis runs the configured linters:\n- swift-format --lint (code style)\n- swiftlint (Swift best practices)\n\n**Common Issues:**\n- swift-format not installed: `brew install swift-format`\n- swiftlint not installed: `brew install swiftlint`\n- Config files missing: Check `.swift-format.json` and `.swiftlint.yml`\n\n**Acceptance Criteria:**\n- [ ] `pnpm check` exits with code 0\n- [ ] No lint errors (warnings OK but should be minimal)\n- [ ] Both swift-format and swiftlint pass\n\n#### 4. Development Workflow Verification\n\n**What to Check:**\n```bash\npnpm start\n```\n\n**Expected:**\n- App builds (compile_and_run.sh executes)\n- App launches\n- Menu bar icon appears\n- No crash on launch\n\n**How to Verify Menu Bar:**\n1. Look for clipboard icon in system menu bar (top right of screen)\n2. Click icon - should show menu with \"Settings\" and \"Quit\"\n3. Quit via menu or Cmd+Q\n\n**Common Issues:**\n- Script not executable: `chmod +x Scripts/*.sh`\n- App in Dock instead of menu bar: Check Info.plist LSUIElement\n- Icon not visible: Check if running headless/SSH (needs display)\n\n**Acceptance Criteria:**\n- [ ] `pnpm start` launches app successfully\n- [ ] Menu bar icon visible\n- [ ] App does not appear in Dock\n- [ ] App does not crash\n\n#### 5. Package Verification\n\n**What to Check:**\n```bash\npnpm package\n```\n\n**Expected:**\n- Creates `OptimusClip.app` in project root\n- App bundle contains correct structure\n- Info.plist has correct version info\n\n**Version Verification:**\n```bash\n# Check Info.plist contents\n/usr/libexec/PlistBuddy -c \"Print CFBundleShortVersionString\" OptimusClip.app/Contents/Info.plist\n# Should output: 0.1.0 (or whatever version.env specifies)\n\n/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" OptimusClip.app/Contents/Info.plist\n# Should output: 1 (or whatever version.env specifies)\n```\n\n**Bundle Structure:**\n```\nOptimusClip.app/\n└── Contents/\n    ├── Info.plist        ← Must have version info\n    ├── MacOS/\n    │   └── OptimusClip   ← Must be executable\n    └── Resources/        ← May be empty initially\n```\n\n**Acceptance Criteria:**\n- [ ] `OptimusClip.app` created\n- [ ] MARKETING_VERSION matches version.env\n- [ ] BUILD_NUMBER matches version.env\n- [ ] Executable at correct path\n\n#### 6. CI Pipeline Verification\n\n**What to Check:**\n- Push to GitHub\n- Wait for CI to complete\n- Check Actions tab for all green\n\n**Expected:**\nAll CI jobs pass:\n- Lint check\n- Build check\n- Test check\n\n**Common Issues:**\n- macOS runner not available: Check runner configuration\n- Xcode version mismatch: Specify in workflow\n- Timeout: Increase if builds are slow\n\n**Acceptance Criteria:**\n- [ ] All CI jobs pass (green checkmarks)\n- [ ] No failures or warnings in CI logs\n- [ ] CI completes in reasonable time (\u003c10 minutes)\n\n### Evidence Collection\n\nDocument your verification for future reference:\n\n**Recommended Evidence:**\n1. **Screenshot**: Running app in menu bar\n2. **Screenshot**: CI pipeline all green\n3. **Terminal Output**: Copy of version verification commands\n4. **Notes**: Any deviations from expected behavior\n\n**Where to Store:**\n- Create `docs/verification/phase-0.md` (if keeping records)\n- Or just confirm all checks pass in this bead's comments\n\n### Failure Protocol\n\n**If Any Check Fails:**\n1. STOP - Do not proceed to Phase 1\n2. Identify which Phase 0 task is responsible\n3. Reopen that task and fix the issue\n4. Re-run ALL verification checks (not just the failed one)\n5. Only proceed when ALL checks pass\n\n**Why Re-run All Checks?**\nFixing one issue might break something else. Full verification ensures the foundation is solid.\n\n### Success Criteria\n\nAll of the following must be true:\n\n- [ ] `swift build` succeeds without errors\n- [ ] `swift test` runs at least one passing test\n- [ ] `pnpm check` passes lint verification\n- [ ] `pnpm start` launches app with menu bar icon\n- [ ] `pnpm package` creates correctly versioned app bundle\n- [ ] GitHub Actions CI pipeline is all green\n- [ ] No blocking issues discovered\n\n### What Happens Next\n\n**When All Checks Pass:**\n1. Mark this task as complete\n2. Phase 0 is officially done\n3. Proceed to Phase 1: Menu Bar Shell\n\n**When Checks Fail:**\n1. Document the failure\n2. Return to the relevant Phase 0 task\n3. Fix and verify\n4. Return here for full verification\n\n### Architectural Significance\n\nThis verification task depends on ALL other Phase 0 tasks because it validates their combined output. It is the final checkpoint before feature development begins.\n\n**Dependencies:**\n- Repository Structure (oc-9g6.1)\n- Bundle ID \u0026 Versioning (oc-9g6.2)\n- SPM Packages (oc-9g6.3)\n- Build Scripts (oc-9g6.4)\n- Info.plist Configuration (oc-9g6.5)\n- App Skeleton (oc-9g6.6)\n- SwiftFormat Config (oc-9g6.7)\n- SwiftLint Config (oc-9g6.8)\n- GitHub Actions CI (oc-9g6.9)\n- npm Scripts (oc-9g6.10)\n\n**Blocks:**\n- Phase 1: Menu Bar Shell (oc-uzt)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:06:16.195103-05:00","updated_at":"2025-12-13T08:50:47.863405-05:00","closed_at":"2025-12-13T08:50:47.863405-05:00","dependencies":[{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:06:16.195567-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6.2","type":"blocks","created_at":"2025-12-12T23:54:04.700606-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6.3","type":"blocks","created_at":"2025-12-12T23:54:04.973538-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6.4","type":"blocks","created_at":"2025-12-12T23:54:05.315842-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6.5","type":"blocks","created_at":"2025-12-12T23:54:05.549041-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6.6","type":"blocks","created_at":"2025-12-12T23:54:05.813285-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6.7","type":"blocks","created_at":"2025-12-12T23:54:06.06314-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6.8","type":"blocks","created_at":"2025-12-12T23:54:06.295486-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6.9","type":"blocks","created_at":"2025-12-12T23:54:06.511379-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.11","depends_on_id":"oc-9g6.10","type":"blocks","created_at":"2025-12-12T23:54:06.75473-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.2","title":"Bundle ID \u0026 Versioning Setup","description":"## Task: Bundle ID \u0026 Versioning Setup\n\n### Background \u0026 Context\nEvery macOS application requires a unique **Bundle Identifier** (Bundle ID) - a reverse-DNS string that uniquely identifies the app across the entire Apple ecosystem. This identifier is foundational to macOS app development and affects numerous system services.\n\n### Why Bundle ID Matters\n\nThe Bundle ID (`com.yourname.optimusclip`) is used by:\n\n1. **macOS Launch Services**: Associates file types, URL schemes, and prevents duplicate instances\n2. **Keychain Access**: API keys stored under this identifier can only be accessed by apps with matching ID\n3. **Sparkle Auto-Updates**: Update feeds are tied to Bundle ID - changing it breaks update continuity\n4. **Code Signing**: Developer ID certificates are associated with team ID embedded in Bundle ID\n5. **User Preferences**: @AppStorage (UserDefaults) paths include Bundle ID\n6. **Accessibility Permissions**: System grants permissions per Bundle ID, not per executable\n7. **Gatekeeper**: Notarization tickets are stapled to specific Bundle IDs\n\n**Changing Bundle ID after release is extremely disruptive** - users lose their settings, Keychain credentials become inaccessible, and auto-updates break. Choose carefully and stick with it.\n\n### Versioning Strategy\n\n**Two Numbers, Two Purposes:**\n\n1. **MARKETING_VERSION** (CFBundleShortVersionString)\n   - What users see: \"1.0.0\", \"1.2.3\"\n   - Semantic versioning: MAJOR.MINOR.PATCH\n   - MAJOR: Breaking changes or major features\n   - MINOR: New features, backward compatible\n   - PATCH: Bug fixes only\n\n2. **BUILD_NUMBER** (CFBundleVersion)\n   - What Sparkle compares for updates\n   - MUST monotonically increase (never decrease or repeat)\n   - Recommended format: `YYYYMMDDnn` (e.g., `2024120101`)\n   - Alternative: Simple integer starting at 1\n\n**Critical Rule**: Build number must ALWAYS increase, even if marketing version decreases. Example: If you ship 1.1.0 (build 2024120101) then need to hotfix 1.0.x, the hotfix must be build 2024120102 or higher, even though marketing version is \"lower.\"\n\n### Implementation Details\n\n**version.env** - Single source of truth:\n```bash\n# Version configuration - edit this file for releases\nMARKETING_VERSION=\"0.1.0\"\nBUILD_NUMBER=\"1\"\n```\n\nThis file is:\n- Read by `package_app.sh` during build\n- Substituted into Info.plist template\n- Checked into git (tracks version history)\n- Easy to edit (no XML parsing needed)\n\n**Why not hardcode in Info.plist?**\n- Prevents version drift between build script knowledge and bundle metadata\n- Single source of truth reduces errors\n- Easy to script version bumps (`sed -i '' 's/BUILD_NUMBER=.*/BUILD_NUMBER=\"2\"/' version.env`)\n\n### Architectural Decisions\n\n**Bundle ID Format**: `com.\u003cyourname\u003e.optimusclip`\n- Lowercase (Apple convention)\n- No spaces or special characters\n- Your domain/name for uniqueness\n- Product name at end\n\n**YYYYMMDDnn Build Numbers**:\n- Human-readable (know when build was made)\n- Naturally increasing with time\n- `nn` suffix allows multiple builds per day\n- Alternative: Simple integers (1, 2, 3...) work fine for small projects\n\n### Edge Cases \u0026 Gotchas\n\n1. **Don't use dots in BUILD_NUMBER** - Some tools parse it as version components\n2. **Don't reuse build numbers** - Sparkle may skip updates if it sees \"same\" version\n3. **Team ID in Bundle ID** - Not required for Bundle ID, but appears in code signing identity\n4. **Case sensitivity** - Bundle IDs are case-insensitive on macOS but case-preserving\n\n### Acceptance Criteria\n- [ ] version.env file exists with MARKETING_VERSION and BUILD_NUMBER\n- [ ] Bundle ID documented and consistent across all references\n- [ ] package_app.sh reads version.env and substitutes into Info.plist\n- [ ] `pnpm package` produces .app with correct version in About dialog","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:05:23.643578-05:00","updated_at":"2025-12-13T00:15:18.725545-05:00","closed_at":"2025-12-13T00:15:18.725545-05:00","dependencies":[{"issue_id":"oc-9g6.2","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:05:23.644133-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.2","depends_on_id":"oc-9g6.1","type":"blocks","created_at":"2025-12-12T23:53:54.751867-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.3","title":"Package.swift Configuration","description":"## Task: Package.swift Configuration\n\n### BACKGROUND \u0026 CONTEXT\n\nThe Package.swift file is the Swift Package Manager (SPM) manifest that defines the entire build configuration for Optimus Clip. This is the foundation of the project's build system and dependency management. Unlike Xcode projects with complex .xcodeproj XML files, SPM uses a simple Swift DSL that is both human-readable and version-control friendly.\n\nFor Optimus Clip, we're using Swift 6.0 (the latest stable version) which introduces strict concurrency checking and data-race safety at compile time. This is critical for a clipboard monitoring application that runs concurrent tasks (clipboard polling, LLM API calls, paste simulation) without race conditions.\n\nThe package structure follows a modular architecture pattern:\n- **OptimusClip** (executable target): The thin entry point with @main, UI layer, and app lifecycle\n- **OptimusClipCore** (library target): All business logic, transformation engine, LLM clients, clipboard utilities\n- **OptimusClipTests** (test target): Unit and integration tests\n\nThis separation is essential for testability. The Core library contains pure logic with no AppKit/SwiftUI dependencies, making it fully testable in isolation. The executable target is kept minimal to reduce the surface area that requires app runtime to test.\n\n### REAL-WORLD PROBLEM/USE CASE\n\n**Without proper Package.swift:**\n- Developer clones the repo\n- Runs `swift build`\n- Gets cryptic errors: \"error: root manifest not found\"\n- Has to manually create project structure\n- Doesn't know which dependencies to add\n- Spends hours troubleshooting build configuration\n\n**With comprehensive Package.swift:**\n- Developer clones the repo\n- Runs `swift build`\n- SPM automatically fetches dependencies (KeyboardShortcuts, MenuBarExtraAccess)\n- All targets compile successfully\n- Can immediately run `swift test` and see passing tests\n- CI pipeline works out of the box\n\n**Real scenario during development:**\n1. Developer wants to add a new transformation algorithm\n2. Creates `Sources/OptimusClipCore/Transformations/WhitespaceStripper.swift`\n3. SPM automatically includes it in the Core target (no manual file list management)\n4. Can immediately test it with `import OptimusClipCore` in test files\n5. The executable target automatically gets access through its dependency on Core\n\n### WHY THIS APPROACH\n\n**Why Swift Package Manager instead of Xcode projects?**\n- **Version control friendly**: Single Swift file instead of complex XML\n- **No merge conflicts**: Xcode project files cause constant merge conflicts in teams\n- **Deterministic builds**: Same Package.swift produces identical builds everywhere\n- **Scriptable**: Can programmatically read/modify package configuration\n- **Modern Apple standard**: SPM is Apple's recommended build system going forward\n\n**Why split Core and App targets?**\n- **Testability**: Core logic is pure and testable without app runtime\n- **Reusability**: Core could be extracted as a framework for CLI tool or browser extension\n- **Faster test cycles**: Tests only depend on Core, not entire app bundle\n- **Clear boundaries**: Forces separation of business logic from UI layer\n- **Independent versioning**: Core could theoretically have its own version\n\n**Why Swift 6.0?**\n- **Concurrency safety**: Compile-time data-race detection prevents crashes\n- **Latest language features**: Pattern matching improvements, macro support\n- **Future-proof**: Will be supported for years (Swift 5 enters maintenance mode soon)\n- **Strict by default**: Catches common bugs at compile time\n\n**Why these specific dependencies?**\n- **KeyboardShortcuts** (sindresorhus): Battle-tested, 2k+ stars, handles global hotkeys reliably on macOS 10.15+\n- **MenuBarExtraAccess** (orchetect): Solves critical SwiftUI limitation - access to NSStatusItem from MenuBarExtra for pulse animation\n\n### TECHNICAL IMPLEMENTATION DETAILS\n\n**Complete Package.swift template:**\n\n```swift\n// swift-tools-version: 6.0\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"OptimusClip\",\n    \n    // PLATFORM REQUIREMENTS\n    // macOS 15 (Sequoia) required for:\n    // - MenuBarExtra SwiftUI component\n    // - Swift 6 concurrency improvements\n    // - Latest SF Symbols\n    platforms: [\n        .macOS(.v15)\n    ],\n    \n    // PRODUCTS\n    // What this package produces (the executable app)\n    products: [\n        .executable(\n            name: \"OptimusClip\",\n            targets: [\"OptimusClip\"]\n        )\n    ],\n    \n    // DEPENDENCIES\n    // External packages this project depends on\n    dependencies: [\n        // Global hotkey recording and management\n        // Allows users to define custom keyboard shortcuts\n        .package(\n            url: \"https://github.com/sindresorhus/KeyboardShortcuts\",\n            from: \"2.0.0\"\n        ),\n        \n        // Access NSStatusItem from SwiftUI MenuBarExtra\n        // Required for menu bar icon pulse animation\n        .package(\n            url: \"https://github.com/orchetect/MenuBarExtraAccess\",\n            from: \"1.0.0\"\n        ),\n        \n        // NOTE: LLM client packages will be added in Phase 5:\n        // - LLMChatOpenAI for OpenAI/OpenRouter/Ollama\n        // - LLMChatAnthropic for Anthropic Claude\n        // - AWS SDK for Swift for Bedrock\n        \n        // NOTE: Sparkle auto-updater will be added in Phase 7\n        // .package(url: \"https://github.com/sparkle-project/Sparkle\", from: \"2.8.0\"),\n    ],\n    \n    // TARGETS\n    // The building blocks of this package\n    targets: [\n        // EXECUTABLE TARGET: OptimusClip\n        // The main application entry point\n        // This is the \"thin\" layer - just UI and app lifecycle\n        .executableTarget(\n            name: \"OptimusClip\",\n            dependencies: [\n                // Depends on our Core library\n                \"OptimusClipCore\",\n                \n                // Third-party dependencies\n                \"KeyboardShortcuts\",\n                .product(name: \"MenuBarExtraAccess\", package: \"MenuBarExtraAccess\"),\n            ],\n            path: \"Sources/OptimusClip\",\n            \n            // Swift 6 concurrency checking\n            swiftSettings: [\n                .enableUpcomingFeature(\"StrictConcurrency\"),\n                .enableExperimentalFeature(\"AccessLevelOnImport\")\n            ]\n        ),\n        \n        // LIBRARY TARGET: OptimusClipCore\n        // All business logic, fully testable\n        // No AppKit/SwiftUI dependencies (pure Swift)\n        .target(\n            name: \"OptimusClipCore\",\n            dependencies: [],\n            path: \"Sources/OptimusClipCore\",\n            \n            // Swift 6 concurrency checking\n            swiftSettings: [\n                .enableUpcomingFeature(\"StrictConcurrency\"),\n                .enableExperimentalFeature(\"AccessLevelOnImport\")\n            ]\n        ),\n        \n        // TEST TARGET: OptimusClipTests\n        // Unit and integration tests\n        .testTarget(\n            name: \"OptimusClipTests\",\n            dependencies: [\n                // Tests only depend on Core, not the executable\n                // This makes tests fast and isolated\n                \"OptimusClipCore\"\n            ],\n            path: \"Tests/OptimusClipTests\",\n            \n            // Swift 6 concurrency checking\n            swiftSettings: [\n                .enableUpcomingFeature(\"StrictConcurrency\"),\n                .enableExperimentalFeature(\"AccessLevelOnImport\")\n            ]\n        )\n    ]\n)\n```\n\n**Key configuration details:**\n\n1. **Swift Tools Version (`6.0`):**\n   - Controls which SPM features are available\n   - Enables Swift 6 language features\n   - Sets minimum Swift compiler version\n\n2. **Platform Specification (`.macOS(.v15)`):**\n   - Enforces macOS 15+ at compile time\n   - Prevents use of deprecated APIs\n   - Matches Info.plist LSMinimumSystemVersion\n\n3. **Product Definition:**\n   - `.executable` creates a runnable binary\n   - Name must match target name\n   - Produces `.build/debug/OptimusClip` or `.build/release/OptimusClip`\n\n4. **Dependency Version Strategies:**\n   - `from: \"2.0.0\"`: Accept 2.0.0 up to (but not including) 3.0.0\n   - Semantic versioning: Patch/minor updates auto-accepted\n   - Major version changes require manual update\n   - SPM resolves dependencies with `swift package resolve`\n   - Lockfile (`Package.resolved`) pins exact versions\n\n5. **Target Types:**\n   - `.executableTarget`: Has `@main`, produces binary\n   - `.target`: Library, produces .swiftmodule\n   - `.testTarget`: Contains XCTest tests\n\n6. **Swift Settings:**\n   - `StrictConcurrency`: Enforces actor isolation and Sendable conformance\n   - `AccessLevelOnImport`: Allows fine-grained import control\n\n### ARCHITECTURAL CONNECTIONS\n\n**Dependency Graph:**\n```\nOptimusClipTests\n    └─\u003e OptimusClipCore\n\nOptimusClip (executable)\n    ├─\u003e OptimusClipCore\n    ├─\u003e KeyboardShortcuts\n    └─\u003e MenuBarExtraAccess\n```\n\n**How it connects to other Phase 0 components:**\n- **Info.plist**: CFBundleExecutable must match product name (\"OptimusClip\")\n- **package.json**: `swift build` command compiles all targets\n- **Scripts/package_app.sh**: Reads binary from `.build/debug/OptimusClip` or `.build/release/OptimusClip`\n- **CI Pipeline**: Runs `swift build` and `swift test` based on this manifest\n- **CLAUDE.md**: Documents the target structure and dependencies\n\n**File System Layout (created automatically by SPM):**\n```\noptimus-clip/\n├── Package.swift              # This file\n├── Package.resolved           # Dependency lockfile (auto-generated)\n├── .build/                    # Build artifacts (gitignored)\n│   ├── debug/\n│   │   ├── OptimusClip        # Debug executable\n│   │   └── *.swiftmodule      # Compiled modules\n│   └── release/\n│       └── OptimusClip        # Release executable\n├── Sources/\n│   ├── OptimusClip/           # Executable target sources\n│   │   └── OptimusClipApp.swift\n│   └── OptimusClipCore/       # Library target sources\n│       └── Transformation.swift\n└── Tests/\n    └── OptimusClipTests/      # Test target sources\n        └── TransformationTests.swift\n```\n\n### EDGE CASES \u0026 GOTCHAS\n\n**1. Dependency Resolution Failures:**\n- **Issue**: `swift package resolve` fails with conflicting version requirements\n- **Solution**: Check Package.resolved for pinned versions, delete it to re-resolve\n- **Prevention**: Use `from:` instead of exact versions for flexibility\n\n**2. Xcode Cache Corruption:**\n- **Symptom**: Xcode shows \"Missing package product\" even after successful SPM resolve\n- **Solution**: `rm -rf ~/Library/Developer/Xcode/DerivedData/*`\n- **Root cause**: Xcode caches SPM artifacts aggressively\n\n**3. Test Target Can't Import Core:**\n- **Symptom**: `import OptimusClipCore` fails in test files\n- **Cause**: Test target missing dependency declaration\n- **Solution**: Ensure `.testTarget(dependencies: [\"OptimusClipCore\"])`\n\n**4. Executable Target Name Mismatch:**\n- **Issue**: Binary is named differently than Info.plist CFBundleExecutable\n- **Result**: App bundle won't launch (macOS can't find executable)\n- **Solution**: Keep names synchronized across Package.swift, Info.plist, package_app.sh\n\n**5. Swift Version Mismatch:**\n- **Issue**: Developer has Swift 5.9 but Package.swift requires 6.0\n- **Error**: \"error: package requires minimum Swift tools version 6.0\"\n- **Solution**: Update Xcode to latest version (includes Swift 6+)\n\n**6. Path Attribute Ignored:**\n- **Note**: If `path:` is specified, SPM only looks in that directory\n- **Gotcha**: Adding files outside the path won't be included\n- **Best practice**: Stick to convention (Sources/{TargetName}/)\n\n**7. Dependency URL Typos:**\n- **Issue**: Wrong GitHub URL for dependency\n- **Error**: \"error: failed to clone repository\"\n- **Solution**: Copy-paste URLs from official package repos\n\n**8. Product Name Conflicts:**\n- **Issue**: Multiple packages define same product name\n- **Solution**: Use `.product(name: \"...\", package: \"...\")` to disambiguate\n\n### TESTING REQUIREMENTS\n\n**Phase 0 Verification:**\n1. Run `swift build` - should succeed without errors\n2. Check `.build/debug/OptimusClip` exists and is executable\n3. Run `swift test` - should run (even if no tests yet)\n4. Run `swift package dump-package` - should output valid JSON\n5. Run `swift package show-dependencies` - should list KeyboardShortcuts and MenuBarExtraAccess\n\n**Continuous Validation:**\n1. After adding new source files, verify `swift build` still works\n2. After updating dependencies, verify `swift package resolve` succeeds\n3. After changing target structure, verify tests still find imports\n4. In CI, verify builds work on clean environment (no cached dependencies)\n\n**Test Commands:**\n```bash\n# Validate manifest syntax\nswift package dump-package \u003e /dev/null\n\n# Show dependency tree\nswift package show-dependencies\n\n# Resolve dependencies (updates Package.resolved)\nswift package resolve\n\n# Build all targets\nswift build\n\n# Build release configuration\nswift build -c release\n\n# Run tests\nswift test\n\n# Clean build artifacts\nswift package clean\n\n# Reset dependencies (delete Package.resolved and .build)\nswift package reset\n```\n\n### SUCCESS CRITERIA\n\n- [ ] Package.swift file created at repository root\n- [ ] Swift tools version set to 6.0\n- [ ] Platform requirement set to macOS 15+\n- [ ] OptimusClip executable product defined\n- [ ] KeyboardShortcuts dependency added with version constraint\n- [ ] MenuBarExtraAccess dependency added with version constraint\n- [ ] OptimusClip executable target defined with correct dependencies\n- [ ] OptimusClipCore library target defined\n- [ ] OptimusClipTests test target defined with OptimusClipCore dependency\n- [ ] Swift 6 concurrency settings enabled for all targets\n- [ ] `swift build` succeeds without errors\n- [ ] `swift test` runs successfully (even with placeholder test)\n- [ ] `swift package dump-package` outputs valid JSON\n- [ ] Binary created at `.build/debug/OptimusClip`\n- [ ] Package.resolved generated with locked dependency versions\n\n### CONFIGURATION OPTIONS\n\n**Dependency Version Strategies:**\n- `from: \"2.0.0\"` - Semantic versioning (recommended)\n- `\"2.0.0\"...\"3.0.0\"` - Explicit range\n- `.exact(\"2.0.0\")` - Pin to exact version (avoid unless necessary)\n- `.branch(\"main\")` - Use latest from branch (development only)\n- `.revision(\"abc123\")` - Pin to specific commit (for unreleased fixes)\n\n**Swift Settings Options:**\n```swift\nswiftSettings: [\n    // Enable upcoming Swift features early\n    .enableUpcomingFeature(\"StrictConcurrency\"),\n    .enableUpcomingFeature(\"BareSlashRegexLiterals\"),\n    \n    // Experimental features (may change)\n    .enableExperimentalFeature(\"AccessLevelOnImport\"),\n    \n    // Compiler flags\n    .unsafeFlags([\"-warnings-as-errors\"], .when(configuration: .release)),\n    \n    // Preprocessor defines\n    .define(\"DEBUG\", .when(configuration: .debug))\n]\n```\n\n**Build Configuration Conditional Compilation:**\n```swift\n#if DEBUG\n    // Debug-only code\n#else\n    // Release code\n#endif\n```\n\n### SECURITY CONSIDERATIONS\n\n**Dependency Trust:**\n- All dependencies from reputable sources (sindresorhus has 1M+ GitHub followers)\n- Review Package.resolved for unexpected version changes\n- Consider vendoring critical dependencies for supply chain security\n- SPM fetches dependencies over HTTPS (secure by default)\n\n**No Secrets in Package.swift:**\n- This file is committed to git\n- Never embed API keys or credentials\n- Use environment variables for sensitive build-time configuration\n\n**Code Signing Compatibility:**\n- SPM-built binaries are compatible with codesigning\n- Binary at `.build/release/OptimusClip` can be signed directly\n- No special flags needed for hardened runtime\n\n### PERFORMANCE CONSIDERATIONS\n\n**Build Performance:**\n- **Incremental builds**: SPM only recompiles changed modules\n- **Parallel compilation**: Uses all CPU cores by default\n- **Build cache**: `.build/` directory caches compiled modules\n- **Clean builds**: `swift package clean` forces full rebuild\n\n**Dependency Resolution:**\n- First resolution is slow (clones all dependencies)\n- Subsequent builds use cached dependencies\n- Package.resolved prevents repeated network calls\n- Consider committing Package.resolved for reproducible builds\n\n**Target Granularity:**\n- Fewer targets = faster builds (less overhead)\n- More targets = better incremental compilation (smaller rebuild units)\n- Current structure (3 targets) is optimal balance\n\n**Expected Build Times (M1 Mac):**\n- Clean build: ~30-45 seconds (includes dependency fetching)\n- Incremental build (change one file): ~2-5 seconds\n- Test run (placeholder test): ~1-2 seconds\n\n### IMPLEMENTATION ORDER\n\n1. Create Package.swift at repository root\n2. Set swift-tools-version to 6.0\n3. Define package name (\"OptimusClip\")\n4. Set platform requirement (.macOS(.v15))\n5. Add KeyboardShortcuts dependency\n6. Add MenuBarExtraAccess dependency\n7. Define OptimusClip executable product\n8. Define OptimusClip executable target with dependencies\n9. Define OptimusClipCore library target\n10. Define OptimusClipTests test target\n11. Add Swift 6 concurrency settings to all targets\n12. Verify with `swift build`\n13. Verify with `swift package dump-package`\n\n### COMMON COMMANDS REFERENCE\n\n```bash\n# Build (debug)\nswift build\n\n# Build (release, optimized)\nswift build -c release\n\n# Run tests\nswift test\n\n# Run tests with filter\nswift test --filter TransformationTests\n\n# Run tests in parallel\nswift test --parallel\n\n# Show build products\nswift build --show-bin-path\n\n# Update dependencies to latest allowed versions\nswift package update\n\n# Resolve dependencies (create Package.resolved)\nswift package resolve\n\n# Show dependency tree\nswift package show-dependencies\n\n# Validate Package.swift syntax\nswift package dump-package\n\n# Generate Xcode project (optional, for Xcode users)\nswift package generate-xcodeproj\n\n# Clean build artifacts\nswift package clean\n\n# Reset everything (clean + delete Package.resolved)\nswift package reset\n```\n\n### ADDITIONAL NOTES\n\n- **Xcode Integration**: Opening Package.swift in Xcode automatically creates a workspace\n- **CLI Workflow**: Can develop entirely in terminal with swift commands + any editor\n- **CI Compatibility**: GitHub Actions, CircleCI, etc. all support Swift Package Manager\n- **Future Extensions**: Easy to add new targets (CLI tool, browser extension, etc.)\n- **Documentation**: Run `swift package generate-documentation` (requires DocC)\n\n**File Location:** `/Users/chrisedwards/projects/oss/optimus-clip/Package.swift`\n\n**Estimated Time:** 20-30 minutes (mostly copy-paste and verification)\n\n**Priority:** P0 - This file must exist before any code can be written or built","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:05:53.250902-05:00","updated_at":"2025-12-13T00:16:50.443526-05:00","closed_at":"2025-12-13T00:16:50.443526-05:00","dependencies":[{"issue_id":"oc-9g6.3","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:05:53.251414-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.3","depends_on_id":"oc-9g6.1","type":"blocks","created_at":"2025-12-12T23:53:55.000326-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.4","title":"Build Scripts","description":"## Task: Build Scripts\n\n### Background \u0026 Context\nSwift Package Manager (SPM) is designed for libraries and command-line tools, not macOS app bundles. When you run `swift build`, you get a bare executable - no `.app` bundle, no Info.plist, no icon, no proper macOS integration. Our build scripts bridge this gap.\n\n### Why We Need Custom Scripts\n\n**The Problem:**\n- SPM produces: `.build/debug/OptimusClip` (bare executable)\n- macOS expects: `OptimusClip.app/Contents/MacOS/OptimusClip` + Info.plist + Resources\n\n**Without proper .app bundle:**\n- No menu bar icon (Info.plist defines LSUIElement)\n- No version info (About dialog is empty)\n- No Dock suppression (app appears in Dock)\n- Can't code sign or notarize (Gatekeeper rejects)\n- Launch Services doesn't recognize it\n\n### The Three Scripts\n\n#### 1. compile_and_run.sh - Development Workflow\n\n**Purpose:** One command to build and run during development\n\n**Flow:**\n```\nkill existing → swift build → package .app → launch → verify running\n```\n\n**Implementation:**\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\nROOT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\" \u0026\u0026 pwd)\"\n\n# 1. Stop any running instances\n\"${ROOT_DIR}/Scripts/kill_optimusclip.sh\" || true\n\n# 2. Build (debug, fast)\nswift build\n\n# 3. Create minimal .app bundle\n\"${ROOT_DIR}/Scripts/package_app.sh\" debug\n\n# 4. Launch\nopen \"${ROOT_DIR}/OptimusClip.app\"\n\n# 5. Verify it's running (wait up to 5 seconds)\nfor i in {1..10}; do\n    if pgrep -x \"OptimusClip\" \u003e /dev/null; then\n        echo \"✓ OptimusClip running\"\n        exit 0\n    fi\n    sleep 0.5\ndone\necho \"⚠ OptimusClip may not have started\"\n```\n\n**Why kill first?** macOS caches running apps. If you don't kill the old instance, `open` may just bring the old version to front instead of launching the new build.\n\n#### 2. package_app.sh - Bundle Creation\n\n**Purpose:** Create proper .app bundle structure with versioning\n\n**Accepts:** `debug` or `release` argument\n\n**Flow:**\n```\nsource version.env → swift build → create structure → copy binary → inject Info.plist → copy resources\n```\n\n**Implementation:**\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\nMODE=\"${1:-debug}\"\nROOT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\" \u0026\u0026 pwd)\"\n\n# Source version info\nsource \"${ROOT_DIR}/version.env\"\n\nAPP_NAME=\"OptimusClip\"\nAPP_BUNDLE=\"${ROOT_DIR}/${APP_NAME}.app\"\nCONTENTS=\"${APP_BUNDLE}/Contents\"\nMACOS=\"${CONTENTS}/MacOS\"\nRESOURCES=\"${CONTENTS}/Resources\"\n\n# Build\nif [[ \"$MODE\" == \"release\" ]]; then\n    swift build -c release\n    BINARY=\"${ROOT_DIR}/.build/release/${APP_NAME}\"\nelse\n    swift build\n    BINARY=\"${ROOT_DIR}/.build/debug/${APP_NAME}\"\nfi\n\n# Create bundle structure\nrm -rf \"${APP_BUNDLE}\"\nmkdir -p \"${MACOS}\" \"${RESOURCES}\"\n\n# Copy binary\ncp \"${BINARY}\" \"${MACOS}/${APP_NAME}\"\n\n# Generate Info.plist with version substitution\nsed -e \"s/\\$(MARKETING_VERSION)/${MARKETING_VERSION}/g\" \\\n    -e \"s/\\$(BUILD_NUMBER)/${BUILD_NUMBER}/g\" \\\n    \"${ROOT_DIR}/Info.plist\" \u003e \"${CONTENTS}/Info.plist\"\n\n# Copy icon if exists\n[[ -f \"${ROOT_DIR}/Icon.icns\" ]] \u0026\u0026 cp \"${ROOT_DIR}/Icon.icns\" \"${RESOURCES}/AppIcon.icns\"\n\necho \"✓ Packaged ${APP_BUNDLE} (${MODE}, v${MARKETING_VERSION} build ${BUILD_NUMBER})\"\n```\n\n**Why sed substitution?** Info.plist is a template with `$(MARKETING_VERSION)` placeholders. This allows version.env to be the single source of truth.\n\n#### 3. kill_optimusclip.sh - Cleanup Utility\n\n**Purpose:** Reliably stop all running instances\n\n**Implementation:**\n```bash\n#!/usr/bin/env bash\n# Kill all OptimusClip processes\n\npkill -x \"OptimusClip\" 2\u003e/dev/null || true\nsleep 0.2\n\n# Verify killed\nif pgrep -x \"OptimusClip\" \u003e /dev/null; then\n    echo \"⚠ OptimusClip still running, using SIGKILL\"\n    pkill -9 -x \"OptimusClip\" 2\u003e/dev/null || true\nfi\n\necho \"✓ OptimusClip stopped\"\n```\n\n**Why `-x` flag?** Exact match only. Without it, `pkill OptimusClip` could kill `OptimusClipHelper` or other similarly-named processes.\n\n### Bundle Structure Reference\n\n```\nOptimusClip.app/\n├── Contents/\n│   ├── Info.plist          ← Generated from template + version.env\n│   ├── MacOS/\n│   │   └── OptimusClip     ← Executable from .build/\n│   └── Resources/\n│       └── AppIcon.icns    ← Optional app icon\n```\n\n### Architectural Decisions\n\n**Why shell scripts vs Makefile?**\n- Shell is more portable (no make dependency)\n- Easier to debug (bash -x)\n- Simpler for small projects\n- npm scripts provide the interface anyway (`pnpm start`)\n\n**Why not Xcode project?**\n- SPM is simpler and more portable\n- No .xcodeproj to maintain\n- Easier for contributors (just `swift build`)\n- CI doesn't need Xcode (can use swift CLI)\n\n**Why version.env vs xcconfig?**\n- xcconfig requires Xcode project\n- Shell sourcing is universal\n- Easy to edit with sed/awk\n- Git diff shows changes clearly\n\n### Edge Cases \u0026 Gotchas\n\n1. **Executable permissions** - Binary from `.build/` already has +x, but if copying fails, check permissions\n2. **Quarantine attribute** - macOS may add quarantine to downloaded scripts; use `xattr -c` to clear\n3. **Case sensitivity** - App name must match exactly: `OptimusClip` not `optimusclip`\n4. **Binary path** - Debug goes to `.build/debug/`, release to `.build/release/`\n5. **Clean builds** - If weird issues, `rm -rf .build` and rebuild\n\n### Acceptance Criteria\n- [ ] All three scripts exist in Scripts/ directory\n- [ ] Scripts are executable (`chmod +x`)\n- [ ] `./Scripts/compile_and_run.sh` builds and launches app\n- [ ] `./Scripts/package_app.sh release` creates release bundle\n- [ ] Version info appears correctly in packaged app\n- [ ] `pnpm start` invokes compile_and_run.sh successfully","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:05:53.763178-05:00","updated_at":"2025-12-13T00:17:52.000407-05:00","closed_at":"2025-12-13T00:17:52.000407-05:00","dependencies":[{"issue_id":"oc-9g6.4","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:05:53.763695-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.4","depends_on_id":"oc-9g6.3","type":"blocks","created_at":"2025-12-12T23:53:55.466422-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.5","title":"Linting \u0026 Formatting Config","description":"BACKGROUND \u0026 CONTEXT:\nCode quality tooling is the foundation of any maintainable Swift project. This task establishes automated style enforcement and static analysis for Optimus Clip BEFORE any feature code is written. By configuring SwiftFormat and SwiftLint early, we ensure:\n\n1. **Consistent Style:** All code follows the same formatting rules (indentation, line length, spacing)\n2. **Swift 6 Compatibility:** Explicit self requirements for actor isolation and concurrency safety\n3. **Early Error Detection:** Catch anti-patterns, unused code, and complexity issues before code review\n4. **Zero Style Debates:** Tools enforce rules automatically, eliminating bikeshedding\n\nSwiftFormat and SwiftLint serve complementary roles:\n- **SwiftFormat:** Auto-fixes style (indent, spacing, brackets, ordering) - \"the formatter\"\n- **SwiftLint:** Detects code smells and complexity (force unwrap, long functions, cyclomatic complexity) - \"the linter\"\n\nThis project uses Swift 6 with strict concurrency checking, which requires explicit `self.` in closures and async contexts. SwiftFormat's `--self insert` rule ensures compliance.\n\nREAL-WORLD PROBLEM/USE CASE:\nDeveloper workflow scenario:\n\n1. **Before tooling exists:**\n   - Developer writes feature code with inconsistent indentation (2 spaces vs 4 spaces)\n   - Uses force unwrapping (`apiKey!`) in production code\n   - Writes 80-line function with nested conditionals\n   - Commits code\n   - CI fails with cryptic Swift 6 errors about missing `self`\n   - Code review derailed by style nitpicks\n   - Developer spends 30 minutes manually fixing formatting\n\n2. **After tooling configured:**\n   - Developer writes feature code with any style\n   - Runs `pnpm check` before commit\n   - SwiftFormat auto-fixes indentation, adds explicit `self.`, wraps long lines\n   - SwiftLint warns about force unwrap and long function\n   - Developer refactors problematic code\n   - Commits pass CI on first try\n   - Code review focuses on logic, not style\n   - Total time: 5 minutes\n\nWithout this task:\n- Every commit becomes a style battleground\n- Swift 6 concurrency errors appear late in development\n- Code reviews waste time on formatting debates\n- CI passes inconsistent code quality\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n**1. .swiftformat Configuration:**\nCreate `.swiftformat` at repository root:\n\n```\n# SwiftFormat Configuration - OptimusClip\n# Version: 0.55.0+\n# Swift Version: 6.0\n\n--swiftversion 6.0\n\n# Indentation\n--indent 4\n--tabwidth 4\n--maxwidth 120\n--wraparguments before-first\n--wrapcollections before-first\n\n# Self (REQUIRED for Swift 6 concurrency)\n--self insert\n--selfrequired self, memberself\n\n# Spacing\n--trimwhitespace always\n--insertblanklines enabled\n--removeblanklines enabled\n\n# Ordering\n--importgrouping testable-bottom\n--extensionacl on-declarations\n\n# Control Flow\n--elseposition same-line\n--guardelse same-line\n\n# Braces\n--allman false\n--stripunusedargs always\n\n# Comments\n--header strip\n\n# Disabled rules (if any)\n# --disable redundantSelf\n```\n\nKey rules explained:\n- `--self insert`: Adds `self.` everywhere (Swift 6 actor isolation requirement)\n- `--indent 4`: Standard Swift style (not 2-space like some web projects)\n- `--maxwidth 120`: Balances readability with modern screen widths\n- `--wraparguments before-first`: Consistent multi-line function calls\n- `--importgrouping testable-bottom`: Clean import organization\n\n**2. .swiftlint.yml Configuration:**\nCreate `.swiftlint.yml` at repository root:\n\n```yaml\n# SwiftLint Configuration - OptimusClip\n# Version: 0.55.0+\n\ndisabled_rules:\n  - trailing_whitespace  # SwiftFormat handles this\n  - todo                 # We use bd (beads) for task tracking\n  - identifier_name      # Allow short names in closures\n\nopt_in_rules:\n  # Analyzer rules (require compilation)\n  - unused_declaration\n  - unused_import\n  \n  # Code quality\n  - explicit_init\n  - explicit_self\n  - fatal_error_message\n  - first_where\n  - force_unwrapping  # Catch force unwraps\n  - implicitly_unwrapped_optional\n  - multiline_parameters\n  - overridden_super_call\n  - private_outlet\n  - redundant_nil_coalescing\n  - sorted_first_last\n  - unneeded_parentheses_in_closure_argument\n  - yoda_condition\n\nanalyzer_rules:\n  - unused_declaration\n  - unused_import\n\nincluded:\n  - Sources\n  - Tests\n\nexcluded:\n  - .build\n  - .swiftpm\n  - Scripts\n\n# Rule Customization\nline_length:\n  warning: 120\n  error: 150\n  ignores_comments: true\n  ignores_urls: true\n\nfile_length:\n  warning: 500\n  error: 1500\n\nfunction_body_length:\n  warning: 40\n  error: 100\n\ntype_body_length:\n  warning: 300\n  error: 500\n\ncyclomatic_complexity:\n  warning: 10\n  error: 20\n\nforce_cast:\n  severity: warning  # Allow in tests, warn in production\n\nforce_try:\n  severity: warning  # Discourage but not block\n\nforce_unwrapping:\n  severity: error    # Strict: use guard let or if let\n\nidentifier_name:\n  min_length:\n    warning: 2\n    error: 1\n  max_length:\n    warning: 50\n    error: 100\n  excluded:\n    - i\n    - id\n    - x\n    - y\n    - v  # Common in SwiftUI\n\nreporter: \"xcode\"  # IDE-friendly output format\n```\n\nKey rules explained:\n- `unused_declaration`: Catches dead code early (requires compilation)\n- `force_unwrapping: error`: Prevents crashes from `value!`\n- `function_body_length: 40`: Encourages small, testable functions\n- `cyclomatic_complexity: 10`: Limits nested conditionals\n\n**3. Integration with package.json:**\nThese configs enable the following npm scripts (defined in oc-9g6.7):\n\n```bash\n# Auto-fix formatting\npnpm format\n\n# Check formatting without changing files\npnpm check\n\n# CI mode (fails on violations)\npnpm lint\n```\n\n**4. Installation Commands:**\n```bash\n# Install tools (one-time setup)\nbrew install swiftformat swiftlint\n\n# Verify installation\nswiftformat --version  # Should be 0.55.0+\nswiftlint version      # Should be 0.55.0+\n```\n\nARCHITECTURAL CONNECTIONS:\n- **CI Pipeline (.github/workflows/ci.yml):** Enforces rules on every push\n- **package.json (oc-9g6.7):** Provides developer-friendly commands\n- **Pre-commit Hooks (future):** Auto-format before commit\n- **Claude Code Integration:** CLAUDE.md references these rules for AI-generated code\n- **All Swift Code:** Every file in Sources/ and Tests/ passes these checks\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. **SWIFT 6 CONCURRENCY BREAKING CHANGES:**\n   - Without `--self insert`, code won't compile in Swift 6 strict mode\n   - Adding explicit self retroactively is tedious (100+ files)\n   - **Solution:** Configure this BEFORE writing actor/async code\n\n2. **SWIFTFORMAT VS SWIFTLINT CONFLICTS:**\n   - SwiftFormat adds trailing commas, SwiftLint might warn\n   - **Solution:** Disable `trailing_comma` in SwiftLint (already in config)\n\n3. **ANALYZER RULES REQUIRE COMPILATION:**\n   - `unused_declaration` and `unused_import` won't run with `swiftlint lint`\n   - Need `swiftlint analyze --compiler-log-path .build/debug.log`\n   - **Solution:** CI runs `swift build` before `swiftlint analyze`\n\n4. **VERSION MISMATCHES:**\n   - SwiftFormat 0.50 vs 0.55 have different rule names\n   - **Solution:** Document minimum versions in CLAUDE.md\n\n5. **FORCE UNWRAP IN TESTS:**\n   - Tests often use `try!` and `value!` legitimately\n   - **Solution:** SwiftLint allows force_cast/force_try as warnings, not errors\n\n6. **LONG LINES IN STRINGS:**\n   - Error messages and URLs exceed 120 characters\n   - **Solution:** Use `ignores_urls: true` and multi-line strings\n\n7. **XCODE INTEGRATION:**\n   - Xcode doesn't auto-run these tools on save\n   - **Solution:** Run `pnpm format` manually or use Xcode build phase\n\nTESTING REQUIREMENTS:\nManual verification after creating configs:\n\n1. **Format Check Passes:**\n   ```bash\n   swiftformat . --lint\n   # Should show \"0 files would have been formatted\"\n   ```\n\n2. **Lint Check Passes:**\n   ```bash\n   swiftlint lint\n   # Should show \"Done linting! Found 0 violations\"\n   ```\n\n3. **Analyzer Rules Work:**\n   ```bash\n   swift build\n   swiftlint analyze --compiler-log-path .build/debug.log\n   # Should detect unused imports/declarations\n   ```\n\n4. **Auto-Fix Works:**\n   ```bash\n   # Create intentionally bad file\n   echo \"func  badFormat( x:Int){return x}\" \u003e Sources/OptimusClip/Test.swift\n   \n   # Format it\n   swiftformat Sources/OptimusClip/Test.swift\n   \n   # Should be fixed to:\n   # func badFormat(x: Int) { return x }\n   ```\n\n5. **CI Integration:**\n   ```bash\n   # Simulate CI\n   swiftformat . --lint \u0026\u0026 swiftlint lint --strict\n   # Exit code 0 = pass, non-zero = fail\n   ```\n\nSUCCESS CRITERIA:\n- [ ] `.swiftformat` exists at repo root with all required rules\n- [ ] `.swiftlint.yml` exists at repo root with analyzer rules enabled\n- [ ] `swiftformat --version` \u003e= 0.55.0\n- [ ] `swiftlint version` \u003e= 0.55.0\n- [ ] `swiftformat . --lint` passes with 0 violations\n- [ ] `swiftlint lint` passes with 0 violations\n- [ ] `--self insert` rule confirmed (adds explicit self)\n- [ ] `force_unwrapping: error` rule confirmed (blocks force unwraps)\n- [ ] CLAUDE.md documents these tools and commands\n- [ ] CI workflow uses these configs (verified in oc-9g6)\n\nCONFIGURATION OPTIONS:\n- Line length: 120 (can adjust to 100 or 140)\n- Indent: 4 spaces (Swift standard, not negotiable)\n- Max function length: 40 lines warning, 100 error\n- Force unwrap severity: error (can downgrade to warning for tests)\n\nPERFORMANCE CONSIDERATIONS:\n- SwiftFormat scans all files in ~2 seconds for this small project\n- SwiftLint without analyzer: ~1 second\n- SwiftLint with analyzer: ~5 seconds (requires compilation)\n- Cache `.build` folder in CI to speed up analyzer rules\n\nSECURITY CONSIDERATIONS:\n- Linting rules don't directly impact security\n- `force_unwrapping: error` prevents potential crashes (defensive programming)\n- No credential exposure risks from these tools\n\nIMPLEMENTATION ORDER:\n1. Create `.swiftformat` with Swift 6 rules\n2. Create `.swiftlint.yml` with analyzer rules\n3. Install tools locally: `brew install swiftformat swiftlint`\n4. Run `swiftformat .` to format existing placeholder files\n5. Run `swiftlint lint` to verify no violations\n6. Commit both config files\n7. Update CLAUDE.md with tool usage instructions\n8. Verify CI integration (done in oc-9g6)\n\nCODE ORGANIZATION:\n.swiftformat                    # SwiftFormat config\n.swiftlint.yml                  # SwiftLint config\nCLAUDE.md                       # Documents usage\n.github/workflows/ci.yml        # Enforces rules\npackage.json                    # Provides pnpm commands\n\nPRIORITY: P0 (Foundational - blocks all code quality work)\n\nESTIMATED TIME: 20-30 minutes (config creation + verification)\n\nCOMMON PITFALLS:\n| Issue | Solution |\n|-------|----------|\n| Swift 6 compile errors | Add `--self insert` to .swiftformat |\n| Analyzer rules don't run | Use `swiftlint analyze` not `swiftlint lint` |\n| Xcode and CLI format differently | Ensure Xcode uses same SwiftFormat version |\n| Rules conflict with each other | Disable conflicting SwiftLint rules |\n| CI slower than local | Cache .build folder in GitHub Actions |\n\nDEPENDENCIES:\nBefore starting:\n- Homebrew installed\n- Swift 6 toolchain installed\n- Repository structure exists (Sources/, Tests/)\n\nAfter completion:\n- Enables oc-9g6.7 (package.json scripts reference these tools)\n- Enables all Phase 1+ development (code quality enforced)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:05:54.287452-05:00","updated_at":"2025-12-13T00:18:35.625657-05:00","closed_at":"2025-12-13T00:18:35.625657-05:00","dependencies":[{"issue_id":"oc-9g6.5","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:05:54.287962-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.5","depends_on_id":"oc-9g6.1","type":"blocks","created_at":"2025-12-12T23:53:55.856362-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.6","title":"Info.plist Template","description":"BACKGROUND \u0026 CONTEXT:\nInfo.plist is the application configuration manifest that defines how macOS treats your app. It's the source of truth for:\n\n1. **Bundle Identity:** Unique identifier (com.yourname.optimusclip)\n2. **Versioning:** Marketing version (1.0.0) and build number (1, 2, 3...)\n3. **App Behavior:** Menu bar only? Allow multiple instances? Minimum OS version?\n4. **Permissions:** Future Accessibility and Keychain entitlements\n5. **Sparkle Integration:** Auto-update feed URL and signing keys (Phase 7)\n\nFor Optimus Clip, the most critical keys are:\n- **LSUIElement=true:** Makes app menu-bar-only (no Dock icon, no Cmd+Tab entry)\n- **LSMultipleInstancesProhibited=true:** Prevents duplicate instances competing for hotkeys\n- **LSMinimumSystemVersion=15.0:** Enforces macOS 15+ (required for Swift 6 features)\n\nThis is a **TEMPLATE** file with placeholders like `$(MARKETING_VERSION)` and `$(BUILD_NUMBER)`. The `Scripts/package_app.sh` script (created in oc-9g6) reads `version.env` and substitutes real values at build time using `sed`.\n\nWhy templates?\n- **Single Source of Truth:** `version.env` defines version, not multiple files\n- **Prevents Drift:** Can't accidentally commit mismatched versions\n- **Automation-Friendly:** CI can bump build numbers without editing XML\n\nREAL-WORLD PROBLEM/USE CASE:\nScenario: Developer preparing first release\n\n**WITHOUT Info.plist template:**\n1. Developer hardcodes version in Info.plist: `\u003cstring\u003e0.1.0\u003c/string\u003e`\n2. Developer hardcodes build number: `\u003cstring\u003e1\u003c/string\u003e`\n3. Builds app, releases to users\n4. Fixes bug, wants to release 0.1.1\n5. Must manually edit Info.plist in two places\n6. Forgets to increment build number\n7. Sparkle auto-update breaks (compares build numbers, not versions)\n8. Users don't get update\n9. Developer spends 2 hours debugging Sparkle configuration\n10. Realizes build number didn't increase\n\n**WITH Info.plist template:**\n1. Developer edits `version.env`: `MARKETING_VERSION=\"0.1.1\"` and `BUILD_NUMBER=\"2\"`\n2. Runs `pnpm package:release`\n3. Script substitutes values into Info.plist\n4. App bundle has correct version and build number\n5. Sparkle update works correctly\n6. Total time: 30 seconds\n\n**Menu Bar App Behavior:**\nWithout `LSUIElement=true`:\n- App appears in Dock (wastes space)\n- App appears in Cmd+Tab switcher (confusing)\n- User expects window-based app, but there is no window\n- User tries to click Dock icon, nothing happens\n- User thinks app is broken\n\nWith `LSUIElement=true`:\n- App only appears in Menu Bar (expected behavior)\n- No Dock icon clutter\n- No Cmd+Tab confusion\n- Professional menu bar app UX\n\n**Multiple Instance Prevention:**\nWithout `LSMultipleInstancesProhibited=true`:\n- User launches app twice (accidentally or via Login Items + manual launch)\n- Two instances compete for global hotkeys\n- First instance registers Cmd+Option+V\n- Second instance fails to register (or steals it)\n- Clipboard transformations randomly fail\n- User files bug report: \"Hotkeys stop working randomly\"\n\nWith `LSMultipleInstancesProhibited=true`:\n- macOS prevents second instance from launching\n- User sees brief flash (second instance exits immediately)\n- No hotkey conflicts\n- Reliable behavior\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n**1. Info.plist Template Structure:**\nCreate `Info.plist` at repository root:\n\n```xml\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003c!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e\n\u003cplist version=\"1.0\"\u003e\n\u003cdict\u003e\n    \u003c!-- ========================================\n         BUNDLE IDENTITY\n         ======================================== --\u003e\n    \n    \u003ckey\u003eCFBundleIdentifier\u003c/key\u003e\n    \u003cstring\u003ecom.yourname.optimusclip\u003c/string\u003e\n    \n    \u003ckey\u003eCFBundleName\u003c/key\u003e\n    \u003cstring\u003eOptimusClip\u003c/string\u003e\n    \n    \u003ckey\u003eCFBundleDisplayName\u003c/key\u003e\n    \u003cstring\u003eOptimus Clip\u003c/string\u003e\n    \n    \u003ckey\u003eCFBundleExecutable\u003c/key\u003e\n    \u003cstring\u003eOptimusClip\u003c/string\u003e\n    \n    \u003ckey\u003eCFBundlePackageType\u003c/key\u003e\n    \u003cstring\u003eAPPL\u003c/string\u003e\n    \n    \u003c!-- ========================================\n         VERSIONING (Populated by package_app.sh)\n         ======================================== --\u003e\n    \n    \u003ckey\u003eCFBundleShortVersionString\u003c/key\u003e\n    \u003cstring\u003e$(MARKETING_VERSION)\u003c/string\u003e\n    \n    \u003ckey\u003eCFBundleVersion\u003c/key\u003e\n    \u003cstring\u003e$(BUILD_NUMBER)\u003c/string\u003e\n    \n    \u003c!-- ========================================\n         MENU BAR APP CONFIGURATION\n         ======================================== --\u003e\n    \n    \u003c!-- Hide from Dock and Cmd+Tab --\u003e\n    \u003ckey\u003eLSUIElement\u003c/key\u003e\n    \u003ctrue/\u003e\n    \n    \u003c!-- Prevent multiple instances --\u003e\n    \u003ckey\u003eLSMultipleInstancesProhibited\u003c/key\u003e\n    \u003ctrue/\u003e\n    \n    \u003c!-- Require macOS 15.0+ (Swift 6) --\u003e\n    \u003ckey\u003eLSMinimumSystemVersion\u003c/key\u003e\n    \u003cstring\u003e15.0\u003c/string\u003e\n    \n    \u003c!-- ========================================\n         APP METADATA\n         ======================================== --\u003e\n    \n    \u003ckey\u003eLSApplicationCategoryType\u003c/key\u003e\n    \u003cstring\u003epublic.app-category.productivity\u003c/string\u003e\n    \n    \u003ckey\u003eNSHumanReadableCopyright\u003c/key\u003e\n    \u003cstring\u003eCopyright © 2025. All rights reserved.\u003c/string\u003e\n    \n    \u003c!-- ========================================\n         ICON (Optional - added when Icon.icns exists)\n         ======================================== --\u003e\n    \n    \u003c!-- \u003ckey\u003eCFBundleIconFile\u003c/key\u003e --\u003e\n    \u003c!-- \u003cstring\u003eAppIcon\u003c/string\u003e --\u003e\n    \n    \u003c!-- ========================================\n         SPARKLE AUTO-UPDATE (Phase 7 - Commented for MVP)\n         ======================================== --\u003e\n    \n    \u003c!-- \u003ckey\u003eSUFeedURL\u003c/key\u003e --\u003e\n    \u003c!-- \u003cstring\u003ehttps://raw.githubusercontent.com/yourname/optimus-clip/main/appcast.xml\u003c/string\u003e --\u003e\n    \n    \u003c!-- \u003ckey\u003eSUPublicEDKey\u003c/key\u003e --\u003e\n    \u003c!-- \u003cstring\u003eYOUR_SPARKLE_PUBLIC_KEY_HERE\u003c/string\u003e --\u003e\n    \n    \u003c!-- \u003ckey\u003eSUEnableInstallerLauncherService\u003c/key\u003e --\u003e\n    \u003c!-- \u003ctrue/\u003e --\u003e\n    \n    \u003c!-- ========================================\n         PERMISSIONS (Future - Phase 2)\n         ======================================== --\u003e\n    \n    \u003c!-- Accessibility (for global hotkeys and paste simulation) --\u003e\n    \u003c!-- \u003ckey\u003eNSAppleEventsUsageDescription\u003c/key\u003e --\u003e\n    \u003c!-- \u003cstring\u003eOptimus Clip needs Accessibility access to register global hotkeys and paste transformed clipboard content.\u003c/string\u003e --\u003e\n    \n\u003c/dict\u003e\n\u003c/plist\u003e\n```\n\n**2. Placeholder Substitution Logic:**\nThe `Scripts/package_app.sh` script (oc-9g6) performs substitution:\n\n```bash\n# Source version info\nsource \"${ROOT_DIR}/version.env\"\n\n# Generate Info.plist with version substitution\nsed -e \"s/\\$(MARKETING_VERSION)/${MARKETING_VERSION}/g\" \\\n    -e \"s/\\$(BUILD_NUMBER)/${BUILD_NUMBER}/g\" \\\n    \"${ROOT_DIR}/Info.plist\" \u003e \"${CONTENTS}/Info.plist\"\n```\n\nBefore substitution (template):\n```xml\n\u003ckey\u003eCFBundleShortVersionString\u003c/key\u003e\n\u003cstring\u003e$(MARKETING_VERSION)\u003c/string\u003e\n\n\u003ckey\u003eCFBundleVersion\u003c/key\u003e\n\u003cstring\u003e$(BUILD_NUMBER)\u003c/string\u003e\n```\n\nAfter substitution (with version.env: `MARKETING_VERSION=\"0.1.0\"`, `BUILD_NUMBER=\"1\"`):\n```xml\n\u003ckey\u003eCFBundleShortVersionString\u003c/key\u003e\n\u003cstring\u003e0.1.0\u003c/string\u003e\n\n\u003ckey\u003eCFBundleVersion\u003c/key\u003e\n\u003cstring\u003e1\u003c/string\u003e\n```\n\n**3. Key Explanations:**\n\n| Key | Value | Purpose |\n|-----|-------|---------|\n| `CFBundleIdentifier` | `com.yourname.optimusclip` | Unique app ID (reverse domain notation) |\n| `CFBundleName` | `OptimusClip` | Internal name (no spaces) |\n| `CFBundleDisplayName` | `Optimus Clip` | User-facing name (with spaces) |\n| `CFBundleExecutable` | `OptimusClip` | Executable filename in MacOS/ folder |\n| `CFBundleShortVersionString` | `$(MARKETING_VERSION)` | User-facing version (1.0.0) |\n| `CFBundleVersion` | `$(BUILD_NUMBER)` | Build number for Sparkle comparisons |\n| `LSUIElement` | `true` | Menu bar only, no Dock |\n| `LSMultipleInstancesProhibited` | `true` | Single instance enforcement |\n| `LSMinimumSystemVersion` | `15.0` | macOS Sequoia+ required |\n| `LSApplicationCategoryType` | `public.app-category.productivity` | App Store category |\n| `NSHumanReadableCopyright` | `Copyright © 2025` | Legal copyright text |\n\n**4. Bundle ID Naming Convention:**\n- Use reverse domain notation: `com.\u003cyourname\u003e.\u003cappname\u003e`\n- Lowercase only (no capitals)\n- No spaces or special characters\n- Examples:\n  - ✅ `com.johndoe.optimusclip`\n  - ✅ `com.acme.optimus-clip` (hyphen OK)\n  - ❌ `com.JohnDoe.OptimusClip` (capitals)\n  - ❌ `optimusclip` (not reverse domain)\n\nARCHITECTURAL CONNECTIONS:\n- **version.env (oc-9g6):** Source of truth for MARKETING_VERSION and BUILD_NUMBER\n- **Scripts/package_app.sh (oc-9g6):** Substitutes placeholders at build time\n- **OptimusClip.app/Contents/Info.plist:** Final location after packaging\n- **Sparkle Framework (Phase 7):** Reads CFBundleVersion for update comparisons\n- **macOS Launch Services:** Reads LSUIElement and LSMultipleInstancesProhibited\n- **Code Signing (Phase 7):** Bundle ID must match signing certificate\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. **HARDCODED VERSIONS IN TEMPLATE:**\n   - If you put `\u003cstring\u003e0.1.0\u003c/string\u003e` instead of `$(MARKETING_VERSION)`, substitution fails silently\n   - **Solution:** Always use `$(PLACEHOLDER)` syntax for version fields\n\n2. **BUNDLE ID MISMATCH:**\n   - Code signing certificate must match bundle ID (e.g., cert for `com.acme.*`, bundle `com.johndoe.optimusclip` = signing fails)\n   - **Solution:** Decide bundle ID early, get Developer ID cert for that ID\n\n3. **BUILD NUMBER NOT MONOTONIC:**\n   - Sparkle compares build numbers as integers\n   - If v0.1.1 has build 5, v0.1.2 must have build \u003e= 6\n   - Going backwards (build 4) breaks updates\n   - **Solution:** Never decrement BUILD_NUMBER in version.env\n\n4. **LSUIElement WITH WINDOW-BASED APP:**\n   - If app has main window (NSWindow), LSUIElement hides it from Cmd+M minimize\n   - Optimus Clip only has Settings window (modal), so this is fine\n   - **Solution:** Use LSUIElement only for menu bar apps\n\n5. **PLACEHOLDER NOT SUBSTITUTED:**\n   - If `package_app.sh` doesn't run, app bundle has literal `$(MARKETING_VERSION)` text\n   - App crashes on launch with invalid version string\n   - **Solution:** Always build via `pnpm package`, not manual copying\n\n6. **COPYRIGHT YEAR HARDCODED:**\n   - Template has `2025` hardcoded\n   - Future releases still say 2025\n   - **Solution:** Use `$(date +%Y)` in package_app.sh or update manually each year\n\n7. **ICON FILE MISSING:**\n   - If `CFBundleIconFile` key present but Icon.icns missing, app uses generic icon\n   - Not a fatal error, just looks unprofessional\n   - **Solution:** Comment out icon keys until Phase 2 when icon exists\n\nTESTING REQUIREMENTS:\n\n1. **Template Syntax Valid:**\n   ```bash\n   plutil -lint Info.plist\n   # Should output: \"Info.plist: OK\"\n   ```\n\n2. **Placeholders Present:**\n   ```bash\n   grep '$(MARKETING_VERSION)' Info.plist\n   grep '$(BUILD_NUMBER)' Info.plist\n   # Both should find matches\n   ```\n\n3. **Build Script Substitution Works:**\n   ```bash\n   # Run package script\n   pnpm package\n   \n   # Check generated Info.plist\n   plutil -p OptimusClip.app/Contents/Info.plist | grep CFBundleShortVersionString\n   # Should show real version, not $(MARKETING_VERSION)\n   ```\n\n4. **Menu Bar Behavior:**\n   ```bash\n   # Launch packaged app\n   open OptimusClip.app\n   \n   # Verify NOT in Dock (check Dock visually)\n   # Verify NOT in Cmd+Tab (press Cmd+Tab, should not appear)\n   # Verify IS in Menu Bar (check top-right corner)\n   ```\n\n5. **Single Instance Enforcement:**\n   ```bash\n   # Launch app twice\n   open OptimusClip.app\n   sleep 1\n   open OptimusClip.app\n   \n   # Check process count\n   ps aux | grep -c OptimusClip\n   # Should show 1 (not 2)\n   ```\n\n6. **Minimum OS Version:**\n   - On macOS 14 or earlier, app should refuse to launch with error\n   - On macOS 15+, app should launch normally\n   - (MVP: Assume macOS 15+ during development)\n\nSUCCESS CRITERIA:\n- [ ] `Info.plist` exists at repository root\n- [ ] Contains `$(MARKETING_VERSION)` placeholder (not hardcoded version)\n- [ ] Contains `$(BUILD_NUMBER)` placeholder (not hardcoded number)\n- [ ] `LSUIElement` set to `true`\n- [ ] `LSMultipleInstancesProhibited` set to `true`\n- [ ] `LSMinimumSystemVersion` set to `15.0`\n- [ ] Bundle ID follows reverse domain notation (com.yourname.optimusclip)\n- [ ] `plutil -lint Info.plist` passes\n- [ ] Sparkle keys commented out (added in Phase 7)\n- [ ] Copyright year current (2025)\n- [ ] Comments explain each section\n- [ ] CLAUDE.md documents Info.plist structure\n\nCONFIGURATION OPTIONS:\n- Bundle ID: Replace `yourname` with your actual identifier\n- Copyright holder: Update copyright text\n- Category: `public.app-category.productivity` (can change to utilities)\n- Minimum OS: 15.0 for Swift 6 (don't lower, will break)\n\nPERFORMANCE CONSIDERATIONS:\n- Info.plist loaded once at app launch\n- No runtime performance impact\n- Tiny file size (~2 KB)\n\nSECURITY CONSIDERATIONS:\n- Bundle ID uniqueness prevents app spoofing\n- LSMultipleInstancesProhibited prevents malicious duplicate launches\n- Minimum OS version ensures security patches present\n- No secrets stored in Info.plist (visible in app bundle)\n\nIMPLEMENTATION ORDER:\n1. Copy template from MVP spec (plans/optimus-clip-mvp-spec.md)\n2. Replace `com.yourname.optimusclip` with your actual bundle ID\n3. Verify placeholders use `$(VARIABLE)` syntax\n4. Add comments for clarity\n5. Run `plutil -lint Info.plist` to validate XML\n6. Commit template\n7. Verify `package_app.sh` substitution works (test in oc-9g6)\n\nCODE ORGANIZATION:\nInfo.plist                      # Template (repo root)\nversion.env                     # Version source of truth\nScripts/package_app.sh          # Substitution script\nOptimusClip.app/Contents/Info.plist  # Generated (not committed)\n\nPRIORITY: P0 (Required for app bundle creation)\n\nESTIMATED TIME: 15-20 minutes (template creation + validation)\n\nCOMMON PITFALLS:\n| Issue | Solution |\n|-------|----------|\n| Hardcoded version instead of placeholder | Use `$(MARKETING_VERSION)` not `0.1.0` |\n| Bundle ID has uppercase letters | Use lowercase: `com.yourname.optimusclip` |\n| Build number goes backwards | Always increment in version.env |\n| App appears in Dock | Verify `LSUIElement=true` |\n| Multiple instances run | Verify `LSMultipleInstancesProhibited=true` |\n| Invalid XML syntax | Run `plutil -lint Info.plist` |\n\nFUTURE ENHANCEMENTS (Phase 7):\n- Uncomment Sparkle keys (SUFeedURL, SUPublicEDKey)\n- Add NSAppleEventsUsageDescription for Accessibility permission\n- Add custom icon (CFBundleIconFile)\n- Add NSPrincipalClass if using custom app delegate\n\nDEPENDENCIES:\nBefore starting:\n- Repository structure exists\n- version.env created (oc-9g6)\n- Scripts/package_app.sh planned (oc-9g6)\n\nAfter completion:\n- Enables package_app.sh to generate valid app bundles\n- Enables Phase 1 (Menu Bar Shell) to configure app behavior","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:05:54.860264-05:00","updated_at":"2025-12-13T00:19:34.7064-05:00","closed_at":"2025-12-13T00:19:34.7064-05:00","dependencies":[{"issue_id":"oc-9g6.6","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:05:54.860779-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.6","depends_on_id":"oc-9g6.2","type":"blocks","created_at":"2025-12-12T23:53:56.341446-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.7","title":"package.json NPM Scripts","description":"BACKGROUND \u0026 CONTEXT:\npackage.json provides a unified CLI interface for developer workflows using npm/pnpm scripts. While Optimus Clip is a Swift project (not JavaScript), package.json offers several advantages:\n\n1. **Memorable Commands:** `pnpm start` vs `./Scripts/compile_and_run.sh`\n2. **Cross-Platform:** Works on any system with npm/pnpm (no shell script permissions issues)\n3. **Composable:** `check` = `format --lint` + `swiftlint` (DRY principle)\n4. **Familiar:** Web developers joining the project know `pnpm test`, `pnpm build` immediately\n5. **CI-Friendly:** GitHub Actions can run `pnpm check` without learning custom scripts\n6. **Self-Documenting:** `pnpm run` lists all available commands\n\nThis approach is inspired by modern Swift projects like Vapor and SwiftNIO, which use Makefiles or npm scripts as command orchestrators.\n\nKey scripts for Optimus Clip:\n- **start:** Full dev workflow (build + test + package + launch)\n- **build/build:release:** SwiftPM compilation\n- **test:** Run test suite with Swift Testing framework\n- **format:** Auto-fix code style with SwiftFormat\n- **lint:** Check code quality with SwiftLint\n- **check:** Combined format + lint (CI gate)\n- **package/package:release:** Create .app bundle\n- **stop:** Kill running instances before rebuild\n\nREAL-WORLD PROBLEM/USE CASE:\nDeveloper daily workflow comparison:\n\n**WITHOUT package.json:**\n```bash\n# Developer wants to test changes\n./Scripts/kill_optimusclip.sh\nswift build\nswift test\n./Scripts/package_app.sh debug\nopen OptimusClip.app\n\n# Later: Want to run linter\nswiftformat . --lint\nswiftlint lint\n\n# New developer joins, asks: \"How do I build this?\"\n# Answer: \"Read CLAUDE.md section 3, subsection 4, run these 5 commands...\"\n```\n\n**WITH package.json:**\n```bash\n# Developer wants to test changes\npnpm start\n# (Does everything: kill, build, test, package, launch)\n\n# Later: Want to run linter\npnpm check\n\n# New developer joins, asks: \"How do I build this?\"\n# Answer: \"pnpm start\"\n# Or: \"Run 'pnpm run' to see all commands\"\n```\n\n**CI Pipeline Scenario:**\n\nWITHOUT package.json:\n```yaml\n# .github/workflows/ci.yml (messy)\n- run: swiftformat . --lint\n- run: swiftlint lint --strict\n- run: swift build\n- run: swift test --parallel\n```\n\nWITH package.json:\n```yaml\n# .github/workflows/ci.yml (clean)\n- run: pnpm check\n- run: pnpm test\n```\n\n**Cross-Platform Development:**\n\n- Alice (macOS dev) runs: `pnpm start`\n- Bob (Linux dev, future port) runs: `pnpm build` (Swift on Linux)\n- CI (GitHub Actions) runs: `pnpm check`\n- All three use identical commands despite different environments\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n**1. package.json Structure:**\nCreate `package.json` at repository root:\n\n```json\n{\n  \"name\": \"optimus-clip\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"description\": \"Intelligent clipboard middleware for macOS\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/yourname/optimus-clip.git\"\n  },\n  \"scripts\": {\n    \"start\": \"./Scripts/compile_and_run.sh\",\n    \"build\": \"swift build\",\n    \"build:release\": \"swift build -c release\",\n    \"test\": \"swift test\",\n    \"test:parallel\": \"swift test --parallel\",\n    \"format\": \"swiftformat .\",\n    \"format:check\": \"swiftformat . --lint\",\n    \"lint\": \"swiftlint lint --fix\",\n    \"lint:strict\": \"swiftlint lint --strict\",\n    \"check\": \"swiftformat . --lint \u0026\u0026 swiftlint lint\",\n    \"package\": \"./Scripts/package_app.sh debug\",\n    \"package:release\": \"./Scripts/package_app.sh release\",\n    \"stop\": \"./Scripts/kill_optimusclip.sh || true\",\n    \"clean\": \"swift package clean \u0026\u0026 rm -rf .build OptimusClip.app\"\n  },\n  \"keywords\": [\n    \"clipboard\",\n    \"macos\",\n    \"llm\",\n    \"menu-bar\",\n    \"swift\"\n  ],\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\"\n}\n```\n\n**2. Script Explanations:**\n\n| Script | Command | Purpose | Exit Code Handling |\n|--------|---------|---------|-------------------|\n| `start` | `./Scripts/compile_and_run.sh` | Full dev workflow (build + test + package + launch) | Fails if any step fails |\n| `build` | `swift build` | Debug build (fast, includes debug symbols) | Fails if compile errors |\n| `build:release` | `swift build -c release` | Release build (optimized, no debug symbols) | Fails if compile errors |\n| `test` | `swift test` | Run all tests sequentially | Fails if any test fails |\n| `test:parallel` | `swift test --parallel` | Run tests in parallel (faster, requires isolated tests) | Fails if any test fails |\n| `format` | `swiftformat .` | Auto-fix formatting (modifies files) | Always succeeds |\n| `format:check` | `swiftformat . --lint` | Check formatting without changes (CI mode) | Fails if formatting needed |\n| `lint` | `swiftlint lint --fix` | Auto-fix linting issues (modifies files) | Fails if unfixable issues |\n| `lint:strict` | `swiftlint lint --strict` | Treat warnings as errors (CI mode) | Fails on any violation |\n| `check` | `format:check \u0026\u0026 lint` | Combined format + lint check (CI gate) | Fails if either fails |\n| `package` | `./Scripts/package_app.sh debug` | Create debug .app bundle | Fails if build fails |\n| `package:release` | `./Scripts/package_app.sh release` | Create release .app bundle (signed in Phase 7) | Fails if build fails |\n| `stop` | `./Scripts/kill_optimusclip.sh` | Kill running instances | Always succeeds (`|| true`) |\n| `clean` | `swift package clean \u0026\u0026 rm -rf .build OptimusClip.app` | Delete build artifacts | Always succeeds |\n\n**3. Script Chaining Patterns:**\n\n**Sequential with Failure Propagation:**\n```json\n\"check\": \"swiftformat . --lint \u0026\u0026 swiftlint lint\"\n```\n- If SwiftFormat fails, SwiftLint never runs\n- Exit code = first failing command\n\n**Parallel Execution (Future):**\n```json\n\"check:parallel\": \"npm-run-all --parallel format:check lint\"\n```\n- Requires `npm-run-all` package\n- Both run simultaneously\n- Exit code = any failing command\n\n**Always Succeed:**\n```json\n\"stop\": \"./Scripts/kill_optimusclip.sh || true\"\n```\n- If no process found, exit 1 becomes exit 0\n- Prevents `pnpm stop` from failing\n\n**4. Usage Patterns:**\n\n**Development:**\n```bash\n# Full rebuild and launch\npnpm start\n\n# Quick rebuild (no tests)\npnpm build \u0026\u0026 pnpm package \u0026\u0026 open OptimusClip.app\n\n# Run tests only\npnpm test\n\n# Format code before commit\npnpm format\n```\n\n**Pre-Commit:**\n```bash\n# Check formatting and linting (no changes)\npnpm check\n\n# If check fails, auto-fix\npnpm format \u0026\u0026 pnpm lint\n```\n\n**CI Pipeline:**\n```bash\n# Install dependencies (none for MVP, but establishes pattern)\npnpm install\n\n# Check code quality\npnpm check\n\n# Run tests\npnpm test\n\n# Build release binary\npnpm build:release\n```\n\n**Release:**\n```bash\n# Create release build\npnpm package:release\n\n# Verify app bundle\nopen OptimusClip.app\n\n# Sign and notarize (Phase 7)\n./Scripts/sign-and-notarize.sh\n```\n\n**5. Version Synchronization:**\nThe `version` field in package.json should match `MARKETING_VERSION` in version.env:\n\n```bash\n# Update both when releasing\necho 'MARKETING_VERSION=\"0.2.0\"' \u003e version.env\njq '.version = \"0.2.0\"' package.json \u003e tmp.json \u0026\u0026 mv tmp.json package.json\n```\n\n(Or use a script to keep them in sync automatically)\n\nARCHITECTURAL CONNECTIONS:\n- **.swiftformat (oc-9g6.5):** Used by `format` and `check` scripts\n- **.swiftlint.yml (oc-9g6.5):** Used by `lint` and `check` scripts\n- **Scripts/compile_and_run.sh (oc-9g6):** Called by `start` script\n- **Scripts/package_app.sh (oc-9g6):** Called by `package` and `package:release` scripts\n- **Scripts/kill_optimusclip.sh (oc-9g6):** Called by `stop` script\n- **.github/workflows/ci.yml (oc-9g6):** Uses `check` and `test` scripts\n- **CLAUDE.md:** Documents these commands for AI assistants\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. **SCRIPT EXECUTION PERMISSIONS:**\n   - Shell scripts must be executable (`chmod +x Scripts/*.sh`)\n   - If not executable, `pnpm start` fails with \"Permission denied\"\n   - **Solution:** Add `chmod +x` step in repository setup\n\n2. **WINDOWS COMPATIBILITY:**\n   - Shell scripts (`.sh`) don't run natively on Windows\n   - Windows developers need Git Bash or WSL\n   - **Solution:** Document Windows requirements or create `.cmd` equivalents (future)\n\n3. **NPM VS PNPM VS YARN:**\n   - Commands work with any package manager (`npm run start`, `pnpm start`, `yarn start`)\n   - Lockfile differs (package-lock.json vs pnpm-lock.yaml)\n   - **Solution:** Choose one (recommend pnpm for speed) and document in CLAUDE.md\n\n4. **NO NODE_MODULES FOR MVP:**\n   - package.json has no dependencies (no `node_modules` folder)\n   - Only used for script orchestration\n   - May confuse Node.js developers expecting `npm install`\n   - **Solution:** Add comment in package.json: `\"dependencies\": {}`\n\n5. **EXIT CODE PROPAGATION:**\n   - `swift build` fails with exit 1\n   - npm/pnpm propagates exit code correctly\n   - CI detects failure and stops pipeline\n   - **Solution:** No action needed (works correctly)\n\n6. **SCRIPT NOT FOUND:**\n   - If `./Scripts/compile_and_run.sh` doesn't exist, `pnpm start` fails\n   - Error: \"No such file or directory\"\n   - **Solution:** Create scripts before running package.json commands\n\n7. **RELATIVE PATHS:**\n   - Scripts assume execution from repository root\n   - Running `pnpm start` from subdirectory may fail\n   - **Solution:** Always run from root, or add `cd` commands to scripts\n\nTESTING REQUIREMENTS:\n\n1. **All Scripts Runnable:**\n   ```bash\n   # List all scripts\n   pnpm run\n   \n   # Should show: start, build, test, format, lint, check, package, stop, clean\n   ```\n\n2. **Start Script Works:**\n   ```bash\n   pnpm start\n   # Should: kill old instance, build, test, package, launch app\n   # App should appear in menu bar\n   ```\n\n3. **Build Scripts Work:**\n   ```bash\n   pnpm build\n   # Should create .build/debug/OptimusClip\n   \n   pnpm build:release\n   # Should create .build/release/OptimusClip\n   ```\n\n4. **Test Script Works:**\n   ```bash\n   pnpm test\n   # Should run Swift tests and show results\n   ```\n\n5. **Format Scripts Work:**\n   ```bash\n   # Make intentionally bad file\n   echo \"func  bad( x:Int){}\" \u003e Sources/OptimusClip/Test.swift\n   \n   pnpm format\n   # Should fix formatting\n   \n   cat Sources/OptimusClip/Test.swift\n   # Should be: func bad(x: Int) {}\n   ```\n\n6. **Lint Scripts Work:**\n   ```bash\n   pnpm check\n   # Should pass with 0 violations\n   ```\n\n7. **Package Scripts Work:**\n   ```bash\n   pnpm package\n   # Should create OptimusClip.app\n   \n   ls -la OptimusClip.app/Contents/Info.plist\n   # Should exist with substituted versions\n   ```\n\n8. **Stop Script Works:**\n   ```bash\n   pnpm start  # Launch app\n   sleep 2\n   pnpm stop   # Kill app\n   \n   ps aux | grep OptimusClip\n   # Should show no running processes\n   ```\n\n9. **Clean Script Works:**\n   ```bash\n   pnpm clean\n   # Should delete .build/ and OptimusClip.app\n   \n   ls .build\n   # Should not exist\n   ```\n\nSUCCESS CRITERIA:\n- [ ] `package.json` exists at repository root\n- [ ] `\"name\": \"optimus-clip\"` (lowercase, hyphenated)\n- [ ] `\"private\": true` (not published to npm)\n- [ ] All scripts listed in table above exist\n- [ ] `pnpm run` shows all available scripts\n- [ ] `pnpm start` builds and launches app successfully\n- [ ] `pnpm check` validates formatting and linting\n- [ ] `pnpm test` runs test suite\n- [ ] `pnpm package` creates valid .app bundle\n- [ ] Scripts have descriptive comments (optional)\n- [ ] CLAUDE.md documents common workflows using these scripts\n\nCONFIGURATION OPTIONS:\n- Package manager: npm, pnpm, or yarn (recommend pnpm)\n- Test parallelization: `--parallel` flag (requires isolated tests)\n- Lint strictness: `--strict` flag for CI (treat warnings as errors)\n- Clean depth: Can add `rm -rf ~/Library/Caches/OptimusClip` for deeper clean\n\nPERFORMANCE CONSIDERATIONS:\n- Scripts have minimal overhead (~10ms to invoke)\n- SwiftFormat: ~2 seconds for full codebase\n- SwiftLint: ~1 second without analyzer, ~5 seconds with analyzer\n- `pnpm start`: ~10-15 seconds for full rebuild\n- No `node_modules` means zero npm install time\n\nSECURITY CONSIDERATIONS:\n- Scripts can execute arbitrary shell commands (trust your own scripts)\n- Don't add untrusted scripts from third parties\n- Review scripts before running (same as any shell script)\n- No secrets in package.json (visible in git history)\n\nIMPLEMENTATION ORDER:\n1. Create package.json with basic metadata (name, version, private)\n2. Add build scripts (build, build:release)\n3. Add test script (test)\n4. Add format and lint scripts (format, lint, check)\n5. Add package scripts (package, package:release)\n6. Add utility scripts (start, stop, clean)\n7. Test each script individually\n8. Update CLAUDE.md with workflow examples\n9. Commit package.json\n\nCODE ORGANIZATION:\npackage.json                    # Script definitions (repo root)\nScripts/compile_and_run.sh      # Called by `start`\nScripts/package_app.sh          # Called by `package`\nScripts/kill_optimusclip.sh     # Called by `stop`\n.swiftformat                    # Used by `format`\n.swiftlint.yml                  # Used by `lint`\n\nPRIORITY: P0 (Foundational - defines developer workflow)\n\nESTIMATED TIME: 15-20 minutes (JSON creation + script testing)\n\nCOMMON PITFALLS:\n| Issue | Solution |\n|-------|----------|\n| Scripts not executable | Run `chmod +x Scripts/*.sh` |\n| Shell scripts fail on Windows | Use Git Bash or WSL |\n| `pnpm: command not found` | Install pnpm: `npm install -g pnpm` |\n| Scripts assume wrong directory | Always run from repository root |\n| Exit codes not propagated | Use `\u0026\u0026` for sequential scripts |\n| npm install fails | No dependencies = no install needed |\n\nFUTURE ENHANCEMENTS:\n- **npm-run-all:** Parallel script execution (`check:parallel`)\n- **Husky:** Git hooks for pre-commit checks (`pnpm check` before commit)\n- **Semantic Release:** Auto-bump version.env from package.json\n- **Watch Mode:** `pnpm dev` = auto-rebuild on file change\n- **Debug Scripts:** `pnpm debug` = launch with LLDB attached\n\nDEPENDENCIES:\nBefore starting:\n- npm or pnpm installed (`brew install pnpm`)\n- Scripts directory exists with placeholder scripts\n- .swiftformat and .swiftlint.yml exist (oc-9g6.5)\n\nAfter completion:\n- Enables all developer workflows (build, test, format, package)\n- Enables CI pipeline (pnpm check in GitHub Actions)\n- Enables oc-9g6 verification (pnpm start confirms project works)\n\nPACKAGE MANAGER COMPARISON:\n| Feature | npm | pnpm | yarn |\n|---------|-----|------|------|\n| Speed | Slow | Fast (hardlinks) | Medium |\n| Disk usage | High | Low (shared store) | Medium |\n| Monorepo support | Basic | Excellent | Good |\n| Lockfile | package-lock.json | pnpm-lock.yaml | yarn.lock |\n| Adoption | Universal | Growing | Declining |\n\n**Recommendation:** Use pnpm for performance, but npm works fine for zero-dependency projects.\n\nEXAMPLE WORKFLOWS:\n\n**Daily Development:**\n```bash\ngit pull\npnpm start           # Build, test, launch\n# Make code changes\npnpm check           # Verify formatting/linting\npnpm test            # Verify tests pass\ngit add .\ngit commit -m \"...\"\ngit push\n```\n\n**Quick Iteration:**\n```bash\n# Skip tests for faster iteration\npnpm build \u0026\u0026 pnpm package \u0026\u0026 open OptimusClip.app\n```\n\n**Pre-Commit Hook (Future):**\n```bash\n#!/bin/sh\n# .husky/pre-commit\npnpm check || exit 1\n```\n\n**CI Pipeline:**\n```yaml\n# .github/workflows/ci.yml\n- run: pnpm check\n- run: pnpm test\n- run: pnpm build:release\n```","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:05:55.385143-05:00","updated_at":"2025-12-13T00:34:35.021255-05:00","closed_at":"2025-12-13T00:34:35.021255-05:00","dependencies":[{"issue_id":"oc-9g6.7","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:05:55.385623-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.7","depends_on_id":"oc-9g6.4","type":"blocks","created_at":"2025-12-12T23:53:56.570551-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.8","title":"CI Pipeline Setup","description":"BACKGROUND \u0026 CONTEXT:\nContinuous Integration (CI) is the first line of defense against bugs, style drift, and broken builds in software projects. For Optimus Clip, CI ensures that every commit and pull request meets quality standards BEFORE code is merged. This is critical because:\n1. **Swift 6 strict concurrency checking** can fail in non-obvious ways\n2. **Code formatting inconsistencies** accumulate without enforcement\n3. **Breaking changes** may not be caught until runtime without automated testing\n4. **Release confidence** requires proven build reproducibility\n\nThe CI pipeline automates the same checks developers run locally (`pnpm check`, `swift build`, `swift test`) but in a clean, repeatable environment. This catches issues like:\n- \"Works on my machine\" problems (missing dependencies, hardcoded paths)\n- Forgotten commits (new files not added to git)\n- Platform-specific bugs (different macOS versions)\n\nThis pipeline is designed to be FAST (\u003c 5 minutes) and RELIABLE (no flaky tests), with aggressive caching to minimize GitHub Actions costs.\n\nREAL-WORLD PROBLEM/USE CASE:\n**Scenario: Developer submits PR with unformatted code**\n1. Developer writes feature, runs locally, tests pass\n2. Forgets to run `pnpm check` (swiftformat + swiftlint)\n3. Creates PR on GitHub\n4. CI pipeline runs automatically\n5. **Format Check Job: FAILS** - \"Found 12 unformatted files\"\n6. GitHub blocks merge (status check required)\n7. Developer runs `pnpm format` locally\n8. Pushes fix, CI passes\n9. PR merged with consistent formatting\n\n**Without CI:**\n- Unformatted code merges to main\n- Next developer pulls main, their IDE auto-formats on save\n- Git diff shows 500+ line changes (all whitespace)\n- Code review becomes impossible\n- Team argues about formatting in every PR\n- Eventually someone force-pushes a \"mass reformat\" commit\n- Git blame becomes useless for those lines\n\n**Scenario: Breaking change not caught by tests**\n1. Developer refactors ClipboardMonitor\n2. All existing tests still pass (they don't cover edge case)\n3. Creates PR, CI passes tests\n4. Code merged\n5. Release cut from main branch\n6. Users report crash on launch\n7. Rollback required, user trust damaged\n\n**With comprehensive CI:**\n- Build job would catch compilation errors\n- Test job would catch obvious regressions\n- Coverage report would flag untested code paths\n- Team adds test before merging fix\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n**File: .github/workflows/ci.yml**\n- Creates multi-job pipeline with format-check, lint, build, test\n- Uses macos-15 runner for Swift 6 compatibility\n- Implements SPM dependency caching via .build directory\n- Runs on push to main and all pull requests\n- Supports workflow_dispatch for manual triggers\n- Cancels in-progress runs when new commits pushed (saves Actions minutes)\n\n**Key Jobs:**\n1. **format-check**: Runs swiftformat --lint, fails if unformatted code found\n2. **lint**: Runs swiftlint --strict, treats warnings as errors\n3. **build**: Matrix strategy for debug/release configs\n4. **test**: Runs swift test --parallel with code coverage\n5. **ci-success**: Summary job that checks all jobs passed\n\n**Caching Strategy:**\n- Cache key: runner.os + hash of Package.resolved\n- Cached path: .build directory\n- Speeds up builds from ~3min to ~30sec on cache hit\n- Invalidates automatically when dependencies change\n\n**Artifact Handling:**\n- Uploads release binary on main branch pushes only\n- 7-day retention for debugging\n- Skips upload on PRs (cost optimization)\n\n**Coverage Integration:**\n- Generates lcov format coverage report\n- Uploads to Codecov (optional, requires token)\n- Displays summary in CI logs\n- Non-blocking if upload fails\n\nARCHITECTURAL CONNECTIONS:\n- CI enforces code style from `.swiftformat` and `.swiftlint.yml` (created in Phase 0)\n- Validates `Package.swift` dependency resolution\n- Tests all code from `Sources/OptimusClip/` and `Sources/OptimusClipCore/`\n- Prepares for automated release pipeline (Phase 7)\n- Coverage data feeds into quality metrics\n- Artifact uploads enable ad-hoc testing of main builds\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. **SwiftFormat/SwiftLint Version Drift:**\n   - Problem: CI uses Homebrew latest, dev uses different version\n   - Solution: Pin versions in workflow (brew install swiftformat@0.54.0)\n   - Alternative: Use Docker image with locked versions\n\n2. **Package.resolved Not Committed:**\n   - Problem: SPM resolves different dependency versions in CI vs local\n   - Solution: Commit `Package.resolved` to git (recommended for apps)\n   - Check: Add `.gitattributes` entry to prevent merge conflicts\n\n3. **Xcode Command Line Tools Missing:**\n   - Problem: `swift build` fails with cryptic error\n   - Solution: `macos-15` runner includes full toolchain by default\n   - Verify: Add `swift --version` step early in workflow\n\n4. **Flaky Tests:**\n   - Problem: Tests pass locally, fail in CI (timing issues)\n   - Solution: Avoid time-based assertions, use expectations with longer timeouts\n   - Debug: Add `--verbose` flag to test command\n\n5. **Coverage Upload Failures:**\n   - Problem: Codecov token expired or network issues\n   - Solution: `fail_ci_if_error: false` - Don't block merge\n   - Alternative: Use GitHub's built-in coverage comments\n\n6. **Concurrency Limits:**\n   - Problem: Multiple PRs trigger simultaneous builds, hit GitHub Actions limits\n   - Solution: `cancel-in-progress: true` cancels outdated runs\n   - Cost savings: Only test latest commit\n\n7. **Secrets in Logs:**\n   - Problem: API keys accidentally logged in test output\n   - Solution: Mask secrets in GitHub Actions settings\n   - Prevention: Never use real API keys in tests, use mocks\n\nTESTING REQUIREMENTS:\n1. **Manual Verification:**\n   - Create PR with unformatted code → CI fails on format-check\n   - Create PR with SwiftLint violations → CI fails on lint\n   - Create PR with compilation error → CI fails on build\n   - Create PR with failing test → CI fails on test\n   - Create PR with passing checks → CI succeeds\n\n2. **Workflow Testing:**\n   - Push to main branch → All jobs run\n   - Open PR from fork → All jobs run\n   - Manual dispatch via GitHub UI → All jobs run\n   - Push new commit to PR → Previous run cancelled, new run starts\n\n3. **Cache Verification:**\n   - First run (cold cache): Build takes ~3 minutes\n   - Second run (warm cache): Build takes ~30 seconds\n   - After Package.swift change: Cache invalidated, full rebuild\n\n4. **Artifact Verification:**\n   - Main branch push → Artifact uploaded to GitHub\n   - Download artifact → Executable runs without errors\n   - PR push → No artifact uploaded (cost savings)\n\nSUCCESS CRITERIA:\n- [ ] `.github/workflows/ci.yml` created and committed\n- [ ] CI runs on every push to main\n- [ ] CI runs on every pull request\n- [ ] Format check fails on unformatted code\n- [ ] Lint check fails on SwiftLint violations\n- [ ] Build check fails on compilation errors\n- [ ] Test check fails on test failures\n- [ ] SPM dependencies cached correctly\n- [ ] Build artifacts uploaded on main branch\n- [ ] Coverage report generated (optional: uploaded to Codecov)\n- [ ] All jobs complete in \u003c 5 minutes\n- [ ] GitHub branch protection requires CI to pass before merge\n\nCONFIGURATION OPTIONS:\n- **Coverage threshold:** Fail CI if coverage drops below X% (e.g., 80%)\n- **Notification:** Slack/Discord webhook on failure\n- **Artifact retention:** 7 days default, increase for releases\n- **Test parallelization:** `--parallel` flag for faster test runs\n- **Timeout:** 15 minutes per job (prevents hung builds from blocking queue)\n\nPERFORMANCE CONSIDERATIONS:\n- SPM cache reduces build time by 80%+\n- Parallel jobs reduce total CI time\n- `cancel-in-progress` saves GitHub Actions minutes\n- Debug build faster than release (no optimizations)\n- Test parallelization requires thread-safe tests\n\nSECURITY CONSIDERATIONS:\n- No API keys in workflow (use GitHub Secrets)\n- Codecov token stored as repository secret\n- Artifacts only uploaded from main branch (prevent PR poisoning)\n- No execution of PR code before review (GitHub prevents this by default)\n- Fork PRs have limited secret access (GitHub security model)\n\nIMPLEMENTATION ORDER:\n1. Create `.github/workflows/` directory\n2. Write minimal ci.yml with format-check only\n3. Test format-check job locally with `act` tool (optional)\n4. Commit and push to GitHub\n5. Verify format-check runs in GitHub Actions UI\n6. Add lint job\n7. Add build job with caching\n8. Add test job with coverage\n9. Add ci-success summary job\n10. Configure branch protection rules\n\nCODE ORGANIZATION:\n```\noptimus-clip/\n├── .github/\n│   └── workflows/\n│       └── ci.yml              # Main CI pipeline\n├── .swiftformat                # Referenced by format-check job\n├── .swiftlint.yml              # Referenced by lint job\n├── Package.swift               # Dependency resolution\n└── Package.resolved            # Locked dependency versions (commit this!)\n```\n\nPRIORITY: P0 (Must complete before any feature work to prevent quality debt)\n\nESTIMATED TIME: 60-90 minutes (including testing and iteration)\n\nFUTURE ENHANCEMENTS (Post-MVP):\n- **Nightly builds:** Run extended tests on schedule\n- **Benchmark tracking:** Performance regression detection\n- **Security scanning:** Dependency vulnerability checks (GitHub Dependabot)\n- **Release automation:** Trigger release workflow on version tag\n- **Matrix testing:** Multiple macOS versions (15, 14, 13)\n- **Notarization check:** Verify app can be notarized (requires signing)\n\nDEPENDENCIES:\n- Requires `.swiftformat` and `.swiftlint.yml` files (created in Phase 0)\n- Requires `Package.swift` with test targets defined\n- Requires at least one passing test (created in oc-9g6.10)\n- GitHub repository must be public or have Actions enabled\n\nCOMMON FAILURE MODES:\n1. **\"xcrun: error: unable to find utility\"** → Xcode CLI tools not installed\n2. **\"Package.resolved conflicts\"** → Add `merge=union` in .gitattributes\n3. **\"SwiftFormat not found\"** → brew install step failed\n4. **\"No such module 'OptimusClipCore'\"** → Package.swift misconfigured\n5. **\"Coverage data not found\"** → Tests didn't run or crashed\n\nREFERENCE MATERIALS:\n- GitHub Actions docs: https://docs.github.com/en/actions\n- SwiftFormat CLI: https://github.com/nicklockwood/SwiftFormat#command-line-tool\n- SwiftLint CLI: https://github.com/realm/SwiftLint#command-line\n- SPM caching strategies: https://www.polpiella.dev/caching-spm-dependencies-with-github-actions\n- Swift code coverage: https://www.polpiella.dev/code-coverage-for-swift-command-line-tools\n\nBLOCKERS/RISKS:\n- None (CI is independent of application features)\n- Risk: GitHub Actions quota exceeded (unlikely for small project)\n- Mitigation: Use `cancel-in-progress` and aggressive caching","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:05:55.875131-05:00","updated_at":"2025-12-13T00:39:21.13884-05:00","closed_at":"2025-12-13T00:39:21.13884-05:00","dependencies":[{"issue_id":"oc-9g6.8","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:05:55.875606-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.8","depends_on_id":"oc-9g6.5","type":"blocks","created_at":"2025-12-12T23:53:56.740277-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.8","depends_on_id":"oc-9g6.7","type":"blocks","created_at":"2025-12-12T23:53:56.991897-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9g6.9","title":"CLAUDE.md Agent Guidelines","description":"BACKGROUND \u0026 CONTEXT:\nCLAUDE.md is a living documentation file that serves as a \"contract\" between the codebase and AI assistants (Claude, GPT-4, Codex CLI, etc.). It provides context, conventions, and constraints that make AI assistance more effective and consistent. Think of it as:\n- **Onboarding doc** for new AI assistant sessions\n- **Style guide** for code generation\n- **Safety manual** to prevent common mistakes\n- **Architecture diagram** in prose form\n\nWhy this matters for Optimus Clip:\n1. **Swift 6 strict concurrency** requires specific patterns (Sendable, @MainActor, etc.)\n2. **Menu bar app architecture** is non-standard (no Dock icon, background-only)\n3. **Security-critical operations** (Keychain, Accessibility permissions) need careful handling\n4. **Build system complexity** (SwiftPM + custom scripts + version.env)\n\nWithout CLAUDE.md, every AI session starts from zero knowledge:\n- \"Why won't this build?\" (forgot to update Package.swift)\n- \"Why is this code flagged?\" (violated SwiftLint rules)\n- \"Where should this file go?\" (unclear directory structure)\n\nWith CLAUDE.md, AI assistants:\n- Generate code that passes linting on first try\n- Place new files in correct directories\n- Follow established patterns (protocol-oriented design, value types)\n- Avoid anti-patterns (force unwrapping, blocking main thread)\n\nREAL-WORLD PROBLEM/USE CASE:\n**Scenario: Developer asks AI to add new transformation type**\n\n**Without CLAUDE.md:**\n1. Developer: \"Add a new transformation that removes Markdown formatting\"\n2. AI: \"Sure, I'll create a new class...\" (generates reference type with mutable state)\n3. Developer runs `pnpm check`\n4. SwiftLint errors: \"Prefer struct over class for value types\"\n5. SwiftFormat errors: \"Missing explicit self in closure\"\n6. Developer manually fixes style issues\n7. Developer runs `swift build`\n8. Build fails: \"Type does not conform to Sendable\"\n9. Developer adds @unchecked Sendable (dangerous!)\n10. Works, but violates concurrency safety\n\n**With CLAUDE.md:**\n1. Developer: \"Add a new transformation that removes Markdown formatting\"\n2. AI reads CLAUDE.md:\n   - \"Prefer value types (struct) over reference types (class)\"\n   - \"All transformations must conform to Transformation protocol\"\n   - \"Use Swift 6 strict concurrency (@Sendable)\"\n   - \"Place in Sources/OptimusClipCore/\"\n3. AI generates:\n   ```swift\n   struct MarkdownStripTransformation: Transformation, Sendable {\n       func transform(_ input: String) async throws -\u003e String {\n           // Implementation using explicit self\n       }\n   }\n   ```\n4. Developer runs `pnpm check` → Passes\n5. Developer runs `swift build` → Passes\n6. First-try success, no iteration needed\n\n**Scenario: New contributor (or AI session) adds test**\n\n**Without CLAUDE.md:**\n- Test file created in wrong location (Sources/ instead of Tests/)\n- Uses XCTest instead of Swift Testing framework\n- No async test support\n- Imports wrong modules\n\n**With CLAUDE.md:**\n- \"Use Swift Testing framework for new tests\"\n- \"Place tests in Tests/OptimusClipTests/\"\n- \"Async tests supported via @Test attribute\"\n- Correct test structure on first try\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n**File: CLAUDE.md**\n\n```markdown\n# Optimus Clip - AI Assistant Guidelines\n\n**Last Updated:** 2025-12-12\n**Project Status:** Phase 0 (Scaffolding)\n**Swift Version:** 6.0\n**macOS Target:** 15.0+\n\n---\n\n## Project Overview\n\nOptimus Clip is a macOS menu bar application that acts as intelligent clipboard middleware. It intercepts clipboard content via global hotkeys, transforms it using algorithmic rules or LLMs, and pastes the result.\n\n**Bundle ID:** com.\u003cyourname\u003e.optimusclip\n**Architecture:** SwiftUI + AppKit hybrid (menu bar + settings window)\n**Concurrency Model:** Swift 6 strict concurrency with async/await\n\n---\n\n## Project Structure\n\n```\noptimus-clip/\n├── Sources/\n│   ├── OptimusClip/           # Main app target (executable)\n│   │   ├── OptimusClipApp.swift         # @main entry point\n│   │   ├── Views/                       # SwiftUI views\n│   │   │   ├── Settings/                # Settings window tabs\n│   │   │   └── Components/              # Reusable UI components\n│   │   ├── Managers/                    # System integration\n│   │   │   ├── ClipboardMonitor.swift   # Clipboard polling\n│   │   │   ├── HotkeyManager.swift      # Global hotkeys\n│   │   │   └── PermissionManager.swift  # Accessibility permission\n│   │   └── Models/                      # SwiftData models\n│   │\n│   └── OptimusClipCore/       # Shared library (importable)\n│       ├── Transformation.swift         # Core protocol\n│       ├── Transformations/             # Implementations\n│       │   ├── AlgorithmicTransformation.swift\n│       │   └── LLMTransformation.swift\n│       └── LLMClients/                  # Provider integrations\n│           ├── OpenAIClient.swift\n│           ├── AnthropicClient.swift\n│           └── BedrockClient.swift\n│\n├── Tests/\n│   └── OptimusClipTests/      # Unit tests\n│       ├── TransformationTests.swift\n│       └── ClipboardTests.swift\n│\n├── Scripts/                   # Build automation\n│   ├── compile_and_run.sh    # Dev workflow\n│   ├── package_app.sh        # Create .app bundle\n│   └── kill_optimusclip.sh   # Stop running instances\n│\n├── version.env               # Single source of truth for versions\n├── Package.swift             # SPM manifest\n├── package.json              # npm scripts (pnpm interface)\n├── Info.plist                # App configuration template\n├── .swiftformat              # Code formatting rules\n├── .swiftlint.yml            # Linting rules\n└── CLAUDE.md                 # This file\n```\n\n**Why split OptimusClip and OptimusClipCore?**\n- OptimusClip: Platform-specific (AppKit, SwiftUI, macOS APIs)\n- OptimusClipCore: Pure Swift logic (testable, reusable, cross-platform potential)\n\n---\n\n## Build Commands\n\nAll commands use `pnpm` as the interface (reads from package.json scripts):\n\n```bash\n# Development workflow (build + test + package + run)\npnpm start\n\n# Individual operations\npnpm build              # swift build (debug)\npnpm build:release      # swift build -c release\npnpm test               # swift test\npnpm format             # swiftformat . (auto-fix)\npnpm lint               # swiftlint lint --fix (auto-fix)\npnpm check              # swiftformat --lint + swiftlint (no changes, fail if issues)\npnpm package            # ./Scripts/package_app.sh debug\npnpm package:release    # ./Scripts/package_app.sh release\npnpm stop               # Kill running OptimusClip instances\n```\n\n**Before every commit:**\n```bash\npnpm check    # Must pass (no formatting/linting issues)\npnpm test     # Must pass (all tests green)\n```\n\n**Version management:**\n- Edit `version.env` to change version or build number\n- Format: `MARKETING_VERSION=\"0.1.0\"` and `BUILD_NUMBER=\"1\"`\n- Scripts read this file and populate Info.plist automatically\n\n---\n\n## Code Style Expectations\n\n### Swift 6 Concurrency\n- **Always** use strict concurrency checking (enabled in Package.swift)\n- Mark types as `Sendable` explicitly (struct, actor, or final class with immutable state)\n- Use `@MainActor` for UI types (Views, ObservableObject)\n- Never use `@unchecked Sendable` without detailed justification comment\n- Prefer `async/await` over completion handlers\n\n**Example:**\n```swift\n// ✅ GOOD\nstruct ClipboardContent: Sendable {\n    let text: String\n    let timestamp: Date\n}\n\n@MainActor\nfinal class SettingsViewModel: ObservableObject {\n    @Published var apiKey: String = \"\"\n}\n\n// ❌ BAD\nclass ClipboardContent {  // Missing Sendable, should be struct\n    var text: String\n}\n```\n\n### Value Types Over Reference Types\n- **Prefer `struct`** for data models and transformations\n- Use `class` only when:\n  - Need reference semantics (shared mutable state)\n  - Inheriting from Cocoa classes (NSObject, NSView)\n  - Managing system resources (file handles, timers)\n\n### Explicit Self\n- **Always use `self.`** in closures (required by SwiftFormat config)\n- This prevents subtle capture bugs and aids Swift 6 concurrency checking\n\n```swift\n// ✅ GOOD\nTask {\n    let result = await self.transform(self.input)\n}\n\n// ❌ BAD (will fail swiftformat)\nTask {\n    let result = await transform(input)\n}\n```\n\n### Formatting\n- **Indent:** 4 spaces (no tabs)\n- **Line length:** 120 characters max\n- **Argument wrapping:** Before first argument if multi-line\n- **Braces:** Same line for control flow, new line for functions\n- Run `pnpm format` before committing\n\n### Linting\n- **Force unwrap:** Avoid `!` except for known-safe cases (IBOutlets, SF Symbols)\n- **Force try:** Never use `try!` (use `try?` or proper error handling)\n- **File length:** Warn at 1500 lines (refactor if exceeded)\n- **Unused imports:** Delete automatically\n\n---\n\n## Testing Guidelines\n\n### Framework\n- Use **Swift Testing** framework (not XCTest) for new tests\n- Async tests fully supported via `@Test` attribute\n- Test Core library thoroughly (transformations, LLM clients)\n\n### Structure\n```swift\nimport Testing\n@testable import OptimusClipCore\n\n@Suite(\"Transformation Tests\")\nstruct TransformationTests {\n    @Test(\"Whitespace stripping removes leading spaces\")\n    func testWhitespaceStripping() async throws {\n        let transform = WhitespaceStripTransformation()\n        let input = \"  Hello\\n  World\"\n        let output = try await transform.transform(input)\n        #expect(output == \"Hello\\nWorld\")\n    }\n}\n```\n\n### Coverage Goals\n- **Core library:** 80%+ coverage\n- **UI code:** Test ViewModels, skip pure SwiftUI views\n- **System integration:** Mock system APIs (clipboard, hotkeys)\n\n### Running Tests\n```bash\npnpm test              # Run all tests\nswift test --filter \"TransformationTests\"  # Run specific suite\n```\n\n---\n\n## Safety Guards\n\n### Never Commit\n- API keys or secrets (use Keychain, not hardcoded strings)\n- Absolute paths from your machine (`/Users/yourname/...`)\n- `Package.resolved` merge conflicts (use `.gitattributes` merge strategy)\n- Debug print statements (`print()`, `dump()`)\n\n### Always Test Before Push\n```bash\npnpm check    # Format and lint\npnpm test     # All tests pass\npnpm start    # App launches without crash\n```\n\n### Never Auto-Release\n- Don't create GitHub releases without explicit approval\n- Don't bump version numbers autonomously\n- Don't run signing/notarization scripts without request\n\n---\n\n## Architecture Patterns\n\n### Protocol-Oriented Design\nDefine protocols for core abstractions:\n```swift\nprotocol Transformation: Sendable {\n    func transform(_ input: String) async throws -\u003e String\n}\n```\n\n### Dependency Injection\nPass dependencies explicitly, avoid singletons:\n```swift\n// ✅ GOOD\nstruct LLMTransformation: Transformation {\n    let client: LLMClient\n\n    func transform(_ input: String) async throws -\u003e String {\n        try await client.complete(input)\n    }\n}\n\n// ❌ BAD\nstruct LLMTransformation {\n    func transform(_ input: String) async throws -\u003e String {\n        try await OpenAIClient.shared.complete(input)  // Singleton, hard to test\n    }\n}\n```\n\n### Error Handling\n- Define custom error types conforming to `Error`\n- Use `throws` for expected failures (network, validation)\n- Use `Result` for async operations with explicit error handling\n- Never silently swallow errors (`try? foo()` without fallback)\n\n---\n\n## Common Operations\n\n### Adding a New Transformation\n1. Create new struct in `Sources/OptimusClipCore/Transformations/`\n2. Conform to `Transformation` protocol\n3. Mark as `Sendable`\n4. Add tests in `Tests/OptimusClipTests/`\n5. Run `pnpm check` and `pnpm test`\n\n### Adding a New LLM Provider\n1. Create client in `Sources/OptimusClipCore/LLMClients/`\n2. Define async methods for API calls\n3. Store credentials in Keychain (Phase 6) or @AppStorage (Phase 0-5)\n4. Add provider section to Settings UI\n5. Update provider enum in Models\n\n### Modifying UI\n1. Edit SwiftUI views in `Sources/OptimusClip/Views/`\n2. Use `@AppStorage` for user preferences\n3. Mark ViewModels with `@MainActor`\n4. Test in both light and dark mode\n\n---\n\n## Security Considerations\n\n### API Keys\n- **Phase 0-5:** Store in `@AppStorage` (UserDefaults) as placeholder\n- **Phase 6:** Migrate to macOS Keychain via Security framework\n- Never log API keys (check test output)\n\n### Accessibility Permission\n- Required for global hotkeys and paste simulation\n- Check with `AXIsProcessTrusted()`\n- Request with `AXIsProcessTrustedWithOptions()`\n- Provide clear UI explanation (not just system prompt)\n\n### Clipboard Data\n- Binary safety: Check pasteboard type before processing\n- Never send images to text-only LLMs\n- Implement timeout for LLM calls (30s default)\n\n---\n\n## Commit Guidelines\n\n### Message Format\n```\nShort summary (50 chars or less)\n\nDetailed explanation if needed. Wrap at 72 characters.\n\n- Bullet points for multiple changes\n- Reference issue numbers: Fixes #42\n```\n\n### Before Committing\n- [ ] Run `pnpm check` (passes)\n- [ ] Run `pnpm test` (passes)\n- [ ] Review diff (no unintended changes)\n- [ ] Update CLAUDE.md if patterns changed\n\n---\n\n## Troubleshooting\n\n### Build Fails\n- Check Swift version: `swift --version` (should be 6.0+)\n- Check Xcode: `xcode-select -p` (should point to Xcode.app)\n- Clean build: `swift package clean \u0026\u0026 swift build`\n\n### Tests Fail\n- Check imports: `@testable import OptimusClipCore`\n- Check test target in Package.swift\n- Run verbose: `swift test --verbose`\n\n### Format/Lint Fails\n- Auto-fix: `pnpm format \u0026\u0026 pnpm lint`\n- If still fails, read error messages carefully\n- SwiftFormat errors usually indicate syntax issues\n\n### App Won't Launch\n- Kill existing instances: `pnpm stop`\n- Check binary exists: `ls -l .build/debug/OptimusClip`\n- Run directly: `.build/debug/OptimusClip`\n\n---\n\n## Phase-Specific Notes\n\n### Phase 0 (Current)\n- Focus on tooling, not features\n- Placeholder code is intentionally minimal\n- Goal: `pnpm start` works end-to-end\n- API keys in @AppStorage (not Keychain yet)\n\n### Future Phases\n- Phase 1: Menu bar UI\n- Phase 2: Clipboard monitoring\n- Phase 3: Hotkeys + Settings\n- Phase 4: Algorithmic transformations\n- Phase 5: LLM integration\n- Phase 6: Keychain + Launch at login\n- Phase 7: Code signing + auto-updates\n\n---\n\n## Questions to Ask Before Acting\n\n1. \"Does this change require a test?\"\n2. \"Does this follow Swift 6 concurrency rules?\"\n3. \"Is this a value type or reference type? Why?\"\n4. \"Should this be in OptimusClip or OptimusClipCore?\"\n5. \"Will this pass swiftformat and swiftlint?\"\n6. \"Is this security-sensitive? (API keys, clipboard, permissions)\"\n\n---\n\n## Useful Links\n\n- Swift 6 Migration Guide: https://www.swift.org/migration/documentation/swift-6-concurrency-migration-guide/\n- SwiftUI + AppKit Integration: https://developer.apple.com/documentation/swiftui/integrating-swiftui-views-into-appkit-views\n- Accessibility Permission: https://developer.apple.com/documentation/applicationservices/1459186-axisprocesstrusted\n- KeyboardShortcuts Package: https://github.com/sindresorhus/KeyboardShortcuts\n- MenuBarExtraAccess Package: https://github.com/orchetect/MenuBarExtraAccess\n\n---\n\n**Remember:** This file is a living document. Update it when you discover new patterns, establish conventions, or learn from mistakes. The goal is to make every AI session and every contributor more effective.\n```\n\nARCHITECTURAL CONNECTIONS:\n- Referenced by CI pipeline (establishes code style requirements)\n- Referenced by developers and AI assistants (establishes patterns)\n- Documents project structure (maps to actual directories)\n- Explains build system (version.env, package.json, Scripts/)\n- Defines testing strategy (influences Phase 4-6 implementation)\n- Security guidelines (influences Phase 6 Keychain work)\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. **Keeping CLAUDE.md Up-to-Date:**\n   - Problem: File becomes stale as project evolves\n   - Solution: Add \"Update CLAUDE.md\" to PR checklist when patterns change\n   - Trigger: New architecture decision, new convention established\n\n2. **Too Much Detail vs. Too Little:**\n   - Problem: Either overwhelms reader or provides no value\n   - Solution: Balance \"Why\" (context) with \"What\" (rules)\n   - Test: Can a new contributor understand the decision?\n\n3. **Conflicting with Other Docs:**\n   - Problem: README says one thing, CLAUDE.md says another\n   - Solution: CLAUDE.md is implementation guide, README is user-facing\n   - Clarity: \"For developers/AI\" vs. \"For users\"\n\n4. **AI Ignores CLAUDE.md:**\n   - Problem: AI assistant doesn't read or follow guidelines\n   - Solution: Explicitly prompt: \"Read CLAUDE.md before generating code\"\n   - Workaround: Copy relevant sections into prompt\n\n5. **Style Rules Change:**\n   - Problem: SwiftFormat/SwiftLint updated, rules different\n   - Solution: Update CLAUDE.md when updating .swiftformat or .swiftlint.yml\n   - Version: Date stamp and note last review date\n\n6. **Security Guidance Outdated:**\n   - Problem: Phase 6 migrates to Keychain, old guidance about @AppStorage\n   - Solution: Add \"Phase-Specific Notes\" section\n   - Clarity: \"Phase 0-5: Use @AppStorage\" vs \"Phase 6+: Use Keychain\"\n\n7. **Code Examples Drift:**\n   - Problem: Examples in CLAUDE.md don't compile anymore\n   - Solution: Keep examples minimal and generic\n   - Alternative: Reference actual files instead of inline code\n\nTESTING REQUIREMENTS:\n1. **Readability Test:**\n   - New contributor (or fresh AI session) reads CLAUDE.md\n   - Can answer: \"Where do I put a new transformation?\"\n   - Can answer: \"What's the command to run tests?\"\n   - Can answer: \"Why use struct instead of class?\"\n\n2. **Accuracy Test:**\n   - Every code example in CLAUDE.md compiles\n   - Every command in CLAUDE.md works when run\n   - Every link in CLAUDE.md resolves (no 404s)\n\n3. **Completeness Test:**\n   - All directories explained\n   - All build commands documented\n   - All style rules justified\n   - All security-critical operations highlighted\n\n4. **AI Assistant Test:**\n   - Start fresh AI session\n   - Prompt: \"Read CLAUDE.md, then add a new transformation\"\n   - Verify: Generated code follows all conventions\n   - Verify: File placed in correct directory\n   - Verify: Code passes `pnpm check` without changes\n\nSUCCESS CRITERIA:\n- [ ] CLAUDE.md file created in repository root\n- [ ] All sections from template included\n- [ ] Project structure accurately documented\n- [ ] Build commands tested and working\n- [ ] Code style rules match .swiftformat and .swiftlint.yml\n- [ ] Testing guidelines align with Swift Testing framework\n- [ ] Safety guards cover security-critical operations\n- [ ] Architecture patterns explained with examples\n- [ ] Common operations have step-by-step instructions\n- [ ] Troubleshooting section covers frequent issues\n- [ ] Referenced by README (link for developers)\n- [ ] AI assistant follows guidelines when prompted to read file\n\nCONFIGURATION OPTIONS:\n- **Detail level:** Adjust based on team experience (more for juniors)\n- **Update frequency:** Review every sprint or after major architecture changes\n- **Automation:** Add pre-commit hook to suggest updating CLAUDE.md if Package.swift changed\n\nPERFORMANCE CONSIDERATIONS:\n- N/A (documentation file, no runtime impact)\n- File size should be readable in one sitting (\u003c 500 lines)\n\nSECURITY CONSIDERATIONS:\n- **Critical:** Never include actual API keys or secrets in examples\n- Use placeholder values: `sk-...`, `YOUR_KEY_HERE`\n- Highlight security-sensitive operations clearly\n- Document progression: @AppStorage → Keychain migration\n\nIMPLEMENTATION ORDER:\n1. Create CLAUDE.md file in repository root\n2. Write \"Project Overview\" section (1-2 paragraphs)\n3. Document \"Project Structure\" (directory tree with explanations)\n4. List \"Build Commands\" (copy from package.json, add explanations)\n5. Define \"Code Style Expectations\" (reference .swiftformat/.swiftlint.yml)\n6. Write \"Testing Guidelines\" (framework, structure, coverage)\n7. Add \"Safety Guards\" (security + common mistakes)\n8. Describe \"Architecture Patterns\" (protocol-oriented, DI, error handling)\n9. Create \"Common Operations\" (add transformation, add provider, modify UI)\n10. Write \"Troubleshooting\" (frequent build/test issues)\n11. Add \"Phase-Specific Notes\" (Phase 0 context)\n12. Link from README.md\n\nCODE ORGANIZATION:\n```\noptimus-clip/\n├── CLAUDE.md           # AI assistant guidelines (this file)\n├── README.md           # User-facing documentation (links to CLAUDE.md for devs)\n└── ...\n```\n\nPRIORITY: P0 (Required for effective AI assistance throughout project)\n\nESTIMATED TIME: 90-120 minutes (writing + reviewing + testing)\n\nFUTURE ENHANCEMENTS:\n- **Interactive examples:** Link to runnable playground/tests\n- **Decision log:** Append architecture decisions with rationale\n- **Anti-patterns:** \"Don't do this\" section with bad examples\n- **Performance notes:** Profiling guidance, optimization patterns\n- **Accessibility notes:** VoiceOver, keyboard navigation guidelines\n\nDEPENDENCIES:\n- Requires project structure established (directories exist)\n- Requires Package.swift and package.json created\n- Requires .swiftformat and .swiftlint.yml configured\n- Should be created early in Phase 0 (before writing code)\n\nCOMMON FAILURE MODES:\n1. **\"Too academic\"** → Keep examples concrete and practical\n2. **\"Copy of README\"** → CLAUDE.md is for implementation, README for users\n3. **\"Never updated\"** → Add to PR template: \"Did you update CLAUDE.md?\"\n4. **\"AI ignores it\"** → Explicitly prompt AI to read it\n5. **\"Examples don't work\"** → Test every code snippet before committing\n\nREFERENCE MATERIALS:\n- Swift.org style guide: https://www.swift.org/documentation/api-design-guidelines/\n- Google's documentation guide: https://google.github.io/styleguide/\n- Anthropic's prompt engineering: https://docs.anthropic.com/claude/docs/\n\nBLOCKERS/RISKS:\n- None (can be written independently)\n- Risk: Becomes stale if not maintained\n- Mitigation: Review quarterly, link from PR template\n\nVERIFICATION CHECKLIST:\nAfter writing CLAUDE.md, verify:\n- [ ] Every directory in \"Project Structure\" exists\n- [ ] Every command in \"Build Commands\" runs successfully\n- [ ] Every code example compiles\n- [ ] Every link resolves (no 404s)\n- [ ] File reads naturally (not too verbose)\n- [ ] AI assistant test passes (generate code following guidelines)\n- [ ] Referenced by README with clear call-to-action for developers","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:06:15.108998-05:00","updated_at":"2025-12-13T00:42:50.92723-05:00","closed_at":"2025-12-13T00:42:50.92723-05:00","dependencies":[{"issue_id":"oc-9g6.9","depends_on_id":"oc-9g6","type":"parent-child","created_at":"2025-12-12T22:06:15.109553-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-9g6.9","depends_on_id":"oc-9g6.1","type":"blocks","created_at":"2025-12-12T23:53:57.194401-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-9k1","title":"Fix AWSBedrockProviderClient isConfigured() returning true for unsupported SigV4","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-16T19:43:56.975657-05:00","updated_at":"2025-12-16T20:35:11.307151-05:00","closed_at":"2025-12-16T20:35:11.307151-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:44:43.926088-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-9ko","title":"AWS Bedrock SigV4 signing has placeholder signature that will never work","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-16T19:06:58.026-05:00","updated_at":"2025-12-16T20:35:11.304259-05:00","closed_at":"2025-12-16T20:35:11.304259-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:08:18.015969-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-9kt","title":"Create self-signed dev certificate for persistent accessibility permissions","description":"Create a self-signed code signing certificate for debug builds so that macOS accessibility permissions persist across rebuilds. Update package_app.sh to use the certificate instead of ad-hoc signing.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T19:58:43.673419-05:00","updated_at":"2025-12-14T20:12:18.477449-05:00","closed_at":"2025-12-14T20:12:18.477449-05:00"}
{"id":"oc-bh0","title":"Rename built-in transformations for clarity","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T22:11:51.881495-05:00","updated_at":"2025-12-15T22:12:03.85781-05:00","closed_at":"2025-12-15T22:12:03.85781-05:00"}
{"id":"oc-c3z","title":"Wire Smart Fix hotkey to LLM transformation pipeline","description":"Smart Fix hotkey (Cmd+Option+S) currently uses the same algorithmic pipeline as Quick Fix instead of calling the LLM as specified in the MVP plan.\n\n## Current State\nBoth handlers in HotkeyManager.swift ignore TransformationConfig settings:\n\n1. handleBuiltInHotkey (line 216-220):\n   - Smart Fix case just calls TransformationPipeline.quickFix()\n   \n2. handleUserTransformationHotkey (line 245-248):\n   - Ignores transformation.type completely\n   - Comment says 'Phase 5 will add LLM-based transformations'\n\n## TransformationConfig Already Has LLM Fields\n- type: .algorithmic or .llm\n- provider: e.g. 'anthropic'\n- model: e.g. 'claude-3-haiku-20240307'  \n- systemPrompt: user-configured prompt\n\nDefault Smart Fix config (line 136-145) is already set up:\n- type: .llm\n- provider: 'anthropic'\n- model: 'claude-3-haiku-20240307'\n- systemPrompt: 'Clean up and improve...'\n\n## Required Changes\n1. Check transformation.type in handleUserTransformationHotkey\n2. If type == .llm:\n   - Use LLMProviderClientFactory to get client for transformation.provider\n   - Create LLMTransformation with provider client, model, systemPrompt\n   - Wrap in TransformationPipeline\n3. If type == .algorithmic: use quickFix() pipeline (current behavior)\n4. Handle errors gracefully (beep + no paste if LLM fails or not configured)\n\n## Infrastructure Already Exists\n- LLMTransformation class in OptimusClipCore\n- Provider clients (Anthropic, OpenAI, OpenRouter, Ollama, Bedrock)\n- LLMProviderClientFactory for creating clients from credentials","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T22:52:38.930936-05:00","updated_at":"2025-12-15T10:31:30.767477-05:00","closed_at":"2025-12-15T10:31:30.767477-05:00"}
{"id":"oc-c4g","title":"MenuBarExtra menu flickers and auto-closes","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-16T21:52:23.190773-05:00","updated_at":"2025-12-27T17:22:43.495779-05:00","closed_at":"2025-12-27T17:22:43.495779-05:00","close_reason":"Fixed in commit 5f4f6f2 - added bundle guards to NotificationService"}
{"id":"oc-c6e","title":"Enable full signed release with Apple Developer ID","description":"## Overview\nSet up Apple Developer Program membership and configure the full signed release workflow for OptimusClip. This enables:\n- Notarized releases (no Gatekeeper warnings)\n- Sparkle auto-updates working for users\n- Professional distribution\n\n## Prerequisites\n- $99/year Apple Developer Program membership\n- Mac with Xcode installed\n- GitHub CLI authenticated (`gh auth login`)\n\n## Step 1: Enroll in Apple Developer Program\n1. Go to https://developer.apple.com/programs/enroll/\n2. Sign in with your Apple ID (or create one)\n3. Enroll as Individual ($99/year)\n4. Wait for enrollment approval (usually 24-48 hours)\n\n## Step 2: Create Developer ID Application Certificate\n1. Go to https://developer.apple.com/account/resources/certificates/list\n2. Click \"+\" to create new certificate\n3. Select \"Developer ID Application\" (for distribution outside App Store)\n4. Follow CSR creation steps:\n   - Open Keychain Access \u003e Certificate Assistant \u003e Request Certificate from CA\n   - Enter email, select \"Saved to disk\"\n   - Upload the .certSigningRequest file\n5. Download and double-click the certificate to install in Keychain\n6. Note your Team ID (visible in Membership details)\n\n## Step 3: Create App Store Connect API Key\n1. Go to https://appstoreconnect.apple.com/access/api\n2. Click \"+\" to generate new key\n3. Name: \"OptimusClip Notarization\"\n4. Access: \"Developer\" role is sufficient\n5. Download the .p8 file (ONLY AVAILABLE ONCE - save securely!)\n6. Note the Key ID and Issuer ID shown on the page\n\n## Step 4: Configure Environment Variables\nAdd to your shell profile (~/.zshrc or ~/.bashrc):\n\n```bash\n# Apple Developer credentials for notarization\nexport APP_STORE_CONNECT_KEY_ID=\"YOUR_KEY_ID\"\nexport APP_STORE_CONNECT_ISSUER_ID=\"YOUR_ISSUER_ID\"\nexport APP_STORE_CONNECT_API_KEY_P8=\"$(base64 \u003c /path/to/AuthKey_XXXXX.p8)\"\nexport DEVELOPER_ID_APP_IDENTITY=\"Developer ID Application: Your Name (TEAM_ID)\"\nexport SPARKLE_PRIVATE_KEY_FILE=\"/path/to/sparkle-private-key\"\n```\n\nThen reload: `source ~/.zshrc`\n\n## Step 5: Update Team ID in Code\nEdit `Sources/OptimusClip/Services/UpdaterWrapper.swift`:\n- Change `private static let teamID = \"YOUR_TEAM_ID\"` to your actual Team ID\n\n## Step 6: Export Sparkle Private Key (if not done)\nThe Sparkle key is already in your Keychain. To export for backup:\n```bash\n.build/artifacts/sparkle/Sparkle/bin/generate_keys -x \u003e ~/Desktop/sparkle-private-key.txt\n# Move to secure location (1Password, etc.), then delete plaintext\n```\n\nSet the environment variable to point to this file.\n\n## Step 7: Test the Full Release\n```bash\n# First, do a dry run\n./Scripts/release.sh --dry-run\n\n# If that passes, bump version in version.env and do real release\n./Scripts/release.sh\n```\n\n## Step 8: Verify Release\n1. Download from GitHub release\n2. Verify no Gatekeeper warning on fresh Mac\n3. Verify \"Check for Updates\" menu appears\n4. Test auto-update flow\n\n## Reference Documentation\n- docs/RELEASE_PREREQUISITES.md - Full setup guide\n- docs/RELEASE_PROCESS.md - Step-by-step release guide\n- docs/RELEASE_GOTCHAS.md - Troubleshooting common issues\n- docs/RELEASE_CHECKLIST.md - Verification checklist\n\n## Security Notes\n- Store .p8 file securely (1Password, encrypted drive)\n- Never commit credentials to git\n- The base64-encoded API key in env var is safe (not in git)\n- Sparkle private key should also be backed up securely","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-27T18:25:52.997648-05:00","created_by":"Chris Edwards","updated_at":"2025-12-27T18:25:52.997648-05:00","labels":["release","setup"]}
{"id":"oc-c8n","title":"Test bead","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:00:33.298999-05:00","updated_at":"2025-12-12T22:17:48.329968-05:00","closed_at":"2025-12-12T22:17:48.329968-05:00"}
{"id":"oc-c9x","title":"Phase 7 - Release Infrastructure","description":"POST-MVP: Complete distribution infrastructure for Optimus Clip.\n\nBACKGROUND:\nThis phase enables professional distribution of Optimus Clip outside the Mac App Store. It addresses three critical requirements:\n1. Code Signing: Proves the app comes from a verified developer (you)\n2. Notarization: Apple's automated malware scanning (required on macOS 10.15+)\n3. Automatic Updates: Sparkle framework for seamless user updates\n\nWHY THIS IS NEEDED:\n- Without signing: Users get 'unidentified developer' warnings, must right-click to open\n- Without notarization: macOS 10.15+ blocks unsigned apps ('App is damaged' error)\n- Without updates: Users must manually download new versions (poor UX)\n\nAPPLE DEVELOPER PROGRAM REQUIREMENTS:\n- /year Apple Developer Program membership (https://developer.apple.com/programs/)\n- Developer ID Application certificate (for signing apps distributed outside Mac App Store)\n- App Store Connect API credentials (for notarization automation)\n\nSECURITY \u0026 SIGNING DETAILS:\n- Developer ID uses separate certificates from App Store distribution\n- Hardened Runtime must be enabled (mandatory for notarization)\n- Notarization is server-side (Apple scans your app, issues ticket)\n- Stapling attaches notarization ticket to app (works offline)\n\nCOMMON GOTCHAS:\n- Sparkle must ONLY run in signed, bundled builds (not during development)\n- Bundle identifier must match everywhere (Xcode, Info.plist, certificates)\n- AppleDouble (._) files in archives break signatures (use ditto, not zip)\n- Build numbers must strictly increase for Sparkle to recognize updates\n\nDEPENDENCIES:\n- Depends on Phase 6 Epic (MVP complete) - when that bead exists, add dependency\n\nSCOPE:\nThis phase is optional for initial MVP release. You can distribute unsigned builds for testing, then complete Phase 7 for wider distribution.\n\nSUCCESS CRITERIA:\n- App signed with Developer ID and notarized by Apple\n- Users can download and run without warnings\n- Sparkle provides automatic update checks and installs\n- Release process is scripted and repeatable","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-12T22:04:37.967008-05:00","updated_at":"2025-12-27T18:05:32.102527-05:00","closed_at":"2025-12-27T18:05:32.102527-05:00","close_reason":"All Phase 7 release infrastructure tasks complete","dependencies":[{"issue_id":"oc-c9x","depends_on_id":"oc-l9j","type":"blocks","created_at":"2025-12-13T09:40:13.086816-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-c9x.1","title":"Prerequisites Documentation and Checklist","description":"Document and verify all prerequisites before starting Phase 7 implementation.\n\nBACKGROUND:\nPhase 7 requires external accounts, certificates, and keys that take time to obtain. This checklist ensures you have everything ready before starting implementation, avoiding mid-stream blockers.\n\nPREREQUISITES CHECKLIST:\n\n1. APPLE DEVELOPER PROGRAM MEMBERSHIP (/year)\n   - Sign up at https://developer.apple.com/programs/\n   - Processing can take 24-48 hours\n   - Required for: Developer ID certificates, notarization\n   - Verify: Check https://developer.apple.com/account/\n\n2. DEVELOPER ID APPLICATION CERTIFICATE\n   - Type: 'Developer ID Application' (NOT 'Mac App Distribution')\n   - Request from: Xcode \u003e Settings \u003e Accounts \u003e Manage Certificates\n   - Or: https://developer.apple.com/account/resources/certificates/\n   - Must be installed in macOS Keychain (System or login keychain)\n   - Verify: Run 'security find-identity -v -p codesigning'\n   - Should see: 'Developer ID Application: Your Name (TEAM_ID)'\n\n3. APP STORE CONNECT API CREDENTIALS\n   - Purpose: Automated notarization (xcrun notarytool)\n   - Create at: https://appstoreconnect.apple.com/access/api\n   - Generate: Keys \u003e App Store Connect API \u003e Create Key\n   - Role: 'Developer' or 'Admin' (App Manager insufficient)\n   - Download: .p8 file (ONLY ONE CHANCE - save securely\\!)\n   - Note: Key ID (e.g., 'AB12CD34EF')\n   - Note: Issuer ID (UUID from API Keys page)\n   - Convert p8 to base64: 'base64 -i AuthKey_KEYID.p8 | tr -d \"\\n\"'\n   - Store: In environment variable or secure vault\n\n4. SPARKLE SIGNING KEY PAIR (ed25519)\n   - Generate: './Pods/Sparkle/bin/generate_keys' (after adding Sparkle to SPM)\n   - Or: 'openssl genpkey -algorithm ed25519 -out sparkle_private_key.pem'\n   - Output: Public key (for Info.plist) and private key (for signing releases)\n   - Store private key: Securely (1Password, keychain, etc.)\n   - Format: Single-line base64, NO comments, NO line breaks\n   - Common error: Multi-line PEM format breaks signing\n\nDELIVERABLES:\n- Create docs/RELEASE_PREREQUISITES.md with this checklist\n- Add verification commands for each prerequisite\n- Include troubleshooting for common certificate issues\n- Document secure storage recommendations for keys\n\nCOMMON GOTCHAS:\n- Wrong certificate type: 'Mac App Distribution' won't work for notarization\n- Expired certificates: Renew at developer.apple.com\n- .p8 file: Only downloadable ONCE when created (can't re-download)\n- Sparkle key format: Must be single line (use 'tr -d \"\\n\"' to strip newlines)\n- Keychain access: Certificate must be accessible to codesign (check keychain access control)\n\nVERIFICATION:\n- [ ] Apple Developer Program active (check account status)\n- [ ] Developer ID Application cert in Keychain ('security find-identity')\n- [ ] App Store Connect API key downloaded (.p8 file saved)\n- [ ] Key ID and Issuer ID documented\n- [ ] Sparkle key pair generated and securely stored\n- [ ] Environment variables set for all credentials","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:04:58.333368-05:00","updated_at":"2025-12-16T18:36:25.095647-05:00","closed_at":"2025-12-16T18:36:25.095647-05:00","close_reason":"Documented release prerequisites and verification checklist in docs/RELEASE_PREREQUISITES.md","dependencies":[{"issue_id":"oc-c9x.1","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-13T09:39:52.620214-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.1","depends_on_id":"oc-l9j","type":"blocks","created_at":"2025-12-13T09:43:03.855421-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-c9x.10","title":"Document Release Flow Process","description":"BACKGROUND: Step-by-step documentation of complete release process from version bump to published release. Ensures consistent releases and serves as checklist.\n\nPROBLEM: Releases have many sequential steps, easy to forget one, unclear order, errors cause confusion, no documented recovery procedure.\n\nRELEASE PROCESS (step-by-step):\n\nSTEP 1 - UPDATE VERSION:\nEdit version.env:\n- Bump MARKETING_VERSION (1.0.0 to 1.0.1 for patch, 1.1.0 for minor, 2.0.0 for major)\n- Increment BUILD_NUMBER (must be strictly greater, e.g., 5 to 6)\n- Sparkle compares BUILD_NUMBER, not MARKETING_VERSION\nCommit: Not yet, wait until all updates done\n\nSTEP 2 - UPDATE CHANGELOG:\nEdit CHANGELOG.md:\n- Add section for new version at top\n- List: New features, bug fixes, improvements, breaking changes\n- Format: Keep a Changelog style (https://keepachangelog.com)\n- Be specific: \"Fixed clipboard crash with images\" not \"Bug fixes\"\n\nSTEP 3 - COMMIT VERSION CHANGES:\ngit add version.env CHANGELOG.md\ngit commit -m \"Bump version to 1.0.1\"\nDO NOT tag yet (release.sh does this automatically)\n\nSTEP 4 - RUN RELEASE SCRIPT:\n./Scripts/release.sh\nScript will: build, test, sign, notarize, create GitHub release, update appcast, tag\nDuration: 10-20 minutes (notarization is slow)\nMonitor: Watch output for errors\n\nSTEP 5 - VERIFY RELEASE:\n- GitHub: Check release page has both .zip and .dSYM.zip assets\n- Download: Download .zip, extract with \"ditto -x -k\", verify opens without warnings\n- Appcast: Verify appcast.xml has new item with correct version/signature\n- Git: Verify tag created (git tag -l)\n- Test: Install on clean Mac, verify works\n\nSTEP 6 - ANNOUNCE (optional):\n- Post release notes to users (blog/Twitter/Discord)\n- Update website with new version\n- Notify beta testers\n- Update documentation if API changes\n\nTROUBLESHOOTING:\n\nIssue: Release fails at sign step\nCause: Invalid/expired certificate\nCheck: security find-identity -v -p codesigning\nFix: Renew certificate at developer.apple.com, install in Keychain\n\nIssue: Release fails at notarization\nCause: Various (hardened runtime, unsigned dependencies, wrong entitlements)\nCheck: xcrun notarytool log --id SUBMISSION_ID\nFix: Address issues in log, re-run\n\nIssue: Sparkle signature mismatch\nCause: Public/private key pair mismatch\nCheck: Verify SUPublicEDKey matches key used for signing\nFix: Regenerate key pair, update Info.plist, re-sign and re-release\n\nIssue: Update not offered to users\nCause: BUILD_NUMBER not greater than previous\nCheck: Compare current and previous CFBundleVersion\nFix: Increment BUILD_NUMBER, create new release\n\nIssue: \"App is damaged\" on user machine\nCause: Signature/notarization issue, or improper extraction\nCheck: spctl -a -t exec -vv App.app (should show Notarized Developer ID)\nFix: Re-sign, re-notarize, ensure user extracts with ditto or Archive Utility (not unzip)\n\nROLLBACK PROCEDURE (if release is broken):\n1. Delete GitHub release: gh release delete vVERSION --yes\n2. Remove local tag: git tag -d vVERSION\n3. Remove remote tag: git push origin :refs/tags/vVERSION\n4. Remove appcast entry: Edit appcast.xml, remove item, commit\n5. Fix issue in code\n6. Re-run release process with same or new version\n\nDRY RUN (test without publishing):\n./Scripts/release.sh --dry-run\nSimulates entire process without: uploading to GitHub, pushing tags, updating remote appcast\nUse to verify: build succeeds, signing works, notarization succeeds, appcast generates correctly\n\nPRE-RELEASE CHECKLIST:\n- [ ] All features tested and working\n- [ ] All tests passing (swift test)\n- [ ] Documentation updated\n- [ ] CHANGELOG.md updated with this version\n- [ ] version.env bumped (BUILD_NUMBER increased)\n- [ ] All required env vars set\n- [ ] Git working tree clean (no uncommitted changes)\n- [ ] Release notes written\n\nPOST-RELEASE VERIFICATION:\n- [ ] GitHub release exists with correct version\n- [ ] .zip and .dSYM.zip assets downloadable\n- [ ] appcast.xml has new item with correct signature\n- [ ] Git tag created and pushed\n- [ ] Curl SUFeedURL returns 200\n- [ ] Download and test on clean Mac\n- [ ] Previous version can detect and install update\n\nDOCUMENTATION: Create docs/RELEASE_PROCESS.md with complete procedure, include screenshots, example commands, troubleshooting section.\n\nFREQUENCY: Release when: critical bugs fixed, significant features added, security patches needed, user requests addressed.\n\nSUCCESS: Documented process anyone can follow, clear troubleshooting steps, rollback procedure tested, dry-run option available","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:08:00.679617-05:00","updated_at":"2025-12-27T18:05:15.422534-05:00","closed_at":"2025-12-27T18:05:15.422534-05:00","close_reason":"Closed","dependencies":[{"issue_id":"oc-c9x.10","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:08:00.680255-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.10","depends_on_id":"oc-c9x.7","type":"blocks","created_at":"2025-12-12T23:54:10.48699-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":23,"issue_id":"oc-c9x.10","author":"Chris Edwards","text":"Created RELEASE_PROCESS.md with step-by-step release guide. Commit: 7dc8064","created_at":"2025-12-27T23:05:10Z"}]}
{"id":"oc-c9x.11","title":"Document Common Gotchas and Solutions","description":"BACKGROUND: Release process has many potential failure points. Documenting common issues with solutions prevents frustration and speeds up releases.\n\nPROBLEM: Cryptic errors halt releases, unclear root causes, time wasted debugging known issues, repeated mistakes across releases.\n\nCOMMON GOTCHAS AND SOLUTIONS:\n\n1. SPARKLE KEY FORMAT ERROR\n   Issue: sign_update fails \"invalid key format\" or \"could not parse key\"\n   Cause: Private key has PEM headers, comments, or line breaks\n   Solution: Convert to single-line base64 without headers\n   Command: cat sparkle_private_key.pem | grep -v \"BEGIN\\|END\\|PRIVATE KEY\" | base64 | tr -d newline whitespace \u003e sparkle_key_clean.txt\n   Verification: wc -l key.txt (should output \"0\" for single line)\n\n2. BUNDLE IDENTIFIER MISMATCH\n   Issue: Notarization fails \"bundle ID does not match certificate\"\n   Cause: Info.plist CFBundleIdentifier differs from certificate or appcast\n   Solution: Verify consistency everywhere (Info.plist, signing cert, appcast.xml)\n   Check: codesign -d -r- App.app (shows designated requirement with bundle ID)\n   Fix: Update Info.plist to match certificate, or regenerate cert to match bundle ID\n\n3. APPLEDOUBLE FILES BREAK SIGNATURES\n   Issue: \"App is damaged and cannot be opened\" on user Mac\n   Cause: zip command creates ._ metadata files that corrupt signature\n   Solution: Always use ditto, never use zip command\n   Command: ditto -c -k --keepParent App.app App.zip (correct)\n   NOT: zip -r App.zip App.app (creates AppleDouble files)\n   Cleanup: xattr -cr App.app \u0026\u0026 find App.app -name \"._*\" -delete (before signing)\n\n4. SIGNATURE VERIFICATION FAILS\n   Issue: codesign --verify fails \"invalid signature\" or \"code object is not signed at all\"\n   Cause: App modified after signing, wrong architecture, missing frameworks\n   Solutions: Re-sign after any changes, use --deep flag, verify framework signatures\n   Verification: codesign --verify --deep --strict --verbose=4 App.app (detailed output)\n   Common: Editing Info.plist after signing invalidates signature (sign last)\n\n5. BUILD NUMBER NOT INCREASING\n   Issue: Sparkle does not offer update to users\n   Cause: CFBundleVersion not strictly greater than previous release\n   Solution: BUILD_NUMBER in version.env must increment (5→6, not 5→5)\n   Sparkle rule: Compares CFBundleVersion as integer, ignores CFBundleShortVersionString\n   Check: Previous release CFBundleVersion, ensure new is higher\n   Example: 1.0.0 (build 5) to 1.0.1 (build 6) ✓, not 1.0.1 (build 5) ✗\n\n6. GATEKEEPER REJECTION\n   Issue: \"cannot be opened because developer cannot be verified\"\n   Cause: Not notarized, notarization ticket not stapled, or signature invalid\n   Solutions: Notarize via xcrun notarytool, staple ticket via xcrun stapler, verify with spctl\n   Verification: spctl -a -t exec -vv App.app (should show \"source=Notarized Developer ID\")\n   User workaround: Right-click \u003e Open (bypasses Gatekeeper), but should not be needed\n\n7. HARDENED RUNTIME CRASHES\n   Issue: App crashes after signing with hardened runtime\n   Cause: Missing entitlements for JIT, DYLD environment variables, or executable memory\n   Solution: Add required entitlements to .entitlements file\n   Example: com.apple.security.cs.allow-jit for JIT compilation\n   Entitlements: Pass via codesign --entitlements file.entitlements\n\n8. NOTARIZATION TIMEOUT\n   Issue: xcrun notarytool submit hangs or times out\n   Cause: Network issues, Apple service outage, submission queue backup\n   Solutions: Retry after 5 minutes, check developer.apple.com/system-status\n   Check log: xcrun notarytool log --id SUBMISSION_ID (after submit completes)\n   Alternative: Submit without --wait, check status separately with notarytool history\n\n9. WRONG CERTIFICATE TYPE\n   Issue: codesign succeeds but notarization fails \"invalid signing certificate\"\n   Cause: Using \"Mac App Distribution\" or \"Apple Development\" instead of \"Developer ID Application\"\n   Solution: Generate correct certificate type at developer.apple.com\n   Verification: security find-identity -v -p codesigning (look for \"Developer ID Application\")\n   Note: Three cert types exist, only \"Developer ID Application\" works for outside-MAS distribution\n\n10. APPCAST URL 404\n   Issue: Sparkle logs \"Feed not found\" or \"Invalid feed URL\"\n   Cause: Wrong URL in Info.plist, appcast.xml not committed/pushed, GitHub repo private\n   Solutions: Verify SUFeedURL with curl, ensure appcast.xml committed to main branch, verify repo public\n   GitHub raw URL format: https://raw.githubusercontent.com/USER/REPO/main/appcast.xml\n   Test: curl -I URL (should return 200 OK, not 404)\n\n11. SPARKLE SIGNATURE MISMATCH\n   Issue: Update downloads but fails installation \"Signature validation failed\"\n   Cause: Public key in Info.plist does not match private key used for signing\n   Solution: Regenerate key pair, update SUPublicEDKey, re-sign all releases\n   Prevention: Keep public/private key pair together, document which key is for which app\n\n12. EXTRACTION METHOD MATTERS\n   Issue: User extracts zip, gets \"damaged app\" even though notarized\n   Cause: unzip command-line tool can corrupt macOS resource forks\n   Solution: Users should use Archive Utility (double-click) or ditto -x -k\n   Documentation: Include extraction instructions in README or release notes\n\nDEBUGGING TOOLS AND COMMANDS:\n- Code signature details: codesign -dvvv --entitlements - App.app\n- Gatekeeper test: spctl -a -t exec -vv App.app\n- Notarization log: xcrun notarytool log --id ID --key/--key-id/--issuer\n- Find certificates: security find-identity -v -p codesigning\n- Check bundle ID: defaults read App.app/Contents/Info.plist CFBundleIdentifier\n- Test appcast: curl -v SUFeedURL\n- Verify zip contents: ditto -x -k App.zip /tmp/test \u0026\u0026 ls -la /tmp/test\n- Check AppleDouble files: find App.app -name \"._*\"\n\nPREVENTION CHECKLIST:\n- [ ] Use ditto not zip for all archiving\n- [ ] Run xattr -cr before signing\n- [ ] Sign with --deep --options runtime --timestamp\n- [ ] Verify signature before notarization\n- [ ] Use Developer ID Application cert\n- [ ] Increment BUILD_NUMBER for every release\n- [ ] Staple notarization ticket\n- [ ] Test on clean Mac before announcing\n- [ ] Document extraction method for users\n\nDOCUMENTATION: Create docs/RELEASE_GOTCHAS.md with: comprehensive list, root cause analysis, step-by-step solutions, prevention tips, debugging commands.\n\nSUCCESS: All common issues documented, clear solutions provided, debugging tools listed, prevention checklist available","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:08:19.667567-05:00","updated_at":"2025-12-27T18:05:15.425894-05:00","closed_at":"2025-12-27T18:05:15.425894-05:00","close_reason":"Closed","dependencies":[{"issue_id":"oc-c9x.11","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:08:19.668173-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.11","depends_on_id":"oc-c9x.7","type":"blocks","created_at":"2025-12-12T23:54:11.001447-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":24,"issue_id":"oc-c9x.11","author":"Chris Edwards","text":"Created RELEASE_GOTCHAS.md documenting 12 common issues with solutions. Commit: 7dc8064","created_at":"2025-12-27T23:05:10Z"}]}
{"id":"oc-c9x.12","title":"Phase 7 Verification Checklist","description":"BACKGROUND: Comprehensive verification checklist ensures Phase 7 release infrastructure is complete and functional before first production release.\n\nPROBLEM: Missing verification means broken releases reach users, incomplete setup causes failures mid-release, untested components fail in production.\n\nVERIFICATION CHECKLIST (complete before Phase 7 sign-off):\n\nCODE SIGNATURE VERIFICATION:\n- [ ] codesign --verify --deep --strict App.app exits with code 0\n- [ ] codesign -dvvv App.app shows \"Authority=Developer ID Application\"\n- [ ] codesign shows \"Signature=adhoc\" is NOT present (must be real signature)\n- [ ] codesign shows flags include \"runtime\" (hardened runtime enabled)\n- [ ] codesign shows TeamIdentifier matches expected value\n- [ ] No unsigned frameworks: codesign --verify --deep succeeds for all embedded frameworks\n\nGATEKEEPER VERIFICATION:\n- [ ] spctl -a -t exec -vv App.app exits with code 0\n- [ ] spctl output shows \"source=Notarized Developer ID\"\n- [ ] spctl output shows \"origin=Developer ID Application: YOUR NAME\"\n- [ ] Download on clean Mac (no development tools) opens without warnings\n- [ ] First launch shows no \"unidentified developer\" dialog\n- [ ] App runs normally after Gatekeeper verification\n\nNOTARIZATION VERIFICATION:\n- [ ] stapler validate App.app exits with code 0\n- [ ] stapler output shows \"The validate action worked\"\n- [ ] codesign -dvvv shows notarization ticket attached\n- [ ] xcrun notarytool history shows successful submission\n- [ ] Notarization log (notarytool log --id) shows no errors\n- [ ] Offline verification works (test with network disabled)\n\nSPARKLE INTEGRATION:\n- [ ] Help \u003e Check for Updates menu item appears in production build\n- [ ] No Sparkle dialogs in development builds (swift run)\n- [ ] UpdaterWrapper logs \"Disabled\" for unsigned builds\n- [ ] UpdaterWrapper logs \"Enabled\" for signed production builds\n- [ ] SPUStandardUpdaterController initializes without errors in production\n- [ ] No crashes related to Sparkle framework loading\n\nAPPCAST VERIFICATION:\n- [ ] appcast.xml validates: xmllint --noout appcast.xml exits 0\n- [ ] appcast.xml accessible: curl SUFeedURL returns HTTP 200\n- [ ] Latest version item has sparkle:edSignature attribute\n- [ ] Enclosure URL returns HTTP 200 (asset is downloadable)\n- [ ] Enclosure length attribute matches actual file size: stat -f%z App.zip\n- [ ] Sparkle namespace declared correctly in RSS element\n- [ ] Items ordered newest first (descending by version)\n\nGITHUB RELEASE VERIFICATION:\n- [ ] Release exists: gh release view vVERSION succeeds\n- [ ] .zip asset present: gh release view vVERSION | grep \".zip\"\n- [ ] .dSYM.zip asset present for crash symbolication\n- [ ] Release notes from CHANGELOG.md appear correctly\n- [ ] Assets publicly downloadable (test unauthenticated)\n- [ ] Git tag exists: git tag -l | grep vVERSION\n- [ ] Tag pushed to remote: git ls-remote --tags origin | grep vVERSION\n\nINFO.PLIST CONFIGURATION:\n- [ ] SUFeedURL set and points to appcast.xml\n- [ ] SUFeedURL uses HTTPS (not HTTP)\n- [ ] SUPublicEDKey matches private key used for signing\n- [ ] SUEnableInstallerLauncherService is true\n- [ ] CFBundleVersion is integer (not string)\n- [ ] CFBundleVersion greater than previous release\n- [ ] CFBundleShortVersionString matches MARKETING_VERSION\n- [ ] All required keys present: defaults read App.app/Contents/Info.plist SUFeedURL\n\nENVIRONMENT SETUP:\n- [ ] All required env vars documented in docs/\n- [ ] .env.local template provided\n- [ ] Scripts have executable permissions: ls -l Scripts/*.sh\n- [ ] Prerequisites documented (Apple Developer Program, certificates)\n- [ ] Private keys stored securely (not in git)\n- [ ] API credentials tested and valid\n\nUPDATE MECHANISM (end-to-end test):\n- [ ] Install previous version on test Mac\n- [ ] Release new version with higher build number\n- [ ] Previous version detects update (check logs or manual trigger)\n- [ ] Update downloads successfully\n- [ ] Signature verification passes\n- [ ] Update installs without errors\n- [ ] Post-update app launches successfully\n- [ ] Post-update app is signed and notarized (verify with codesign/spctl)\n\nDOCUMENTATION COMPLETE:\n- [ ] Release process documented with step-by-step instructions\n- [ ] Common gotchas documented with solutions\n- [ ] Troubleshooting guide covers all known issues\n- [ ] Example commands provided for verification\n- [ ] Environment variables documented\n- [ ] Rollback procedure documented\n- [ ] Prerequisites checklist available\n\nSCRIPTS FUNCTIONAL:\n- [ ] sign-and-notarize.sh completes without errors\n- [ ] release.sh completes entire workflow\n- [ ] check-release-assets.sh verifies all assets\n- [ ] All scripts handle errors gracefully\n- [ ] Scripts log meaningful progress messages\n- [ ] Dry-run mode works (--dry-run flag)\n\nFINAL END-TO-END TEST:\n- [ ] Fresh Mac: Download .zip from GitHub release URL\n- [ ] Extract: Double-click or use ditto -x -k (not unzip)\n- [ ] Open: No Gatekeeper warnings\n- [ ] Launch: App starts normally\n- [ ] Check updates: Help \u003e Check for Updates works\n- [ ] All features: Transform clipboard, paste, hotkeys all functional\n- [ ] Logs: No errors in Console.app for app\n- [ ] Update: Can successfully update to newer test version\n\nSECURITY VERIFICATION:\n- [ ] Private keys not committed to git\n- [ ] .gitignore includes .env.local and key files\n- [ ] API credentials have minimal required permissions\n- [ ] Certificates not expired (check expiration dates)\n- [ ] Sparkle signature verification working\n- [ ] HTTPS used for all URLs (no HTTP)\n\nPERFORMANCE VERIFICATION:\n- [ ] App launch time acceptable (\u003c2s)\n- [ ] Update check non-blocking (app responsive during check)\n- [ ] Download progress shown for large updates\n- [ ] Failed update handled gracefully (network error)\n- [ ] No memory leaks in Sparkle integration\n\nREGRESSION TESTING:\n- [ ] Run full test suite before release: swift test\n- [ ] Manual testing on different macOS versions (13, 14, 15)\n- [ ] Test with different default apps\n- [ ] Test under load (rapid transformations)\n- [ ] Test error scenarios (network failures, permission denials)\n\nDEFINITION OF DONE:\nPhase 7 is complete when ALL checklist items above are checked and verified. No shortcuts. This ensures production-ready release infrastructure.\n\nINDEPENDENT VERIFICATION:\nHave another developer (or yourself on different machine) follow release process documentation and verify:\n- [ ] Can release from clean environment\n- [ ] Instructions are clear and complete\n- [ ] All tools and credentials available\n- [ ] Process completes successfully\n- [ ] Released app works on their machine\n\nSIGN-OFF:\n- [ ] All checkboxes above verified\n- [ ] Documentation complete and reviewed\n- [ ] Scripts tested and functional\n- [ ] First test release successful\n- [ ] Ready for production releases\n\nSUCCESS CRITERIA: Every checkbox checked, every verification passed, documentation reviewed, test release successful, Phase 7 complete.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:08:37.851553-05:00","updated_at":"2025-12-27T18:05:15.429252-05:00","closed_at":"2025-12-27T18:05:15.429252-05:00","close_reason":"Closed","dependencies":[{"issue_id":"oc-c9x.12","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:08:37.852274-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.12","depends_on_id":"oc-c9x.3","type":"blocks","created_at":"2025-12-12T23:54:11.709779-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.12","depends_on_id":"oc-c9x.8","type":"blocks","created_at":"2025-12-12T23:54:12.276272-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.12","depends_on_id":"oc-c9x.9","type":"blocks","created_at":"2025-12-12T23:54:12.769432-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.12","depends_on_id":"oc-c9x.10","type":"blocks","created_at":"2025-12-12T23:54:13.263509-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.12","depends_on_id":"oc-c9x.11","type":"blocks","created_at":"2025-12-12T23:54:13.861721-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.12","depends_on_id":"oc-c9x.7","type":"blocks","created_at":"2025-12-14T22:28:56.980627-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":25,"issue_id":"oc-c9x.12","author":"Chris Edwards","text":"Created RELEASE_CHECKLIST.md with comprehensive verification checklist. Commit: 7dc8064","created_at":"2025-12-27T23:05:10Z"}]}
{"id":"oc-c9x.2","title":"Add Sparkle Framework Dependency","description":"BACKGROUND \u0026 CONTEXT:\nSparkle is the industry-standard automatic update framework for macOS applications distributed outside the Mac App Store. It has been battle-tested for over 15 years and is used by thousands of macOS apps including major titles like Sketch, Tower, Sequel Pro, and Transmission. Sparkle provides automatic update checks, secure downloads, signature verification, and native macOS UI for the update process.\n\nREAL-WORLD PROBLEM/USE CASE:\nWithout automatic updates, users must manually check for new versions, download the updated app, replace the old version, and restart. This creates several problems:\n- Users miss important bug fixes and security patches\n- Adoption of new features is slow\n- Support burden increases (users running old versions with known issues)\n- No analytics on update adoption rates\n- Manual distribution is error-prone\n\nWith Sparkle, when you release OptimusClip 1.0.1 with a critical bug fix, users on 1.0.0 will automatically be notified the next time they launch the app. They can update with a single click, and the framework handles download, verification, installation, and restart.\n\nWHY SPARKLE SPECIFICALLY:\n1. Security: Uses ed25519 cryptographic signatures to verify updates are authentic\n2. Native UI: Provides standard macOS update dialogs users expect\n3. Background updates: Can download and prepare updates in the background\n4. Delta updates: Supports binary diffs to reduce download sizes (optional)\n5. Open source: Fully auditable, actively maintained\n6. SPM support: Version 2.8+ has official Swift Package Manager support\n7. macOS integration: Respects system preferences, handles permissions correctly\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. ADD TO PACKAGE.SWIFT DEPENDENCIES:\n   Add Sparkle to the dependencies array and to the OptimusClip target.\n   Use from: 2.8.0 (minimum version with SPM support).\n\n2. VERSION SELECTION:\n   - Use: from: 2.8.0 (minimum version with SPM support)\n   - Latest stable: 2.8.2+\n   - Do NOT pin exact version - allows automatic minor/patch updates\n   - Sparkle follows semantic versioning strictly\n\n3. VERIFICATION AFTER ADDING:\n   swift package resolve\n   ls .build/checkouts/Sparkle\n   swift build\n\n4. SPARKLE FRAMEWORK STRUCTURE:\n   - SPUStandardUpdaterController: High-level update controller (what we'll use)\n   - SPUUpdater: Lower-level updater (for custom UI)\n   - SPUUpdaterDelegate: Delegate protocol for customization\n   - Signing tools: generate_keys, sign_update (command-line tools)\n\n5. WHAT GETS INCLUDED IN BUILD:\n   - Sparkle.framework embedded in app bundle\n   - XPC services for secure updates\n   - Localized strings for update UI\n   - Total size: ~2MB added to app bundle\n\nARCHITECTURAL CONNECTIONS:\n- Phase 0: Added to Package.swift dependencies\n- Phase 7: Used by UpdaterWrapper (next task)\n- Info.plist: Requires SUFeedURL and SUPublicEDKey configuration\n- Release process: sign_update tool used to generate signatures\n- Distribution: Only active in signed, production builds\n\nSECURITY CONSIDERATIONS:\n- Signature verification with ed25519\n- Public key in Info.plist, private key for releases\n- HTTPS required for SUFeedURL\n- Prevents man-in-the-middle attacks\n- XPC services provide sandboxing\n\nPERFORMANCE CONSIDERATIONS:\n- Launch time: 100-500ms async update check\n- Memory: ~2MB framework, ~1MB during check\n- Disk: ~2MB in app bundle\n- Network: 5-10KB appcast, full app size for updates\n\nEDGE CASES \u0026 GOTCHAS:\n- SPM caching: Use swift package reset if needed\n- Framework embedding: Verify in Contents/Frameworks\n- Debug vs release: Framework present but inactive in dev\n- No dependency conflicts expected\n\nTESTING REQUIREMENTS:\n- swift package resolve succeeds\n- swift build completes without errors\n- import Sparkle compiles\n- .build/checkouts/Sparkle exists\n- Framework embedded in packaged app\n\nSUCCESS CRITERIA:\n✓ Package.swift includes Sparkle dependency\n✓ Build succeeds with Sparkle linked\n✓ No console warnings\n✓ Sparkle.framework in app bundle\n✓ App launches without dyld errors\n\nPRIORITY: P2 (foundation for Phase 7 automatic updates)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:25.787795-05:00","updated_at":"2025-12-27T17:29:58.192233-05:00","closed_at":"2025-12-27T17:29:58.192233-05:00","close_reason":"Closed","dependencies":[{"issue_id":"oc-c9x.2","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:05:25.788321-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.2","depends_on_id":"oc-c9x.1","type":"blocks","created_at":"2025-12-12T23:54:04.214377-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":18,"issue_id":"oc-c9x.2","author":"Chris Edwards","text":"Added Sparkle 2.8.0+ to Package.swift. Resolved to 2.8.1. Build succeeds, all 273 tests pass. Sparkle.framework included in build artifacts. Commit: 7e52669","created_at":"2025-12-27T22:29:54Z"}]}
{"id":"oc-c9x.3","title":"Implement UpdaterWrapper with Conditional Sparkle Initialization","description":"## Task: Implement UpdaterWrapper with Conditional Sparkle Initialization\n\n### Background \u0026 The Problem\n\nSparkle (the macOS auto-update framework) is essential for production distribution but problematic during development:\n\n**Problems During Development:**\n1. **Unwanted Update Dialogs**: \"A new version is available\" popups interrupt coding\n2. **Failed Update Checks**: Unsigned builds cause Sparkle errors/crashes\n3. **Network Requests**: Unnecessary traffic to appcast feed\n4. **Console Spam**: Sparkle logs warnings about missing signatures\n5. **CI/CD Issues**: Automated tests fail when Sparkle tries to check updates\n\n**The Solution:**\nCreate an `UpdaterWrapper` that conditionally enables Sparkle ONLY when running as a properly signed, production app bundle.\n\n### Why Not Just Disable in Debug Builds?\n\nYou might think: \"Just use `#if DEBUG` to disable Sparkle\"\n\n**Problems with This Approach:**\n1. **Archive builds**: Release archives for testing would have updates disabled\n2. **TestFlight/Ad-hoc**: Beta distributions wouldn't get updates\n3. **SwiftPM quirk**: SwiftPM doesn't define DEBUG by default\n\n**Better Approach: Runtime Detection**\n- Check if running as `.app` bundle (not `swift run`)\n- Verify the bundle is signed with Developer ID certificate\n- Only then enable Sparkle\n\n### Technical Implementation\n\n```swift\nimport Foundation\nimport Sparkle\n\n/// Wrapper that conditionally enables Sparkle only for signed, bundled builds.\n/// Prevents update dialogs during development while ensuring production builds auto-update.\n@MainActor\nfinal class UpdaterWrapper: ObservableObject {\n    /// The Sparkle updater controller (nil if updates disabled)\n    private var controller: SPUStandardUpdaterController?\n\n    /// The underlying Sparkle updater for advanced operations\n    var updater: SPUUpdater? { controller?.updater }\n\n    /// Whether update checking is available (false during development)\n    var canCheckForUpdates: Bool { controller != nil }\n\n    init() {\n        guard shouldEnableUpdater() else {\n            print(\"[UpdaterWrapper] Updates disabled (development build)\")\n            return\n        }\n\n        controller = SPUStandardUpdaterController(\n            startingUpdater: true,\n            updaterDelegate: nil,\n            userDriverDelegate: nil\n        )\n        print(\"[UpdaterWrapper] Updates enabled (production build)\")\n    }\n\n    /// Determine if Sparkle should be enabled based on runtime conditions\n    private func shouldEnableUpdater() -\u003e Bool {\n        // Condition 1: Must be running as an app bundle\n        let bundle = Bundle.main\n        guard bundle.bundleURL.pathExtension == \"app\" else {\n            print(\"[UpdaterWrapper] Not an app bundle\")\n            return false\n        }\n\n        // Condition 2: Must be signed with Developer ID\n        guard isSignedWithDeveloperID(bundle.bundleURL) else {\n            print(\"[UpdaterWrapper] Not signed with Developer ID\")\n            return false\n        }\n\n        return true\n    }\n\n    /// Verify the app is signed with our Developer ID certificate\n    private func isSignedWithDeveloperID(_ url: URL) -\u003e Bool {\n        var code: SecStaticCode?\n        let createStatus = SecStaticCodeCreateWithPath(url as CFURL, [], \u0026code)\n\n        guard createStatus == errSecSuccess, let code = code else {\n            return false\n        }\n\n        // Requirement: Signed by Apple and our specific team\n        // IMPORTANT: Replace YOUR_TEAM_ID with your actual Apple Developer Team ID\n        // Find it with: security find-identity -v -p codesigning\n        let requirement = \"anchor apple generic and certificate leaf[subject.OU] = \\\"YOUR_TEAM_ID\\\"\"\n\n        var req: SecRequirement?\n        guard SecRequirementCreateWithString(requirement as CFString, [], \u0026req) == errSecSuccess,\n              let req = req else {\n            return false\n        }\n\n        return SecStaticCodeCheckValidity(code, [], req) == errSecSuccess\n    }\n\n    // MARK: - Public API\n\n    /// Check for updates manually\n    func checkForUpdates() {\n        guard let updater = updater else { return }\n        updater.checkForUpdates()\n    }\n\n    /// Check for updates in the background\n    func checkForUpdatesInBackground() {\n        guard let updater = updater else { return }\n        updater.checkForUpdatesInBackground()\n    }\n}\n```\n\n### Finding Your Team ID\n\n**Method 1: Keychain Access**\n```bash\nsecurity find-identity -v -p codesigning\n```\nOutput: `1) ABC123DEF4 \"Developer ID Application: Your Name (ABC123DEF4)\"`\n\nThe Team ID is in parentheses at the end: `ABC123DEF4`\n\n**Method 2: Apple Developer Portal**\n1. Go to https://developer.apple.com/account\n2. Look at the URL or membership details\n3. Team ID shown in format `ABC123DEF4`\n\n### Integration with App\n\n```swift\n@main\nstruct OptimusClipApp: App {\n    // IMPORTANT: Use @StateObject, not @State\n    // This ensures single instance for app lifecycle\n    @StateObject private var updaterWrapper = UpdaterWrapper()\n\n    var body: some Scene {\n        MenuBarExtra(\"Optimus Clip\", systemImage: \"clipboard\") {\n            // Only show \"Check for Updates\" if available\n            if updaterWrapper.canCheckForUpdates {\n                Button(\"Check for Updates...\") {\n                    updaterWrapper.checkForUpdates()\n                }\n                Divider()\n            }\n\n            Button(\"Settings...\") {\n                // Open settings\n            }\n            .keyboardShortcut(\",\", modifiers: .command)\n\n            Divider()\n\n            Button(\"Quit\") {\n                NSApplication.shared.terminate(nil)\n            }\n            .keyboardShortcut(\"q\", modifiers: .command)\n        }\n    }\n}\n```\n\n### Scenarios and Expected Behavior\n\n| Scenario | shouldEnableUpdater | Behavior |\n|----------|---------------------|----------|\n| `swift run` | false | No Sparkle, no menu item |\n| `swift build \u0026\u0026 .build/debug/OptimusClip` | false | No Sparkle (not in .app bundle) |\n| `OptimusClip.app` (unsigned) | false | No Sparkle (signature check fails) |\n| `OptimusClip.app` (ad-hoc signed) | false | No Sparkle (not Developer ID) |\n| `OptimusClip.app` (Developer ID) | true | Sparkle enabled, menu item visible |\n\n### Security Considerations\n\n**Why Check for Developer ID?**\n- Prevents update mechanism from activating in unverified builds\n- Ensures only properly signed releases can receive updates\n- Ad-hoc signed builds (for testing) do not auto-update\n- Prevents malicious builds from hijacking update mechanism\n\n**Code Signature Verification:**\n- `SecStaticCodeCreateWithPath` creates a code object from the bundle\n- `SecRequirementCreateWithString` compiles our requirement string\n- `SecStaticCodeCheckValidity` verifies the signature matches our requirement\n- This is the same verification macOS Gatekeeper uses\n\n### Gotchas \u0026 Common Issues\n\n**1. Team ID Not Replaced**\n```swift\n// WRONG - Will never match\nlet requirement = \"anchor apple generic and certificate leaf[subject.OU] = \\\"YOUR_TEAM_ID\\\"\"\n\n// CORRECT - Use your actual Team ID\nlet requirement = \"anchor apple generic and certificate leaf[subject.OU] = \\\"ABC123DEF4\\\"\"\n```\n\n**2. Using @State Instead of @StateObject**\n```swift\n// WRONG - Creates new instance on each view update\n@State private var updaterWrapper = UpdaterWrapper()\n\n// CORRECT - Single instance for app lifetime\n@StateObject private var updaterWrapper = UpdaterWrapper()\n```\n\n**3. Xcode Development Certificate**\n- Xcode's automatic signing uses a different certificate type\n- \"Apple Development\" certificate != \"Developer ID Application\"\n- Development builds will correctly show Sparkle disabled\n\n**4. Not Handling nil Controller**\n```swift\n// WRONG - Force unwrap will crash in development\nupdater!.checkForUpdates()\n\n// CORRECT - Guard against nil\nguard let updater = updater else { return }\nupdater.checkForUpdates()\n```\n\n### Testing Checklist\n\n- [ ] `swift run` - No Sparkle initialization logs, no menu item\n- [ ] Debug .app build (unsigned) - No Sparkle, no menu item\n- [ ] Signed release build - Sparkle enabled, menu item visible\n- [ ] Menu item calls checkForUpdates() without crash\n- [ ] Console shows appropriate debug messages\n- [ ] @StateObject maintains single instance\n- [ ] No memory leaks from retained controller\n\n### Success Criteria\n\n- [ ] Development builds have Sparkle completely disabled\n- [ ] Production (Developer ID signed) builds have Sparkle enabled\n- [ ] \"Check for Updates\" menu item only visible when Sparkle enabled\n- [ ] No crashes or errors in development builds\n- [ ] Team ID replaced with actual value\n- [ ] Singleton pattern with @StateObject\n- [ ] Clean console output indicating status\n\n### Architectural Connections\n\n- **Sparkle Framework Dependency (oc-c9x.2)**: This wrapper uses Sparkle\n- **Info.plist Configuration (oc-c9x.4)**: Sets SUFeedURL and SUPublicEDKey\n- **App Entry Point (oc-uzt.1)**: Integrates UpdaterWrapper\n- **Menu Bar Menu Items (oc-uzt.4)**: Adds conditional \"Check for Updates\"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:56.691911-05:00","updated_at":"2025-12-27T17:35:08.573137-05:00","closed_at":"2025-12-27T17:35:08.573137-05:00","close_reason":"Closed","dependencies":[{"issue_id":"oc-c9x.3","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:05:56.692475-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.3","depends_on_id":"oc-c9x.2","type":"blocks","created_at":"2025-12-12T23:54:05.043648-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":19,"issue_id":"oc-c9x.3","author":"Chris Edwards","text":"Implemented UpdaterWrapper with conditional Sparkle initialization. Runtime detection via bundle path extension and Developer ID signature check. Added conditional 'Check for Updates' menu item. All 273 tests pass. Commit: 09942e9. Note: Team ID is placeholder (YOUR_TEAM_ID) - needs to be updated during Phase 7 signing setup.","created_at":"2025-12-27T22:35:04Z"}]}
{"id":"oc-c9x.4","title":"Configure Info.plist for Sparkle","description":"BACKGROUND \u0026 CONTEXT:\nInfo.plist is the application's configuration manifest that macOS reads to understand bundle identity, capabilities, and integration points. For Sparkle auto-updates to function, three specific keys must be present in Info.plist that tell the framework:\n1. Where to check for updates (SUFeedURL)\n2. How to verify update authenticity (SUPublicEDKey)\n3. Whether to enable background update installation (SUEnableInstallerLauncherService)\n\nSparkle is an open-source framework for macOS app auto-updates. It uses RSS-based \"appcasts\" (XML feeds) to advertise new versions and ed25519 cryptographic signatures to prevent malicious update injection. The public key in Info.plist must match the private key used to sign releases, or updates will be rejected as tampered.\n\nInfo.plist is populated by Scripts/package_app.sh during bundle creation. The Sparkle keys should be added to the template Info.plist at repository root so they're included in every packaged build. Without these keys, UpdaterWrapper.swift will find no configuration and Sparkle will silently fail to initialize.\n\nREAL-WORLD PROBLEM/USE CASE:\nUser downloads OptimusClip v1.0.0 from GitHub. Two weeks later, you release v1.1.0 with bug fixes. Without Sparkle:\n1. User never learns about update\n2. Continues using buggy version\n3. Eventually encounters fixed bug, gets frustrated\n4. Searches GitHub for updates manually\n5. Downloads new version, drags to Applications, overwrites old version\n6. Tedious process discourages frequent updates\n\nWith Sparkle properly configured:\n1. App checks SUFeedURL daily for new versions\n2. Finds appcast.xml with v1.1.0 entry\n3. Downloads zip, verifies ed25519 signature against SUPublicEDKey\n4. Shows native macOS update dialog: \"Version 1.1.0 is available. Install and relaunch?\"\n5. User clicks \"Install\", app updates in background\n6. Relaunch shows new version, bug fixed\n7. Seamless, professional experience\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. REQUIRED KEYS STRUCTURE:\n```xml\n\u003c!-- Sparkle Auto-Update Configuration --\u003e\n\u003ckey\u003eSUFeedURL\u003c/key\u003e\n\u003cstring\u003ehttps://raw.githubusercontent.com/USERNAME/optimus-clip/main/appcast.xml\u003c/string\u003e\n\n\u003ckey\u003eSUPublicEDKey\u003c/key\u003e\n\u003cstring\u003eYOUR_BASE64_ED25519_PUBLIC_KEY_HERE\u003c/string\u003e\n\n\u003ckey\u003eSUEnableInstallerLauncherService\u003c/key\u003e\n\u003ctrue/\u003e\n```\n\n2. SUFeedURL REQUIREMENTS:\n* Must be HTTPS (not HTTP) - Sparkle rejects insecure URLs\n* Must return valid XML with Content-Type: application/xml or text/xml\n* GitHub raw content URL format: https://raw.githubusercontent.com/USER/REPO/BRANCH/appcast.xml\n* Must be publicly accessible (no authentication required)\n* URL should match repository structure (main vs master branch)\n\n3. GENERATING SPARKLE KEYS:\nThe Sparkle framework includes a generate_keys tool for creating ed25519 key pairs:\n```bash\n# Download Sparkle from GitHub releases\ncurl -LO https://github.com/sparkle-project/Sparkle/releases/download/2.8.0/Sparkle-2.8.0.tar.xz\ntar xf Sparkle-2.8.0.tar.xz\n\n# Generate key pair\n./bin/generate_keys\n\n# Output:\n# Public key (copy to Info.plist SUPublicEDKey):\n# abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOP=\n# \n# Private key (save to secure location, never commit to git):\n# -----BEGIN PRIVATE KEY-----\n# ... base64 content ...\n# -----END PRIVATE KEY-----\n```\n\nStore private key in:\n* Environment variable: `SPARKLE_PRIVATE_KEY_FILE=/path/to/sparkle-private-key`\n* Outside repository (never commit to git)\n* Secure location with restricted permissions (chmod 600)\n\n4. INFO.PLIST TEMPLATE LOCATION:\nThe template at repository root should include placeholder text:\n```xml\n\u003c!-- Sparkle Configuration --\u003e\n\u003ckey\u003eSUFeedURL\u003c/key\u003e\n\u003cstring\u003ehttps://raw.githubusercontent.com/REPLACE_USERNAME/optimus-clip/main/appcast.xml\u003c/string\u003e\n\n\u003ckey\u003eSUPublicEDKey\u003c/key\u003e\n\u003cstring\u003eREPLACE_WITH_GENERATED_PUBLIC_KEY\u003c/string\u003e\n\n\u003ckey\u003eSUEnableInstallerLauncherService\u003c/key\u003e\n\u003ctrue/\u003e\n```\n\nDuring setup, replace REPLACE_USERNAME and REPLACE_WITH_GENERATED_PUBLIC_KEY with actual values.\n\n5. VERIFICATION AFTER PACKAGING:\n```bash\n# Package app with updated Info.plist\n./Scripts/package_app.sh debug\n\n# Verify keys present in bundle\ndefaults read OptimusClip.app/Contents/Info.plist SUFeedURL\n# Output: https://raw.githubusercontent.com/...\n\ndefaults read OptimusClip.app/Contents/Info.plist SUPublicEDKey\n# Output: base64 key string\n\ndefaults read OptimusClip.app/Contents/Info.plist SUEnableInstallerLauncherService\n# Output: 1\n\n# Validate plist structure\nplutil -lint OptimusClip.app/Contents/Info.plist\n# Output: OptimusClip.app/Contents/Info.plist: OK\n\n# Test feed URL accessibility\ncurl -I $(defaults read OptimusClip.app/Contents/Info.plist SUFeedURL)\n# Output: HTTP/2 200 (or 404 if appcast not created yet)\n```\n\nARCHITECTURAL CONNECTIONS:\n* Info.plist read by UpdaterWrapper.swift during initialization\n* SUFeedURL points to appcast.xml created by oc-c9x.5\n* SUPublicEDKey verifies signatures generated by sign-and-notarize.sh (oc-c9x.6)\n* Keys survive package_app.sh script execution (template → bundle)\n* Sparkle dependency added in Package.swift (Phase 7.1)\n* UpdaterWrapper checks bundle signature before enabling Sparkle\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. HTTPS ENFORCEMENT:\n   * Sparkle rejects HTTP URLs (security requirement)\n   * GitHub raw content is always HTTPS (safe)\n   * Self-hosted feeds must have valid SSL certificate\n   * localhost feeds won't work in production\n\n2. PUBLIC KEY FORMATTING:\n   * Must be single line, no whitespace or newlines\n   * Base64 encoded (usually 44-88 characters)\n   * No \"-----BEGIN PUBLIC KEY-----\" wrapper\n   * Case-sensitive, exact match required\n   * Copy entire string including trailing = if present\n\n3. KEY MISMATCH:\n   * Public key in Info.plist must match private key used for signing\n   * Mismatched keys cause signature verification failure\n   * Sparkle shows \"Update improperly signed\" error\n   * Users cannot install updates until keys fixed\n\n4. BRANCH NAME IN URL:\n   * GitHub repositories use \"main\" or \"master\" as default branch\n   * URL must match actual branch name\n   * Wrong branch → 404 error when checking for updates\n   * Verify with: `git remote show origin | grep \"HEAD branch\"`\n\n5. USERNAME/REPO IN URL:\n   * URL must match GitHub repository location\n   * Forked repositories have different usernames\n   * Private repositories require authentication (won't work)\n   * Verify URL in browser before committing\n\n6. PLIST VALIDATION:\n   * XML syntax errors break app launch\n   * Unclosed tags cause parsing failure\n   * Always run plutil -lint after editing\n   * Xcode validates automatically but scripts don't\n\n7. CASE SENSITIVITY:\n   * Sparkle key names are case-sensitive\n   * SUFeedURL not sufeedurl\n   * Boolean must be \u003ctrue/\u003e not \"true\" or 1\n\nTESTING REQUIREMENTS:\n1. Keys present in packaged bundle: defaults read confirms all three keys\n2. Plist syntax valid: plutil -lint passes without errors\n3. Feed URL accessible: curl returns HTTP 200 or 404 (expected if appcast not created)\n4. Public key format: 44-88 character base64 string, no whitespace\n5. Keys survive packaging: package_app.sh preserves Sparkle configuration\n6. UpdaterWrapper initializes: App logs \"Sparkle enabled\" or \"Sparkle disabled (not signed)\"\n7. No launch errors: Console.app shows no plist parsing errors\n\nSUCCESS CRITERIA:\n- All three Sparkle keys added to Info.plist template\n- SUFeedURL uses HTTPS GitHub raw content URL\n- SUPublicEDKey contains valid base64 ed25519 public key\n- SUEnableInstallerLauncherService set to true\n- Private key saved securely outside repository\n- Keys survive package_app.sh execution\n- plutil -lint validation passes\n- No errors in Console.app after app launch\n- UpdaterWrapper can read configuration\n\nCONFIGURATION OPTIONS:\n* SUFeedURL: Can use custom domain instead of GitHub (requires HTTPS)\n* SUEnableAutomaticChecks: Optional, defaults to true (daily checks)\n* SUScheduledCheckInterval: Optional, seconds between checks (default 86400 = 1 day)\n* SUAllowsAutomaticUpdates: Optional, enable silent background updates\n\nPERFORMANCE CONSIDERATIONS:\n* Keys read once at app launch (negligible performance impact)\n* Feed URL checked daily in background (doesn't block UI)\n* No network calls if Sparkle disabled (dev builds)\n\nSECURITY CONSIDERATIONS:\n* Public key can be committed to git (designed to be public)\n* Private key must NEVER be committed (grants signing authority)\n* Use strong key storage for private key (1Password, encrypted disk)\n* Rotate keys if private key compromised (requires re-signing all releases)\n* HTTPS prevents man-in-the-middle feed tampering\n\nIMPLEMENTATION ORDER:\n1. Download Sparkle, run generate_keys, save output\n2. Store private key in secure location outside repository\n3. Add three Sparkle keys to Info.plist template\n4. Replace REPLACE_USERNAME with actual GitHub username\n5. Replace REPLACE_WITH_GENERATED_PUBLIC_KEY with generated public key\n6. Run package_app.sh to create bundle\n7. Verify keys with defaults read commands\n8. Test plutil -lint validation\n9. Test curl SUFeedURL accessibility\n10. Commit updated Info.plist to repository\n\nCODE ORGANIZATION:\n/Users/chrisedwards/projects/oss/optimus-clip/Info.plist (template)\n/Users/chrisedwards/projects/oss/optimus-clip/Scripts/package_app.sh (reads template)\n/Users/chrisedwards/projects/oss/optimus-clip/OptimusClip.app/Contents/Info.plist (output)\n/secure/location/sparkle-private-key (outside repo, never commit)\n\nPRIORITY: P2 (Required before Sparkle can function)\n\nESTIMATED TIME: 15-20 minutes (generate keys, update plist, verify)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:21.290067-05:00","updated_at":"2025-12-27T17:59:10.362598-05:00","closed_at":"2025-12-27T17:59:10.362598-05:00","close_reason":"Closed","dependencies":[{"issue_id":"oc-c9x.4","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:06:21.290695-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.4","depends_on_id":"oc-c9x.2","type":"blocks","created_at":"2025-12-12T23:54:05.592543-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":20,"issue_id":"oc-c9x.4","author":"Chris Edwards","text":"Added Sparkle configuration to Info.plist: SUFeedURL (GitHub raw), SUPublicEDKey (generated, private key in Keychain), SUEnableInstallerLauncherService. Plist validates with plutil. All 273 tests pass. Commit: c6e577e","created_at":"2025-12-27T22:59:06Z"}]}
{"id":"oc-c9x.5","title":"Create Initial appcast.xml File","description":"BACKGROUND \u0026 CONTEXT:\nappcast.xml is an RSS 2.0 feed with Sparkle-specific XML namespaces that advertises available software versions to users. When OptimusClip checks for updates, it fetches this file from the URL specified in Info.plist (SUFeedURL), parses the XML, compares the latest version to the currently running version, and presents an update dialog if a newer version exists.\n\nThe appcast uses the Sparkle XML namespace (xmlns:sparkle) to extend standard RSS with update-specific metadata: version numbers, download URLs, file sizes, cryptographic signatures, minimum system versions, and release notes. Each \u003citem\u003e in the channel represents one released version.\n\nThe file must be:\n1. Valid XML (parseable by NSXMLParser)\n2. Hosted at a publicly accessible HTTPS URL\n3. Updated atomically (no partial writes visible to clients)\n4. Ordered with newest releases first (Sparkle stops at first newer version)\n\nFor Optimus Clip, appcast.xml lives at repository root and is served via GitHub's raw content CDN. The file starts empty (just channel structure) and Scripts/release.sh adds new \u003citem\u003e entries when publishing releases.\n\nREAL-WORLD PROBLEM/USE CASE:\nDeveloper releases three versions of Optimus Clip over two months:\n* v0.9.0 (beta, January 15)\n* v1.0.0 (stable, February 1)\n* v1.0.1 (bugfix, February 10)\n\nUser installed v0.9.0 on January 20. On February 12:\n1. OptimusClip runs daily update check (SUScheduledCheckInterval)\n2. Fetches https://raw.githubusercontent.com/USER/optimus-clip/main/appcast.xml\n3. Parses XML, finds three \u003citem\u003e entries\n4. Compares sparkle:version (CFBundleVersion) to current build number\n5. v1.0.1 has higher build number (e.g., 15 vs. 10)\n6. Shows dialog: \"A new version of Optimus Clip is available. Would you like to download it now?\"\n7. Displays release notes from \u003cdescription\u003e tag\n8. User clicks \"Install Update\"\n9. Downloads zip from \u003cenclosure url=\"...\"\u003e\n10. Verifies sparkle:edSignature matches download\n11. Installs new version, relaunches app\n12. User now on v1.0.1 automatically\n\nWithout appcast.xml:\n* Sparkle shows error \"Cannot check for updates\"\n* Users never learn about new versions\n* Manual update process required\n* Professional auto-update feature broken\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. INITIAL EMPTY APPCAST TEMPLATE:\nCreate file at repository root: /Users/chrisedwards/projects/oss/optimus-clip/appcast.xml\n```xml\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003crss version=\"2.0\" xmlns:sparkle=\"http://www.andymatuschak.org/xml-namespaces/sparkle\"\u003e\n    \u003cchannel\u003e\n        \u003ctitle\u003eOptimus Clip\u003c/title\u003e\n        \u003clink\u003ehttps://github.com/USERNAME/optimus-clip\u003c/link\u003e\n        \u003cdescription\u003eIntelligent clipboard middleware for macOS\u003c/description\u003e\n        \u003clanguage\u003een\u003c/language\u003e\n        \u003c!-- Release items will be inserted here by Scripts/release.sh --\u003e\n    \u003c/channel\u003e\n\u003c/rss\u003e\n```\n\n2. ITEM STRUCTURE (Added by release.sh):\nWhen Scripts/release.sh creates a release, it inserts an \u003citem\u003e at the top of the channel:\n```xml\n\u003citem\u003e\n    \u003ctitle\u003eVersion 1.0.1\u003c/title\u003e\n    \u003clink\u003ehttps://github.com/USERNAME/optimus-clip/releases/tag/v1.0.1\u003c/link\u003e\n    \u003csparkle:version\u003e15\u003c/sparkle:version\u003e\n    \u003csparkle:shortVersionString\u003e1.0.1\u003c/sparkle:shortVersionString\u003e\n    \u003csparkle:minimumSystemVersion\u003e15.0\u003c/sparkle:minimumSystemVersion\u003e\n    \u003cpubDate\u003eSat, 10 Feb 2024 14:30:00 +0000\u003c/pubDate\u003e\n    \u003cenclosure \n        url=\"https://github.com/USERNAME/optimus-clip/releases/download/v1.0.1/OptimusClip-1.0.1.zip\"\n        length=\"8425671\"\n        type=\"application/octet-stream\"\n        sparkle:edSignature=\"mc1qYzE4NjU3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVm\" /\u003e\n    \u003cdescription\u003e\u003c![CDATA[\n        \u003ch2\u003eWhat's New in 1.0.1\u003c/h2\u003e\n        \u003cul\u003e\n            \u003cli\u003eFixed crash when clipboard contains image data\u003c/li\u003e\n            \u003cli\u003eImproved LLM transformation error handling\u003c/li\u003e\n            \u003cli\u003eUpdated Anthropic models list\u003c/li\u003e\n        \u003c/ul\u003e\n    ]]\u003e\u003c/description\u003e\n\u003c/item\u003e\n```\n\n3. KEY FIELDS EXPLAINED:\n\n**sparkle:version (Required)**\n* Maps to CFBundleVersion in Info.plist\n* Must be integer or version string\n* Comparison: Sparkle uses semantic version or numeric comparison\n* Example: \"15\" or \"1.0.1\" (prefer integer for clarity)\n* Must monotonically increase across releases\n\n**sparkle:shortVersionString (Required)**\n* Maps to CFBundleShortVersionString (MARKETING_VERSION)\n* Human-readable version shown in UI\n* Example: \"1.0.1\", \"2.0.0-beta\"\n\n**enclosure url (Required)**\n* Direct download URL for the update zip\n* Must be HTTPS\n* GitHub releases URL format: https://github.com/USER/REPO/releases/download/TAG/FILE.zip\n* Must return HTTP 200 and correct Content-Type\n\n**enclosure length (Required)**\n* File size in bytes\n* Get with: `stat -f%z OptimusClip-1.0.1.zip` (macOS) or `wc -c \u003c file`\n* Used for progress bar and verification\n\n**sparkle:edSignature (Required for security)**\n* ed25519 signature of the zip file\n* Generated with Sparkle's sign_update tool\n* Format: base64-encoded signature (typically 86-88 characters)\n* Must match SUPublicEDKey in Info.plist\n\n**description (Optional but recommended)**\n* Release notes shown to user\n* Can contain HTML (wrap in CDATA)\n* Supports: \u003ch1-h6\u003e, \u003cp\u003e, \u003cul\u003e, \u003cli\u003e, \u003cstrong\u003e, \u003cem\u003e, \u003ca\u003e\n* Keep concise (users skim)\n\n4. HOSTING ON GITHUB:\nGitHub serves raw repository files via raw.githubusercontent.com CDN:\n* URL format: https://raw.githubusercontent.com/USER/REPO/BRANCH/appcast.xml\n* Always HTTPS (Sparkle requirement met)\n* No authentication required for public repos\n* Fast global CDN with high availability\n* Free for open-source projects\n* Commits to main branch update immediately (30-60 second CDN propagation)\n\n5. XML VALIDATION:\nBefore committing, validate structure:\n```bash\n# Check XML syntax\nxmllint --noout appcast.xml\n# (no output = valid)\n\n# Verify Sparkle namespace\nxmllint --xpath \"//rss/@xmlns:sparkle\" appcast.xml\n# Output: xmlns:sparkle=\"http://www.andymatuschak.org/xml-namespaces/sparkle\"\n\n# Pretty-print for review\nxmllint --format appcast.xml\n```\n\n6. INITIAL COMMIT:\n```bash\ncd /Users/chrisedwards/projects/oss/optimus-clip\n# Create empty appcast (template above)\ngit add appcast.xml\ngit commit -m \"Add initial Sparkle appcast feed\"\ngit push origin main\n\n# Verify accessible\ncurl -I https://raw.githubusercontent.com/USERNAME/optimus-clip/main/appcast.xml\n# Should return: HTTP/2 200\n```\n\nARCHITECTURAL CONNECTIONS:\n* SUFeedURL in Info.plist (oc-c9x.4) points to this file\n* Scripts/release.sh (Phase 7.2) adds new items when publishing releases\n* Scripts/sign-and-notarize.sh (oc-c9x.6) generates signatures included in items\n* UpdaterWrapper.swift fetches this file to check for updates\n* Sparkle framework parses XML and validates signatures\n* GitHub releases (created by release.sh) host the zip files referenced in enclosure URLs\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. ITEM ORDERING:\n   * Items MUST be newest-first (top to bottom)\n   * Sparkle stops parsing at first item newer than current version\n   * Out-of-order items prevent users from seeing latest updates\n   * Always insert new items at top of channel\n\n2. BUILD NUMBER COMPARISON:\n   * sparkle:version must monotonically increase\n   * If v1.0.1 has build 15 and v1.0.2 has build 14, Sparkle thinks 14 is older\n   * Use version.env BUILD_NUMBER and always increment\n   * Never reuse build numbers across versions\n\n3. XML ENCODING:\n   * Release notes with \u003c, \u003e, \u0026 must use CDATA or entities\n   * Malformed XML breaks update checks silently\n   * Always wrap HTML content in \u003c![CDATA[...]]\u003e\n   * Test with xmllint after every change\n\n4. URL ACCESSIBILITY:\n   * Sparkle fails silently if enclosure URL returns 404\n   * GitHub releases must be public (not private repos)\n   * Asset upload can lag behind release creation (wait 30s)\n   * CDN propagation takes 30-60 seconds\n\n5. SIGNATURE MISMATCH:\n   * If sparkle:edSignature doesn't match downloaded file, update rejected\n   * Regenerate signature if file changes even slightly\n   * Signature generation: `sign_update OptimusClip-1.0.1.zip -f sparkle-private-key`\n\n6. FILE SIZE MISMATCH:\n   * If enclosure length doesn't match actual file size, progress bar breaks\n   * Always regenerate after re-zipping\n   * Use `stat -f%z` on macOS, `stat -c%s` on Linux\n\n7. MINIMUM SYSTEM VERSION:\n   * sparkle:minimumSystemVersion prevents installs on older macOS\n   * Optimus Clip requires macOS 15.0+ (LSMinimumSystemVersion)\n   * Sparkle compares against system version, blocks if too old\n\n8. EMPTY CHANNEL:\n   * Empty channel (no items) is valid XML\n   * Sparkle interprets as \"no updates available\"\n   * Not an error condition\n   * Initial appcast starts empty\n\nTESTING REQUIREMENTS:\n1. XML syntax valid: xmllint --noout passes without errors\n2. Namespace present: xmlns:sparkle attribute exists on \u003crss\u003e tag\n3. Channel structure: \u003cchannel\u003e with \u003ctitle\u003e nested inside \u003crss\u003e\n4. Accessible via GitHub: curl returns HTTP 200 (after git push)\n5. Content-Type correct: GitHub serves as text/xml or text/plain (both acceptable)\n6. Sparkle can parse: UpdaterWrapper logs no XML parsing errors\n7. Empty state valid: Sparkle interprets empty channel as \"no updates\"\n\nSUCCESS CRITERIA:\n- Valid XML structure created at repository root\n- Sparkle namespace declared on \u003crss\u003e tag\n- Channel contains title, link, description, language\n- File committed to git repository\n- Accessible via GitHub raw content URL (SUFeedURL)\n- xmllint validation passes\n- curl returns HTTP 200\n- No XML parsing errors in Console.app\n- Ready for Scripts/release.sh to populate with items\n\nCONFIGURATION OPTIONS:\n* Channel title: \"Optimus Clip\" (matches app name)\n* Channel link: Repository URL or product website\n* Description: Brief tagline shown in some RSS readers\n* Language: \"en\" (English), \"es\" (Spanish), etc.\n\nPERFORMANCE CONSIDERATIONS:\n* File size grows with each release (add ~500 bytes per item)\n* Keep last 10-20 releases maximum (prune old items to reduce parse time)\n* GitHub CDN caches file (fast download, global distribution)\n* Sparkle caches locally (doesn't re-fetch every app launch)\n\nSECURITY CONSIDERATIONS:\n* HTTPS prevents man-in-the-middle tampering during fetch\n* ed25519 signatures prevent malicious update injection\n* Public key in Info.plist verifies signatures\n* Even if attacker compromises GitHub account, cannot inject malicious updates without private key\n\nIMPLEMENTATION ORDER:\n1. Create appcast.xml file at repository root\n2. Add XML declaration and RSS structure\n3. Add Sparkle namespace to \u003crss\u003e tag\n4. Add \u003cchannel\u003e with title, link, description\n5. Validate with xmllint --noout\n6. Commit to git repository\n7. Push to GitHub main branch\n8. Verify curl returns HTTP 200 for raw content URL\n9. Update Info.plist SUFeedURL to point to this URL (if not already)\n10. Test Sparkle parsing by running app and checking Console.app logs\n\nCODE ORGANIZATION:\n/Users/chrisedwards/projects/oss/optimus-clip/appcast.xml (hosted file)\n/Users/chrisedwards/projects/oss/optimus-clip/Scripts/release.sh (adds items)\n/Users/chrisedwards/projects/oss/optimus-clip/Info.plist (SUFeedURL points here)\nhttps://raw.githubusercontent.com/USERNAME/optimus-clip/main/appcast.xml (public URL)\n\nPRIORITY: P2 (Required before Sparkle can detect updates)\n\nESTIMATED TIME: 10-15 minutes (create file, validate, commit, verify URL)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:40.60972-05:00","updated_at":"2025-12-16T18:50:58.703185-05:00","closed_at":"2025-12-16T18:50:58.703185-05:00","close_reason":"Added initial Sparkle appcast template and validated XML","dependencies":[{"issue_id":"oc-c9x.5","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:06:40.61059-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-c9x.6","title":"Create sign-and-notarize.sh Script","description":"BACKGROUND \u0026 CONTEXT:\nsign-and-notarize.sh is the core release automation script that transforms a locally-built OptimusClip binary into a distribution-ready, Apple-approved application bundle. This script orchestrates a complex multi-step process that must be executed in exact order with specific tools and parameters.\n\nApple's Gatekeeper security system blocks unsigned applications from launching on macOS with a \"damaged or incomplete\" error. Notarization adds an additional layer of verification where Apple scans the app for malware and code-signing issues before issuing a \"notarization ticket\" that proves the app is safe. Without both signing and notarization, users cannot run the app without manually bypassing security warnings.\n\nThe script performs 12 distinct operations:\n1. Build release binary (optimized, stripped)\n2. Package into .app bundle structure\n3. Sign with Developer ID certificate and hardened runtime\n4. Verify signature integrity\n5. Strip metadata that breaks signatures\n6. Create distribution zip with specific tool (ditto, not zip)\n7. Submit to Apple for notarization scan\n8. Wait for Apple approval (5-15 minutes)\n9. Staple notarization ticket to app bundle\n10. Verify stapling and Gatekeeper acceptance\n11. Re-zip the stapled app for distribution\n12. Archive debug symbols for crash report symbolication\n\nEach step has specific failure modes and requirements. Manual execution is error-prone (easy to skip steps or use wrong parameters) and time-consuming (notarization wait requires monitoring). Automation ensures consistency, catches errors immediately, and enables reliable repeatable releases.\n\nREAL-WORLD PROBLEM/USE CASE:\nDeveloper wants to release OptimusClip v1.0.0 to public GitHub. Manual process:\n1. Run swift build -c release (5 minutes)\n2. Create .app bundle structure (mkdir, cp)\n3. Find Developer ID certificate name in Keychain\n4. Run codesign with 8 parameters (easy to miss --options runtime)\n5. Run codesign --verify (did it work?)\n6. Create zip... wait, use ditto not zip (zip breaks signatures)\n7. Upload to notarytool... need to find API credentials\n8. Wait 10 minutes... keep checking status manually\n9. When done, staple ticket... to the app not the zip\n10. Create new zip of stapled app\n11. Upload to GitHub releases\n12. Realize signature verification fails, start over\n13. 90 minutes elapsed, multiple attempts, frustrated\n\nWith sign-and-notarize.sh:\n1. Run ./Scripts/sign-and-notarize.sh (one command)\n2. Script handles all steps automatically\n3. Waits for notarization completion (no manual monitoring)\n4. Validates every step, exits on first error with clear message\n5. Produces OptimusClip-1.0.0.zip ready for distribution\n6. 15-20 minutes elapsed (mostly Apple wait time)\n7. Consistent, repeatable, error-free process\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. SCRIPT STRUCTURE:\nThe script follows bash best practices with strict error handling and clear step progression. Key requirements: source version.env for version numbers, use environment variables for credentials (never hardcode), validate every operation, produce clear output for debugging.\n\n2. CODESIGN PARAMETERS EXPLAINED:\n\n--force: Replace existing signature if present (required for re-signing)\n--deep: Sign all nested code (frameworks, helpers, plugins)\n--options runtime: Enable hardened runtime (required for notarization)\n--timestamp: Include secure timestamp from Apple (proves signing time)\n--sign IDENTITY: Certificate name from Keychain\n\nFinding your Developer ID certificate:\nsecurity find-identity -v -p codesigning\nUse the \"Developer ID Application\" certificate (for distribution outside Mac App Store)\n\n3. NOTARYTOOL AUTHENTICATION:\n\nApp Store Connect API requires three credentials:\n- APP_STORE_CONNECT_KEY_ID: 10-character key ID\n- APP_STORE_CONNECT_ISSUER_ID: UUID issuer ID\n- APP_STORE_CONNECT_API_KEY_P8: Base64-encoded .p8 private key\n\nCreating API key:\n1. Log in to App Store Connect (appstoreconnect.apple.com)\n2. Users and Access → Keys → App Store Connect API\n3. Click (+) to create new key\n4. Name: \"OptimusClip Notarization\"\n5. Access: Developer\n6. Download AuthKey_XXXXXXXXX.p8 (only chance to download)\n7. Save Key ID and Issuer ID\n8. Store .p8 file securely (never commit to git)\n\n4. DITTO VS ZIP (CRITICAL):\n\nWhy ditto?\nmacOS metadata (extended attributes, resource forks) are stored in AppleDouble files (._filename). The zip command includes these files, which break code signatures. ditto creates \"clean\" archives without AppleDouble files.\n\nWRONG - Breaks signatures:\nzip -r App.zip App.app\n\nCORRECT - Preserves signatures:\nditto -c -k --keepParent --rsrc App.app App.zip\n\nParameters:\n--keepParent: Include App.app as top-level directory (not contents)\n--rsrc: Preserve resource forks if present\n\n5. NOTARIZATION WAIT TIME:\n\nApple's notarization service scans app for malware, code-signing issues, and entitlement violations:\n- Typical: 5-10 minutes\n- Heavy load: 15-30 minutes\n- Failure: Immediate (\u003c 1 minute) with error details\n\nxcrun notarytool submit --wait blocks until complete (script pauses, no manual checking needed).\n\nCheck status manually if needed:\nxcrun notarytool info SUBMISSION_ID --key-id KEY_ID --issuer ISSUER_ID --key AuthKey.p8\n\nGet detailed log if failed:\nxcrun notarytool log SUBMISSION_ID --key-id KEY_ID --issuer ISSUER_ID --key AuthKey.p8\n\n6. STAPLING EXPLANATION:\n\nNotarization ticket is stored on Apple's servers. Stapling embeds a copy in the app bundle so Gatekeeper can verify offline (no internet required).\n\nStaple ticket to app bundle (not zip):\nxcrun stapler staple OptimusClip.app\n\nVerify stapling:\nxcrun stapler validate OptimusClip.app\nOutput: The staple and validate action worked!\n\nVerify Gatekeeper acceptance:\nspctl -a -t exec -vv OptimusClip.app\nOutput: OptimusClip.app: accepted, source=Notarized Developer ID\n\n7. DEBUG SYMBOLS (dSYM):\n\nWhen app crashes, macOS generates crash reports with memory addresses. dSYM files map addresses to source code line numbers (symbolication).\n\nSwift compiler generates dSYM during release build:\nswift build -c release creates .build/release/OptimusClip.dSYM/\n\nArchive for later crash report analysis:\nditto -c -k --keepParent .build/release/OptimusClip.dSYM OptimusClip-1.0.0.dSYM.zip\n\nUpload to GitHub releases alongside app zip for crash report debugging.\n\nARCHITECTURAL CONNECTIONS:\n- Reads version.env for MARKETING_VERSION (used in filenames)\n- Calls Scripts/package_app.sh to create .app bundle\n- Produces zip referenced by appcast.xml enclosure URL\n- Generates signature used in appcast.xml sparkle:edSignature\n- Output uploaded to GitHub releases by Scripts/release.sh\n- dSYM archive used for crash report symbolication\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. CERTIFICATE EXPIRATION:\n   * Developer ID certificates expire after 5 years\n   * Expired cert causes codesign failure: \"certificate trust settings\"\n   * Renew in Apple Developer portal before expiration\n   * Re-sign all releases with new certificate\n\n2. TEAM ID MISMATCH:\n   * App bundle ID must match certificate provisioning profile\n   * Wrong team ID: codesign fails with \"no identity found\"\n   * Verify: security find-identity -v -p codesigning\n\n3. HARDENED RUNTIME VIOLATIONS:\n   * --options runtime enables strict security policies\n   * Some APIs require entitlements (camera, microphone, network)\n   * Optimus Clip requires: com.apple.security.automation.apple-events (for paste simulation)\n   * Add entitlements.plist if needed: codesign --entitlements entitlements.plist\n\n4. NESTED FRAMEWORKS:\n   * If embedding Sparkle.framework, must sign it before signing app\n   * Sign order: deepest first (framework → app)\n   * Use --deep to sign all nested code automatically\n\n5. NOTARIZATION FAILURES:\n   * Common: Missing hardened runtime (add --options runtime)\n   * Common: Unsigned nested code (use --deep)\n   * Common: Invalid bundle structure (verify Info.plist)\n   * Check logs: xcrun notarytool log SUBMISSION_ID\n\n6. NETWORK TIMEOUTS:\n   * notarytool submit can timeout on slow connections\n   * Default timeout: 30 minutes\n   * Increase if needed: xcrun notarytool submit --timeout 7200 (seconds)\n\n7. PRIVATE KEY SECURITY:\n   * App Store Connect API key grants signing authority\n   * Never commit to git (add to .gitignore)\n   * Store in 1Password, environment variable, or CI secrets\n   * Rotate if compromised (revoke old key in App Store Connect)\n\n8. APPLEEVENT SANDBOXING:\n   * Hardened runtime blocks Apple Events by default\n   * Optimus Clip uses CGEvent for paste (allowed)\n   * If using NSAppleScript or AEDeterminePermissionToAutomateTarget, need entitlement\n\nTESTING REQUIREMENTS:\n1. Script completes without errors: Exit code 0\n2. Signature valid: codesign --verify passes\n3. Notarization approved: notarytool output shows \"status: Accepted\"\n4. Stapling successful: stapler validate passes\n5. Gatekeeper accepts: spctl shows \"source=Notarized Developer ID\"\n6. Zip opens cleanly: ditto -x -k extracts without errors\n7. App launches on clean Mac: No \"damaged\" error\n8. Console shows no signature warnings\n9. dSYM archive created: File exists and contains symbols\n\nSUCCESS CRITERIA:\n- Script completes all 12 steps without errors\n- OptimusClip-VERSION.zip created in repository root\n- codesign --verify --deep --strict passes\n- spctl -a -t exec -vv shows \"Notarized Developer ID\"\n- xcrun stapler validate confirms ticket stapled\n- Zip extracts cleanly with ditto -x -k\n- App launches without Gatekeeper warnings on clean macOS 15+ system\n- OptimusClip-VERSION.dSYM.zip created with debug symbols\n- All verification commands pass\n\nCONFIGURATION OPTIONS:\n* IDENTITY: Certificate name (defaults to env var, fallback to hardcoded)\n* Notarization timeout: --timeout parameter to notarytool (default 30 min)\n* dSYM archiving: Optional, skip if .dSYM directory missing\n* Verbose output: Add --verbose to codesign/stapler for debugging\n\nPERFORMANCE CONSIDERATIONS:\n* swift build -c release: 2-5 minutes (depends on code size)\n* codesign: 5-10 seconds\n* ditto zip: 2-3 seconds (app is ~5-10 MB)\n* notarytool submit: 5-15 minutes (Apple server processing)\n* xcrun stapler: 2-3 seconds\n* Total time: 10-20 minutes (mostly notarization wait)\n\nSECURITY CONSIDERATIONS:\n* API key grants notarization authority (protect like password)\n* Private key in environment variable (not hardcoded in script)\n* Use process substitution for key: --key \u003c(echo \"$KEY\" | base64 -d)\n* Never log API credentials (script output safe to share)\n* Certificate in Keychain (macOS secure storage)\n* Delete .p8 file after storing in secure location\n\nIMPLEMENTATION ORDER:\n1. Create Scripts/sign-and-notarize.sh file\n2. Add shebang and set -euo pipefail\n3. Source version.env for MARKETING_VERSION\n4. Define file paths and configuration\n5. Add build step (swift build -c release)\n6. Add packaging step (package_app.sh)\n7. Add signing step (codesign with hardened runtime)\n8. Add verification (codesign --verify)\n9. Add metadata cleanup (xattr, find)\n10. Add zipping (ditto)\n11. Add notarization (notarytool submit --wait)\n12. Add stapling (stapler staple, validate)\n13. Add Gatekeeper check (spctl)\n14. Add re-zipping of stapled app\n15. Add dSYM archiving\n16. Add success message with next steps\n17. Make executable: chmod +x Scripts/sign-and-notarize.sh\n18. Test with: ./Scripts/sign-and-notarize.sh\n\nCODE ORGANIZATION:\n/Users/chrisedwards/projects/oss/optimus-clip/Scripts/sign-and-notarize.sh (main script)\n/Users/chrisedwards/projects/oss/optimus-clip/version.env (version source)\n/Users/chrisedwards/projects/oss/optimus-clip/Scripts/package_app.sh (called by script)\n/Users/chrisedwards/projects/oss/optimus-clip/OptimusClip-1.0.0.zip (output)\n/Users/chrisedwards/projects/oss/optimus-clip/OptimusClip-1.0.0.dSYM.zip (debug symbols)\n\nPRIORITY: P2 (Required for public distribution)\n\nESTIMATED TIME: 45-60 minutes (write script, configure credentials, test end-to-end)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:53.611933-05:00","updated_at":"2025-12-16T19:02:11.19295-05:00","closed_at":"2025-12-16T19:02:11.19295-05:00","close_reason":"Added signing/notarization automation script","dependencies":[{"issue_id":"oc-c9x.6","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:06:53.61259-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.6","depends_on_id":"oc-c9x.1","type":"blocks","created_at":"2025-12-12T23:54:06.983922-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-c9x.7","title":"Create release.sh Master Script","description":"BACKGROUND: Master orchestration script that runs entire release workflow: pre-flight checks, build, sign, notarize, update appcast, create GitHub release, tag, push. Single command releases.\n\nPROBLEM: Manual releases have many steps, easy to miss one, error-prone, inconsistent. release.sh automates and enforces correct order, verifies at each stage, rolls back on failure.\n\nWORKFLOW:\n1. Pre-flight: git status clean, version.env bumped, CHANGELOG updated, env vars set\n2. Lint/test: swiftformat --lint, swiftlint, swift test\n3. Build/sign: call sign-and-notarize.sh\n4. Sparkle signature: sign_update OptimusClip.zip PRIVATE_KEY_FILE (generates ed25519 signature)\n5. Update appcast: add new item with version/URL/signature/length to appcast.xml (newest first)\n6. GitHub release: gh release create vVERSION --title --notes-file (upload zip and dSYM)\n7. Verify assets: check-release-assets.sh confirms URLs accessible\n8. Git tag/push: tag version, push with tags\n\nSPARKLE SIGNATURE: Use sign_update tool from Sparkle package. Output is EdDSA signature string for sparkle:edSignature attribute. File length from stat command for length attribute.\n\nAPPCAST UPDATE: Parse XML, insert new item element at top of channel, include version/pubDate/enclosure/description. Validate with xmllint before committing.\n\nGITHUB RELEASE: Use gh CLI (must be authenticated). Upload both zip (app) and dSYM.zip (crash symbols). Extract release notes from CHANGELOG.md section for this version.\n\nPRE-FLIGHT CHECKS: Exit early if: uncommitted changes, version not bumped, required env vars missing, previous tag exists. Prevents partial/broken releases.\n\nPOST-RELEASE: Tag with git tag vVERSION, push main and tags. Update CI checks release was created successfully.\n\nSAFETY: Dry-run mode (--dry-run flag) simulates without uploading. Confirmation prompts before destructive actions. Rollback procedure documented for bad releases.\n\nENV VARS: All from sign-and-notarize.sh plus SPARKLE_PRIVATE_KEY_FILE (path to ed25519 private key)\n\nVERIFICATION: Script exits 0, GitHub release exists with both assets, appcast has new item, git tag created, URLs return 200\n\nGOTCHAS: sign_update in .build after SPM fetch, private key must be single-line base64, appcast XML must validate, gh CLI must be authenticated, build number must increase\n\nROLLBACK: Delete GitHub release (gh release delete), remove git tag (local and remote), remove appcast item, fix issue, re-run\n\nTESTING: Run with --dry-run, verify all checks pass, run real release to test repo, verify end-to-end\n\nSUCCESS: Script completes, release on GitHub, appcast updated, git tagged, all assets downloadable, users can update","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:07:07.990438-05:00","updated_at":"2025-12-27T18:01:38.315765-05:00","closed_at":"2025-12-27T18:01:38.315765-05:00","close_reason":"Closed","dependencies":[{"issue_id":"oc-c9x.7","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:07:07.991014-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.7","depends_on_id":"oc-c9x.5","type":"blocks","created_at":"2025-12-12T23:54:07.685591-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.7","depends_on_id":"oc-c9x.6","type":"blocks","created_at":"2025-12-12T23:54:08.490052-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.7","depends_on_id":"oc-c9x.3","type":"blocks","created_at":"2025-12-14T22:28:46.032261-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.7","depends_on_id":"oc-c9x.4","type":"blocks","created_at":"2025-12-14T22:28:46.673118-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":21,"issue_id":"oc-c9x.7","author":"Chris Edwards","text":"Created release.sh master orchestration script. Full workflow: pre-flight checks, lint/test, sign-and-notarize, Sparkle signature, appcast update, GitHub release, verification, tag/push. Supports --dry-run mode. All 273 tests pass. Commit: 2ca40f5","created_at":"2025-12-27T23:01:34Z"}]}
{"id":"oc-c9x.8","title":"Create check-release-assets.sh Verification Script","description":"BACKGROUND \u0026 CONTEXT:\ncheck-release-assets.sh is a verification script that runs after creating a GitHub release to confirm all required assets are present, publicly accessible, and correctly configured. This script acts as a safety net that catches common release failures before users encounter them.\n\nGitHub releases are created through the gh CLI or API, which initiates several asynchronous operations: asset upload to GitHub's storage backend, CDN propagation across global edge servers, metadata indexing, and URL routing. These operations can fail silently or partially, leaving the release in an inconsistent state. Common failure modes include: assets stuck in \"uploading\" state, CDN 404s despite successful upload, wrong Content-Type headers breaking downloads, and file size mismatches causing download corruption.\n\nThe script performs comprehensive validation:\n1. Release exists in GitHub API\n2. Expected assets present in release\n3. Asset URLs return HTTP 200 (not 404)\n4. Content-Type headers correct for zip files\n5. Content-Length matches expected file size\n6. Download completes without errors\n7. Results match appcast.xml configuration\n\nRunning this script immediately after release creation (as part of Scripts/release.sh) catches issues within minutes rather than discovering them when users report broken downloads hours or days later.\n\nREAL-WORLD PROBLEM/USE CASE:\nDeveloper runs Scripts/release.sh to publish OptimusClip v1.0.1. The script:\n1. Signs and notarizes app (15 minutes)\n2. Creates GitHub release (gh release create)\n3. Uploads OptimusClip-1.0.1.zip (8 MB, takes 30 seconds)\n4. Uploads OptimusClip-1.0.1.dSYM.zip (2 MB)\n5. Updates appcast.xml with release entry\n6. Commits and pushes to GitHub\n\nWithout verification:\n1. Developer assumes release succeeded\n2. Announces update on Twitter\n3. Users check for updates in app\n4. Sparkle fetches appcast.xml, sees v1.0.1\n5. Tries to download from URL: 404 Not Found\n6. Update fails with \"Download error\"\n7. Users report broken update in GitHub issues\n8. Developer investigates, finds asset upload failed silently\n9. Re-uploads asset manually\n10. 2 hours elapsed, reputation damaged, users frustrated\n\nWith check-release-assets.sh (called automatically by release.sh):\n1. Script checks release immediately after creation\n2. Detects: \"OptimusClip-1.0.1.zip not found in release assets\"\n3. Exits with error, prevents appcast.xml commit\n4. Developer sees error immediately, fixes before announcing\n5. Re-runs release script, verification passes\n6. Release announced confidently\n7. Users update successfully, no issues reported\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. SCRIPT STRUCTURE:\n```bash\n#!/usr/bin/env bash\n# check-release-assets.sh - Verify GitHub release has all required assets\n# Usage: ./Scripts/check-release-assets.sh v1.0.0\n\nset -euo pipefail\n\nTAG=\"${1:?Usage: check-release-assets.sh \u003ctag\u003e}\"\nROOT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\" \u0026\u0026 pwd)\"\n\n# Parse version from tag (strip 'v' prefix)\nVERSION=\"${TAG#v}\"\n\n# Expected assets\nAPP_ZIP=\"OptimusClip-${VERSION}.zip\"\nDSYM_ZIP=\"OptimusClip-${VERSION}.dSYM.zip\"\n\n# GitHub repository (from git remote or environment)\nREPO=\"${GITHUB_REPOSITORY:-$(git remote get-url origin | sed -e 's/.*github.com[:/]\\(.*\\)\\.git/\\1/')}\"\n\necho \"Checking release assets for ${TAG} in ${REPO}...\"\n\n# 1. Check release exists\nif ! gh api \"repos/${REPO}/releases/tags/${TAG}\" \u003e /dev/null 2\u003e\u00261; then\n    echo \"ERROR: Release ${TAG} not found\"\n    exit 1\nfi\necho \"✓ Release exists\"\n\n# 2. Get release assets\nASSETS=$(gh api \"repos/${REPO}/releases/tags/${TAG}\" --jq '.assets[].name')\n\nif ! echo \"${ASSETS}\" | grep -q \"^${APP_ZIP}\\$\"; then\n    echo \"ERROR: ${APP_ZIP} not found in release assets\"\n    exit 2\nfi\necho \"✓ ${APP_ZIP} present\"\n\nif ! echo \"${ASSETS}\" | grep -q \"^${DSYM_ZIP}\\$\"; then\n    echo \"WARNING: ${DSYM_ZIP} not found in release assets\"\nfi\n\n# 3. Get download URLs\nAPP_URL=$(gh api \"repos/${REPO}/releases/tags/${TAG}\" --jq \".assets[] | select(.name == \\\"${APP_ZIP}\\\") | .browser_download_url\")\nDSYM_URL=$(gh api \"repos/${REPO}/releases/tags/${TAG}\" --jq \".assets[] | select(.name == \\\"${DSYM_ZIP}\\\") | .browser_download_url\")\n\n# 4. Check app zip accessibility\nHTTP_CODE=$(curl -s -o /dev/null -w \"%{http_code}\" -L \"${APP_URL}\")\nif [[ \"${HTTP_CODE}\" != \"200\" ]]; then\n    echo \"ERROR: ${APP_URL} returned HTTP ${HTTP_CODE}\"\n    exit 3\nfi\necho \"✓ ${APP_ZIP} accessible (HTTP 200)\"\n\n# 5. Check Content-Type\nCONTENT_TYPE=$(curl -sI -L \"${APP_URL}\" | grep -i \"^content-type:\" | awk '{print $2}' | tr -d '\\r')\nif [[ \"${CONTENT_TYPE}\" != \"application/zip\"* ]] \u0026\u0026 [[ \"${CONTENT_TYPE}\" != \"application/octet-stream\"* ]]; then\n    echo \"WARNING: Unexpected Content-Type: ${CONTENT_TYPE}\"\nfi\n\n# 6. Check file size\nREMOTE_SIZE=$(curl -sI -L \"${APP_URL}\" | grep -i \"^content-length:\" | awk '{print $2}' | tr -d '\\r')\nLOCAL_SIZE=$(stat -f%z \"${ROOT_DIR}/${APP_ZIP}\" 2\u003e/dev/null || echo \"0\")\n\nif [[ \"${REMOTE_SIZE}\" != \"${LOCAL_SIZE}\" ]] \u0026\u0026 [[ \"${LOCAL_SIZE}\" != \"0\" ]]; then\n    echo \"WARNING: Size mismatch (remote: ${REMOTE_SIZE}, local: ${LOCAL_SIZE})\"\nfi\necho \"✓ File size: ${REMOTE_SIZE} bytes\"\n\n# 7. Test download\nif ! curl -fsSL -o /dev/null \"${APP_URL}\"; then\n    echo \"ERROR: Download failed\"\n    exit 4\nfi\necho \"✓ Download successful\"\n\necho \"\"\necho \"✅ All checks passed for ${TAG}\"\n```\n\n2. RELEASE EXISTENCE CHECK:\nUses GitHub API to verify release was created:\n```bash\ngh api \"repos/USER/REPO/releases/tags/v1.0.0\"\n# Returns JSON if exists, 404 error if not\n\n# Check without printing response\ngh api \"repos/USER/REPO/releases/tags/v1.0.0\" \u003e /dev/null 2\u003e\u00261\n# Exit code: 0=success, 1=failure\n```\n\n3. ASSET PRESENCE CHECK:\nQuery release assets with jq filtering:\n```bash\n# Get all asset names\ngh api \"repos/USER/REPO/releases/tags/v1.0.0\" --jq '.assets[].name'\n# Output:\n# OptimusClip-1.0.0.zip\n# OptimusClip-1.0.0.dSYM.zip\n\n# Check specific asset exists\nASSETS=$(gh api \"repos/USER/REPO/releases/tags/v1.0.0\" --jq '.assets[].name')\nif echo \"${ASSETS}\" | grep -q \"^OptimusClip-1.0.0.zip$\"; then\n    echo \"Asset found\"\nfi\n```\n\n4. DOWNLOAD URL EXTRACTION:\nGet browser_download_url for specific asset:\n```bash\ngh api \"repos/USER/REPO/releases/tags/v1.0.0\" \\\n    --jq '.assets[] | select(.name == \"OptimusClip-1.0.0.zip\") | .browser_download_url'\n# Output: https://github.com/USER/REPO/releases/download/v1.0.0/OptimusClip-1.0.0.zip\n```\n\n5. HTTP STATUS CHECK:\nVerify URL is accessible:\n```bash\n# HEAD request, follow redirects, get HTTP status code\ncurl -s -o /dev/null -w \"%{http_code}\" -L \"https://github.com/.../OptimusClip.zip\"\n# Output: 200 (success), 404 (not found), 403 (forbidden), etc.\n\n# Flags:\n# -s: Silent (no progress bar)\n# -o /dev/null: Discard body (HEAD request would be -I, but -L doesn't work with -I)\n# -w \"%{http_code}\": Output HTTP status code\n# -L: Follow redirects (GitHub redirects to CDN)\n```\n\n6. CONTENT-TYPE CHECK:\nVerify correct MIME type:\n```bash\ncurl -sI -L \"https://github.com/.../OptimusClip.zip\" | grep -i \"content-type:\"\n# Output: content-type: application/zip\n\n# Acceptable types:\n# - application/zip (correct)\n# - application/octet-stream (generic binary, acceptable)\n# - text/html (WRONG - likely error page)\n```\n\n7. FILE SIZE VERIFICATION:\nCompare remote size to local file:\n```bash\n# Get remote size from Content-Length header\nREMOTE_SIZE=$(curl -sI -L \"URL\" | grep -i \"content-length:\" | awk '{print $2}' | tr -d '\\r')\n\n# Get local file size\nLOCAL_SIZE=$(stat -f%z OptimusClip-1.0.0.zip)  # macOS\n# or\nLOCAL_SIZE=$(stat -c%s OptimusClip-1.0.0.zip)  # Linux\n\n# Compare\nif [[ \"${REMOTE_SIZE}\" == \"${LOCAL_SIZE}\" ]]; then\n    echo \"Size matches\"\nfi\n```\n\n8. DOWNLOAD TEST:\nAttempt full download to verify no corruption:\n```bash\n# Download to /dev/null (discard, just test download works)\ncurl -fsSL -o /dev/null \"https://github.com/.../OptimusClip.zip\"\n\n# Flags:\n# -f: Fail silently on HTTP errors (exit code != 0)\n# -s: Silent\n# -S: Show errors even with -s\n# -L: Follow redirects\n# -o /dev/null: Discard output\n```\n\n9. CDN PROPAGATION RETRY:\nGitHub CDN can take 30-60 seconds to propagate new assets. Add retry logic:\n```bash\n# Retry up to 3 times with 30-second delay\nMAX_RETRIES=3\nRETRY_DELAY=30\n\nfor i in $(seq 1 $MAX_RETRIES); do\n    HTTP_CODE=$(curl -s -o /dev/null -w \"%{http_code}\" -L \"${URL}\")\n    if [[ \"${HTTP_CODE}\" == \"200\" ]]; then\n        break\n    fi\n    \n    if [[ $i -lt $MAX_RETRIES ]]; then\n        echo \"Retry $i/$MAX_RETRIES: HTTP ${HTTP_CODE}, waiting ${RETRY_DELAY}s for CDN propagation...\"\n        sleep $RETRY_DELAY\n    else\n        echo \"ERROR: Asset not accessible after $MAX_RETRIES retries\"\n        exit 1\n    fi\ndone\n```\n\nARCHITECTURAL CONNECTIONS:\n* Called by Scripts/release.sh after gh release create\n* Validates URLs that will be used in appcast.xml enclosure tags\n* Checks assets created by Scripts/sign-and-notarize.sh\n* Uses gh CLI (requires GITHUB_TOKEN for authentication)\n* Prevents committing appcast.xml if assets unavailable\n* Catches failures before users affected\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. CDN PROPAGATION DELAY:\n   * GitHub CDN takes 30-60 seconds to propagate new assets\n   * Immediate check after upload may return 404\n   * Add retry logic with exponential backoff\n   * Don't fail immediately, wait and retry\n\n2. PRIVATE REPOSITORIES:\n   * Assets in private repos require authentication\n   * browser_download_url includes temporary token\n   * Public Sparkle feeds cannot use private repos\n   * Script should warn if repo is private\n\n3. REDIRECT FOLLOWING:\n   * GitHub redirects downloads to CDN (cloudfront.net)\n   * Must use curl -L (follow redirects)\n   * Without -L, returns 302 instead of 200\n   * Check final destination, not redirect\n\n4. REPOSITORY DETECTION:\n   * Script needs GITHUB_REPOSITORY (owner/repo format)\n   * Can get from environment (CI) or git remote\n   * Parse git remote URL carefully (SSH vs HTTPS format)\n   * Example SSH: git@github.com:user/repo.git\n   * Example HTTPS: https://github.com/user/repo.git\n\n5. TAG FORMAT:\n   * Input tag might be \"v1.0.0\" or \"1.0.0\"\n   * Strip 'v' prefix when constructing filenames\n   * GitHub API requires full tag name with 'v'\n   * OptimusClip-1.0.0.zip (no 'v' in filename)\n\n6. DSYM OPTIONAL:\n   * dSYM archive might not exist for some releases\n   * Warn but don't fail if missing\n   * Only .zip is required for user updates\n   * dSYM only needed for crash report debugging\n\n7. RATE LIMITING:\n   * GitHub API has rate limits (60 unauthenticated, 5000 authenticated)\n   * gh CLI uses GITHUB_TOKEN automatically (higher limit)\n   * Script should check API rate limit if failing\n   * gh api rate_limit shows remaining requests\n\n8. ERROR CODES:\n   * Use distinct exit codes for different failures\n   * Exit 1: Release not found\n   * Exit 2: Asset missing\n   * Exit 3: URL inaccessible\n   * Exit 4: Download failed\n   * Helps debugging in CI logs\n\nTESTING REQUIREMENTS:\n1. Successful release: All checks pass, exit code 0\n2. Missing release: Detects 404, exits with code 1\n3. Missing asset: Detects absent zip, exits with code 2\n4. Inaccessible URL: Detects 404/403, exits with code 3\n5. Failed download: Detects download error, exits with code 4\n6. CDN delay: Retries successfully after propagation\n7. Size mismatch: Warns but continues (non-fatal)\n8. Wrong Content-Type: Warns but continues\n\nSUCCESS CRITERIA:\n- Script passes for good releases (exit 0)\n- Detects missing release (exit 1 with clear error)\n- Detects missing assets (exit 2 with asset name)\n- Detects inaccessible URLs (exit 3 with HTTP code)\n- Detects download failures (exit 4 with curl error)\n- Provides clear error messages for each failure mode\n- Handles CDN propagation delays with retry\n- Works with both CI and local execution\n- Validates all assets before appcast.xml commit\n\nCONFIGURATION OPTIONS:\n* MAX_RETRIES: Number of retry attempts for CDN propagation (default 3)\n* RETRY_DELAY: Seconds between retries (default 30)\n* GITHUB_REPOSITORY: Override repository detection\n* Check dSYM: Optional, can skip with --skip-dsym flag\n* Verbose output: --verbose flag for detailed curl output\n\nPERFORMANCE CONSIDERATIONS:\n* Each check makes network request (total ~5-10 seconds)\n* Retry logic adds 30-60 seconds if CDN not propagated\n* Can run in parallel with other release steps (not blocking)\n* Lightweight script, minimal memory usage\n\nSECURITY CONSIDERATIONS:\n* Uses gh CLI with GITHUB_TOKEN (respects authentication)\n* Does not expose credentials in output\n* Safe to run in public CI logs\n* Only reads release data (no write operations)\n* Validates assets before users download (prevents serving malware if upload compromised)\n\nIMPLEMENTATION ORDER:\n1. Create Scripts/check-release-assets.sh file\n2. Add shebang and set -euo pipefail\n3. Parse tag argument and version\n4. Detect repository from git or environment\n5. Define expected asset filenames\n6. Add release existence check (gh api)\n7. Add asset presence check (jq filtering)\n8. Extract download URLs\n9. Add HTTP status check with retry logic\n10. Add Content-Type validation\n11. Add file size comparison\n12. Add download test\n13. Add success message\n14. Make executable: chmod +x Scripts/check-release-assets.sh\n15. Test with: ./Scripts/check-release-assets.sh v1.0.0\n\nCODE ORGANIZATION:\n/Users/chrisedwards/projects/oss/optimus-clip/Scripts/check-release-assets.sh (verification script)\n/Users/chrisedwards/projects/oss/optimus-clip/Scripts/release.sh (calls this script)\nCalled after: gh release create (releases assets)\nBefore: git commit appcast.xml (prevents committing broken feed)\n\nPRIORITY: P2 (Prevents broken releases reaching users)\n\nESTIMATED TIME: 25-35 minutes (write script, add retry logic, test with real release)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:07:20.316063-05:00","updated_at":"2025-12-27T18:03:07.542979-05:00","closed_at":"2025-12-27T18:03:07.542979-05:00","close_reason":"Closed","dependencies":[{"issue_id":"oc-c9x.8","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:07:20.31654-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.8","depends_on_id":"oc-c9x.7","type":"blocks","created_at":"2025-12-12T23:54:09.172349-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":22,"issue_id":"oc-c9x.8","author":"Chris Edwards","text":"Created check-release-assets.sh verification script. Validates release exists, assets present, CDN accessible (with retry), content-type, file size, and download test. Supports --skip-dsym flag. All 273 tests pass. Commit: d05fdee","created_at":"2025-12-27T23:03:02Z"}]}
{"id":"oc-c9x.9","title":"Document Required Environment Variables","description":"BACKGROUND: Release scripts require several environment variables for API authentication and code signing. Documentation ensures developers can set up release environment correctly.\n\nPROBLEM: Missing env vars cause cryptic errors mid-release, insecure storage in scripts, developers unsure what values needed, credentials scattered across tools.\n\nREQUIRED ENVIRONMENT VARIABLES:\n\n1. APP_STORE_CONNECT_API_KEY_P8: Base64-encoded .p8 file from App Store Connect API (used for notarization)\n   How to get: App Store Connect \u003e Users and Access \u003e Keys \u003e Generate API Key (role: Developer or Admin)\n   Download: AuthKey_KEYID.p8 (ONLY AVAILABLE ONCE, save securely)\n   Format: base64 -i AuthKey_KEYID.p8 | tr -d newline (single line, no whitespace)\n\n2. APP_STORE_CONNECT_KEY_ID: 10-character alphanumeric identifier (e.g., AB12CD34EF)\n   Location: App Store Connect API Keys page, shown next to key name\n\n3. APP_STORE_CONNECT_ISSUER_ID: UUID format issuer ID (e.g., 12345678-1234-1234-1234-123456789012)\n   Location: App Store Connect API Keys page, at top of page\n\n4. SPARKLE_PRIVATE_KEY_FILE: Path to ed25519 private key file for signing updates\n   Generated by: generate_keys tool from Sparkle\n   Format: Single-line base64, no comments, no PEM headers (cat key.pem | base64 | tr -d newline)\n   Security: NEVER commit to git, add to .gitignore\n\n5. DEVELOPER_ID_APPLICATION: (optional) Certificate name for codesign\n   Auto-detected: security find-identity -v -p codesigning (script finds automatically)\n   Format: \"Developer ID Application: Your Name (TEAM_ID)\"\n   Override: Only set if multiple certs and want specific one\n\nSETUP METHODS:\n\nMethod 1 - .env.local file (recommended):\nCreate .env.local in project root (add to .gitignore):\nexport APP_STORE_CONNECT_API_KEY_P8=\"base64string...\"\nexport APP_STORE_CONNECT_KEY_ID=\"AB12CD34EF\"\nexport APP_STORE_CONNECT_ISSUER_ID=\"uuid...\"\nexport SPARKLE_PRIVATE_KEY_FILE=\"/path/to/sparkle_private_key\"\nThen: source .env.local before running release scripts\n\nMethod 2 - Shell profile:\nAdd exports to ~/.zshrc or ~/.bash_profile\nAutomatically loaded in every shell session\nRisk: Available to all processes\n\nMethod 3 - 1Password/Keychain script:\nStore in 1Password, retrieve via CLI: op item get \"Release Vars\" --fields credential\nMore secure, requires 1Password CLI setup\n\nSECURITY BEST PRACTICES:\n- Never commit env vars to git (add .env.local to .gitignore)\n- Use 1Password/keychain for storage, not plain text files\n- Rotate API keys annually\n- Restrict access to release machine\n- Use separate keys for different projects\n- Review key usage in App Store Connect regularly\n- Delete old/unused keys\n- P8 file downloadable only once (backup securely)\n\nVERIFICATION:\necho $APP_STORE_CONNECT_KEY_ID (should output key ID)\ntest -f \"$SPARKLE_PRIVATE_KEY_FILE\" (should exit 0)\nfile \"$SPARKLE_PRIVATE_KEY_FILE\" (should show ASCII text)\n\nCOMMON ISSUES:\n- P8 file multi-line: Use tr -d newline to make single line\n- Quotes in shell: Use double quotes for variables with spaces\n- Whitespace in base64: Breaks parsing, strip with tr -d newline space\n- Wrong key permissions: chmod 600 for private key files\n- Expired certificates: Renew at developer.apple.com\n\nDOCUMENTATION LOCATION: Create docs/RELEASE_ENVIRONMENT.md with: list of required vars, how to obtain each, setup instructions, security guidelines, troubleshooting section.\n\nTEMPLATE .env.local file:\n# Optimus Clip Release Environment\n# Copy to .env.local and fill in your values\nexport APP_STORE_CONNECT_API_KEY_P8=\"PASTE_BASE64_HERE\"\nexport APP_STORE_CONNECT_KEY_ID=\"YOUR_KEY_ID\"\nexport APP_STORE_CONNECT_ISSUER_ID=\"YOUR_ISSUER_ID\"\nexport SPARKLE_PRIVATE_KEY_FILE=\"/secure/path/sparkle_private_key\"\n\nTESTING: Source .env.local, run echo for each variable, verify all set, run release.sh --dry-run to verify scripts can access.\n\nSUCCESS: Documentation created, .env.local template provided, all required vars documented with examples, security guidelines clear, verification commands provided","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:07:46.311342-05:00","updated_at":"2025-12-16T19:48:26.835241-05:00","closed_at":"2025-12-16T19:48:26.835241-05:00","close_reason":"Created .env.local.template with all required env vars, verification commands, and security notes. docs/RELEASE_PREREQUISITES.md already has detailed setup instructions.","dependencies":[{"issue_id":"oc-c9x.9","depends_on_id":"oc-c9x","type":"parent-child","created_at":"2025-12-12T22:07:46.311885-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-c9x.9","depends_on_id":"oc-c9x.6","type":"blocks","created_at":"2025-12-12T23:54:09.850477-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-ch1","title":"Fix unnecessary let pattern warning in ErrorRecoveryManager","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-16T19:41:14.149426-05:00","updated_at":"2025-12-16T20:35:11.307777-05:00","closed_at":"2025-12-16T20:35:11.307777-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:44:43.933559-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-cru","title":"Ollama provider check always returns true breaking badge logic","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-16T19:31:31.539302-05:00","updated_at":"2025-12-16T20:35:11.30841-05:00","closed_at":"2025-12-16T20:35:11.30841-05:00","close_reason":"Closing tombstone issues - already resolved","comments":[{"id":14,"issue_id":"oc-cru","author":"Chris Edwards","text":"## Root Cause Analysis\n\nMenuBarStateManager.swift lines 304-307:\n```swift\n// Check Ollama (just needs host configured, no API key required)\nlet ollamaHost = UserDefaults.standard.string(forKey: SettingsKey.ollamaHost) ?? \"\"\nif !ollamaHost.isEmpty {\n    return true\n}\n```\n\nBut DefaultSettings.ollamaHost is \"http://localhost\" (not empty).\n\nSo the check \"is ollamaHost non-empty\" ALWAYS returns true because the default is non-empty.\n\n## Impact\n- Badge logic breaks: hasConfiguredProvider always returns true\n- Users never see \"setupIncomplete\" yellow badge even when no provider is configured\n- The entire badge feature for missing LLM config doesn't work\n\n## Recommended Fix\nCheck if value differs from default, or check if Ollama is actually running:\n```swift\nlet ollamaHost = UserDefaults.standard.string(forKey: SettingsKey.ollamaHost)\n// Only count as configured if user explicitly set a value (not default)\nif ollamaHost != nil \u0026\u0026 ollamaHost != DefaultSettings.ollamaHost {\n    return true\n}\n```","created_at":"2025-12-17T00:31:58Z"}],"deleted_at":"2025-12-16T19:36:00.761471-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-dab","title":"PERFORMANCE: ClipboardMonitor 150ms polling causes battery drain","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-16T19:54:52.609934-05:00","updated_at":"2025-12-16T20:35:11.301873-05:00","closed_at":"2025-12-16T20:35:11.301873-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T20:05:29.849344-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-fmw","title":"Fix Optimus Clip Icons randomly showing on menubar","description":"I have two Optimus Clip icons in addition to the main icon showing on my menu bar in macOS in odd places. One of them is a black colored icon that is lower on the menu bar and way to the left. The other is a light gray menu bar icon for Optimus Prime that is a little higher and just slightly to the left of the regular icon.\n\nThe regular icon is still there, but the other icons I'm assuming are related to the pulsing of the icon that is supposed to happen when it's working, and it's just cluttered all over my menu bar and I don't know why. This needs to be fixed.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-16T09:44:16.440171-05:00","updated_at":"2025-12-27T17:23:15.493727-05:00","closed_at":"2025-12-27T17:23:15.493727-05:00","close_reason":"Fixed: bundle guards in NotificationService (5f4f6f2) + simplified MenuBarStateManager removing badge feature (b972b2e)","comments":[{"id":17,"issue_id":"oc-fmw","author":"Chris Edwards","text":"Root cause: NotificationService crash without app bundle cascaded through MenuBarStateManager. Fixed with bundle guards (commit 5f4f6f2). Additional cleanup: removed badge feature that added unnecessary complexity and potential for UI artifacts.","created_at":"2025-12-27T22:22:43Z"}]}
{"id":"oc-g12","title":"Menu bar icon does not pulse during transformation","description":"When a transformation runs, the menu bar icon should pulse/animate to provide visual feedback. HotkeyManager calls menuBarStateManager?.startProcessing() and stopProcessing() but no visual effect shows. The MenuBarStateManager reference may not be set, or the pulse animation may not be implemented.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-13T17:07:05.072976-05:00","updated_at":"2025-12-13T18:33:45.042602-05:00","closed_at":"2025-12-13T18:33:45.042602-05:00"}
{"id":"oc-gtz","title":"Fix Sparkle.framework not bundled in app package","description":"## Problem\nWhen running the packaged OptimusClip.app, the app crashes on launch with:\n```\ndyld: Library not loaded: @rpath/Sparkle.framework/Versions/B/Sparkle\n```\n\n## Root Cause\nThe `package_app.sh` script does not copy Sparkle.framework into the app bundle's Frameworks directory.\n\n## Fix\nUpdate `Scripts/package_app.sh` to:\n1. Create Contents/Frameworks directory\n2. Copy Sparkle.framework from build artifacts\n3. The codesign --deep flag already handles signing embedded frameworks","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-27T19:12:54.036522-05:00","created_by":"Chris Edwards","updated_at":"2025-12-27T19:14:28.465029-05:00","closed_at":"2025-12-27T19:14:28.465029-05:00","close_reason":"Fixed by bundling Sparkle.framework and adding rpath. Commit f583370."}
{"id":"oc-h55","title":"Add Optimus Clip mascot to README","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-14T22:59:11.286595-05:00","updated_at":"2025-12-14T22:59:29.03845-05:00","closed_at":"2025-12-14T22:59:29.03845-05:00"}
{"id":"oc-j0g","title":"Phase 4 - Transformation Engine","description":"BACKGROUND \u0026 CONTEXT:\n=====================\nPhase 4 is the core algorithmic heart of Optimus Clip. This phase implements the transformation pipeline that processes clipboard content in real-time. While later phases will add LLM-based transformations, Phase 4 focuses on fast, algorithmic \"Quick Fix\" transformations that can execute in \u003c100ms.\n\nWHY THIS IS NEEDED:\n==================\nClipboard content often arrives in problematic formats:\n- CLI tool outputs (like Claude Code) often have 2-space leading indentation\n- Text copied from terminals/emails gets hard-wrapped at 80 characters\n- These formatting artifacts break when pasted into code, docs, or prompts\n\nThe transformation engine solves this by providing instant, hotkey-triggered fixes that run before the content reaches its destination.\n\nARCHITECTURAL ROLE:\n==================\nThe transformation engine sits between:\n1. Clipboard monitoring (Phase 2) - detects changes\n2. Hotkey system (Phase 3) - triggers transformations\n3. Clipboard writing (Phase 2) - outputs transformed result\n\nThis phase creates:\n- Core transformation protocol/interface\n- Built-in algorithmic transformations (whitespace, unwrap)\n- Pipeline architecture for chaining transforms\n- Registry system for transformation lookup\n- Integration with hotkey triggers\n\nSUCCESS CRITERIA:\n================\n- Whitespace stripping works on real CLI outputs\n- Smart unwrap joins hard-wrapped text without corrupting code\n- All transformations complete in \u003c100ms\n- Hotkeys successfully trigger transformations\n- Code blocks are preserved without corruption\n\nDEPENDENCIES:\n============\nDepends on Phase 3 (Hotkey System) being complete - we need hotkey events to trigger transformations.\n\nTECHNICAL APPROACH:\n==================\n1. Create OptimusClipCore Swift module for shared transformation logic\n2. Define Transformation protocol with async support\n3. Implement algorithmic transforms (strip, unwrap)\n4. Add code detection/preservation logic\n5. Build pipeline and registry architecture\n6. Wire hotkey events to transformation execution\n\nEDGE CASES \u0026 SAFETY:\n===================\n- MUST NOT corrupt code blocks (braces, indentation-sensitive languages)\n- MUST handle mixed content (some wrapped, some code)\n- MUST fail gracefully if transformation errors occur\n- MUST preserve clipboard if transformation fails\n- Performance: must feel instant (\u003c100ms) for user experience","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-12T22:04:43.516312-05:00","updated_at":"2025-12-13T15:48:22.082488-05:00","closed_at":"2025-12-13T15:48:22.082488-05:00","dependencies":[{"issue_id":"oc-j0g","depends_on_id":"oc-4tw","type":"blocks","created_at":"2025-12-13T09:40:11.938238-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-j0g.1","title":"TransformationCore Module","description":"## Task: TransformationCore Module\n\n### Background \u0026 Architectural Purpose\n\nTransformationCore is a separate Swift module that contains all transformation logic, completely independent of the main app. This separation is a deliberate architectural decision with multiple benefits.\n\n### Why a Separate Module?\n\n**1. Testability**\n```swift\n// In OptimusClipTests - can test without launching app\nimport OptimusClipCore\n\nfunc testWhitespaceStrip() {\n    let transform = WhitespaceStripTransformation()\n    let result = transform.transform(\"  Hello\\n  World\")\n    XCTAssertEqual(result, \"Hello\\nWorld\")\n}\n```\nWithout a separate module, testing transformations would require instantiating the entire app context.\n\n**2. Reusability**\nThe core logic could be used in:\n- Future CLI tool (`optimus-clip-cli`)\n- Other apps that need text transformation\n- Shared framework for multiple platforms\n\n**3. Clean Dependency Graph**\n```\nOptimusClip (app)\n    └── depends on → OptimusClipCore (library)\n                          └── NO app dependencies\n\nOptimusClipTests\n    └── depends on → OptimusClipCore (can test without app)\n```\n\n**4. Build Time Optimization**\n- Changes to UI don't rebuild Core\n- Changes to Core don't rebuild UI (unless interface changes)\n- Faster incremental builds\n\n### The Transformation Protocol\n\nThe foundation of the module is a simple, extensible protocol:\n\n```swift\n/// Protocol for all text transformations in Optimus Clip\npublic protocol Transformation {\n    /// Unique identifier for this transformation\n    var id: String { get }\n\n    /// Human-readable name for UI display\n    var displayName: String { get }\n\n    /// Transform input text to output text\n    /// - Parameter input: The original text from clipboard\n    /// - Returns: Transformed text ready for paste\n    func transform(_ input: String) async throws -\u003e String\n}\n```\n\n**Why `async throws`?**\n- `async`: LLM transformations are network calls (take seconds)\n- `throws`: Network failures, timeouts, API errors\n- Algorithmic transforms can simply return synchronously via `async` wrapper\n\n### Built-in Transformations\n\nThe module provides these out-of-the-box transformations:\n\n```swift\n// Algorithmic (instant, no network)\npublic struct WhitespaceStripTransformation: Transformation { }\npublic struct SmartUnwrapTransformation: Transformation { }\n\n// LLM-based (requires provider configuration)\npublic struct LLMTransformation: Transformation {\n    let provider: LLMProvider\n    let model: String\n    let systemPrompt: String\n}\n```\n\n### Module Structure\n\n```\nSources/OptimusClipCore/\n├── Transformation.swift           # Protocol definition\n├── TransformationError.swift      # Error types\n├── Transformations/\n│   ├── WhitespaceStrip.swift      # Remove leading whitespace\n│   ├── SmartUnwrap.swift          # Unwrap hard-wrapped text\n│   └── LLMTransformation.swift    # LLM-based transforms\n├── Detection/\n│   ├── CodeDetector.swift         # Detect code in text\n│   └── ContentAnalyzer.swift      # Analyze text characteristics\n└── Utilities/\n    ├── StringExtensions.swift     # Helper extensions\n    └── TextProcessing.swift       # Common processing functions\n```\n\n### Error Handling\n\n```swift\npublic enum TransformationError: Error, LocalizedError {\n    case emptyInput\n    case timeout(seconds: Int)\n    case networkError(underlying: Error)\n    case providerError(message: String)\n    case rateLimited(retryAfter: TimeInterval?)\n    case invalidAPIKey\n    case contentTooLarge(bytes: Int, limit: Int)\n\n    public var errorDescription: String? {\n        switch self {\n        case .emptyInput:\n            return \"No text to transform\"\n        case .timeout(let seconds):\n            return \"Transformation timed out after \\(seconds) seconds\"\n        case .networkError:\n            return \"Network connection failed\"\n        case .providerError(let message):\n            return \"Provider error: \\(message)\"\n        case .rateLimited(let retryAfter):\n            if let seconds = retryAfter {\n                return \"Rate limited. Try again in \\(Int(seconds)) seconds\"\n            }\n            return \"Rate limited. Please wait and try again\"\n        case .invalidAPIKey:\n            return \"Invalid API key\"\n        case .contentTooLarge(let bytes, let limit):\n            return \"Content too large (\\(bytes) bytes, limit \\(limit))\"\n        }\n    }\n}\n```\n\n### Configuration Pattern\n\nTransformations can be configured:\n\n```swift\npublic struct TransformationConfig: Codable, Identifiable {\n    public var id: UUID\n    public var name: String\n    public var type: TransformationType\n    public var isEnabled: Bool\n\n    // Algorithmic config\n    public var algorithmicOptions: AlgorithmicOptions?\n\n    // LLM config\n    public var provider: LLMProvider?\n    public var model: String?\n    public var systemPrompt: String?\n    public var timeout: TimeInterval?\n}\n\npublic enum TransformationType: String, Codable {\n    case algorithmic\n    case llm\n}\n```\n\n### Factory Pattern for Instantiation\n\n```swift\npublic struct TransformationFactory {\n    /// Create a transformation from configuration\n    public static func create(from config: TransformationConfig) -\u003e Transformation {\n        switch config.type {\n        case .algorithmic:\n            // Combine algorithmic transformations based on options\n            return CompositeTransformation(\n                whitespace: config.algorithmicOptions?.stripWhitespace ?? true,\n                unwrap: config.algorithmicOptions?.smartUnwrap ?? true\n            )\n\n        case .llm:\n            guard let provider = config.provider,\n                  let model = config.model else {\n                fatalError(\"LLM transformation requires provider and model\")\n            }\n            return LLMTransformation(\n                provider: provider,\n                model: model,\n                systemPrompt: config.systemPrompt ?? \"\",\n                timeout: config.timeout ?? 30\n            )\n        }\n    }\n}\n```\n\n### Package.swift Integration\n\n```swift\n// In Package.swift\ntargets: [\n    // Core library - no app dependencies\n    .target(\n        name: \"OptimusClipCore\",\n        dependencies: []  // Minimal dependencies!\n    ),\n\n    // Main app - depends on Core\n    .executableTarget(\n        name: \"OptimusClip\",\n        dependencies: [\n            \"OptimusClipCore\",\n            \"KeyboardShortcuts\",\n            \"MenuBarExtraAccess\",\n        ]\n    ),\n\n    // Tests - can test Core in isolation\n    .testTarget(\n        name: \"OptimusClipTests\",\n        dependencies: [\"OptimusClipCore\"]\n    ),\n]\n```\n\n### Public API Surface\n\nOnly expose what's needed:\n\n```swift\n// Public - used by app and tests\npublic protocol Transformation { }\npublic struct TransformationConfig { }\npublic struct TransformationFactory { }\npublic enum TransformationError { }\n\n// Internal - implementation details\nstruct CodeDetector { }  // Not public\nstruct TextAnalyzer { }  // Not public\n```\n\n### Testing Strategy\n\n```swift\nimport Testing\n@testable import OptimusClipCore\n\n@Test func whitespaceStripBasic() async throws {\n    let transform = WhitespaceStripTransformation()\n    let result = try await transform.transform(\"  Hello\")\n    #expect(result == \"Hello\")\n}\n\n@Test func unwrapPreservesCode() async throws {\n    let code = \"def foo():\\n    pass\"\n    let transform = SmartUnwrapTransformation()\n    let result = try await transform.transform(code)\n    #expect(result == code)  // Unchanged - code detected\n}\n\n@Test func llmTimeoutThrows() async throws {\n    let transform = LLMTransformation(\n        provider: .openai,\n        model: \"gpt-4\",\n        systemPrompt: \"Test\",\n        timeout: 0.001  // Immediate timeout\n    )\n    await #expect(throws: TransformationError.self) {\n        try await transform.transform(\"Hello\")\n    }\n}\n```\n\n### Success Criteria\n- [ ] OptimusClipCore module compiles independently\n- [ ] No dependencies on AppKit/SwiftUI in Core\n- [ ] All transformations implement Transformation protocol\n- [ ] Tests pass without launching app\n- [ ] Factory creates correct transformation types\n- [ ] Error types provide user-friendly messages","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:05:02.349675-05:00","updated_at":"2025-12-13T13:03:22.728108-05:00","closed_at":"2025-12-13T13:03:22.728108-05:00","dependencies":[{"issue_id":"oc-j0g.1","depends_on_id":"oc-j0g","type":"parent-child","created_at":"2025-12-13T09:39:50.512077-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.1","depends_on_id":"oc-4tw","type":"blocks","created_at":"2025-12-13T09:40:22.669149-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-j0g.2","title":"Whitespace Strip Transformation","description":"## Task: Whitespace Strip Transformation\n\n### Background \u0026 The Real-World Problem\n\nWhen copying text from CLI tools like Claude Code, Codex, or terminal output, the text often comes with unwanted leading whitespace. This is because CLI tools typically indent their output for visual clarity:\n\n**What You Copy:**\n```\n  Here is the response from the CLI tool.\n  It has 2 spaces at the start of every line.\n  This is common in terminal output.\n```\n\n**What You Want:**\n```\nHere is the response from the CLI tool.\nIt has 2 spaces at the start of every line.\nThis is common in terminal output.\n```\n\nThis 2-space indentation is a visual convention in many CLI tools but becomes noise when pasting into documents, code, or chat.\n\n### Why This Specific Transformation?\n\n**The 2-Space Convention:**\n- Claude Code indents responses with 2 spaces\n- Many terminal tools use similar conventions\n- Copy-pasting preserves this unwanted indentation\n- Manual cleanup is tedious and error-prone\n\n**Not Just \"Trim Whitespace\":**\n- We DON'T want to remove ALL leading whitespace (that breaks code)\n- We specifically target CONSISTENT indentation patterns\n- We detect and strip the COMMON prefix across all lines\n\n### Algorithm: Common Prefix Stripping\n\n**The Smart Approach:**\n1. Split text into lines\n2. Find the shortest leading whitespace among non-empty lines\n3. Strip exactly that much from every line\n4. Preserve relative indentation within the text\n\n**Example:**\n```\nInput:\n    def hello():        # 4 spaces\n        print(\"hi\")     # 8 spaces\n\nOutput:\ndef hello():            # 0 spaces\n    print(\"hi\")         # 4 spaces (relative preserved)\n```\n\n**The Algorithm:**\n```swift\nfunc stripCommonLeadingWhitespace(_ text: String) -\u003e String {\n    let lines = text.components(separatedBy: \"\\n\")\n\n    // Find minimum indentation (ignoring empty lines)\n    let minIndent = lines\n        .filter { !$0.trimmingCharacters(in: .whitespaces).isEmpty }\n        .map { $0.prefix(while: { $0.isWhitespace }).count }\n        .min() ?? 0\n\n    // If no common indentation, return unchanged\n    guard minIndent \u003e 0 else { return text }\n\n    // Strip the common prefix from each line\n    return lines.map { line in\n        if line.count \u003e= minIndent {\n            return String(line.dropFirst(minIndent))\n        }\n        return line  // Empty or short lines unchanged\n    }.joined(separator: \"\\n\")\n}\n```\n\n### Edge Cases \u0026 Safety\n\n**1. Code Detection (CRITICAL):**\nIf the text appears to be code, we should be MORE careful:\n```swift\nfunc appearsToBeCode(_ text: String) -\u003e Bool {\n    let codeIndicators = [\n        \"func \", \"def \", \"class \", \"import \",\n        \"const \", \"let \", \"var \",\n        \"{\", \"}\", \"=\u003e\", \"-\u003e\",\n        \"if \", \"for \", \"while \",\n    ]\n    return codeIndicators.contains { text.contains($0) }\n}\n```\n\nFor code: Only strip if ALL lines share the same leading whitespace (very conservative).\n\n**2. Empty Lines:**\n- Empty lines should remain empty\n- Don't count them when calculating minimum indent\n- Don't try to strip from them\n\n**3. Tabs vs Spaces:**\n- Treat tabs and spaces as whitespace\n- Don't mix them (strip only if consistent)\n- Preserve original whitespace type\n\n**4. Single Line Input:**\n- No common prefix to find\n- Strip leading whitespace entirely? Or preserve?\n- Decision: Strip for single lines (most common use case)\n\n**5. Mixed Indentation:**\n```\n    Line with 4 spaces\n  Line with 2 spaces\n      Line with 6 spaces\n```\n- Common prefix is 2 spaces\n- Result: 2, 0, 4 spaces (preserves relative structure)\n\n### Configuration Options\n\n```swift\nstruct WhitespaceStripConfig {\n    /// Minimum spaces to strip (0 = auto-detect)\n    var minimumStrip: Int = 0\n\n    /// Maximum spaces to strip (prevents over-stripping)\n    var maximumStrip: Int = 8\n\n    /// Strip trailing whitespace too?\n    var stripTrailing: Bool = true\n\n    /// Be extra conservative with code-like content?\n    var preserveCodeIndentation: Bool = true\n}\n```\n\n### Implementation\n\n```swift\nstruct WhitespaceStripTransformation: Transformation {\n    let config: WhitespaceStripConfig\n\n    func transform(_ input: String) -\u003e String {\n        var result = input\n\n        // 1. Strip common leading whitespace\n        result = stripCommonLeadingWhitespace(result)\n\n        // 2. Optionally strip trailing whitespace per line\n        if config.stripTrailing {\n            result = result\n                .components(separatedBy: \"\\n\")\n                .map { $0.trimmingCharacters(in: .init(charactersIn: \" \\t\")) }\n                .joined(separator: \"\\n\")\n        }\n\n        // 3. Normalize line endings (optional)\n        result = result.replacingOccurrences(of: \"\\r\\n\", with: \"\\n\")\n\n        return result\n    }\n\n    private func stripCommonLeadingWhitespace(_ text: String) -\u003e String {\n        let lines = text.components(separatedBy: \"\\n\")\n\n        // Find non-empty lines\n        let nonEmptyLines = lines.filter { !$0.trimmingCharacters(in: .whitespaces).isEmpty }\n        guard !nonEmptyLines.isEmpty else { return text }\n\n        // Calculate minimum indentation\n        let minIndent = nonEmptyLines\n            .map { line -\u003e Int in\n                var count = 0\n                for char in line {\n                    if char == \" \" { count += 1 }\n                    else if char == \"\\t\" { count += 4 }  // Treat tab as 4 spaces\n                    else { break }\n                }\n                return count\n            }\n            .min() ?? 0\n\n        // Apply maximum limit\n        let stripAmount = min(minIndent, config.maximumStrip)\n        guard stripAmount \u003e 0 else { return text }\n\n        // Strip from each line\n        return lines.map { line in\n            var remaining = stripAmount\n            var result = \"\"\n            for char in line {\n                if remaining \u003e 0 \u0026\u0026 (char == \" \" || char == \"\\t\") {\n                    remaining -= (char == \"\\t\" ? 4 : 1)\n                } else {\n                    result.append(char)\n                }\n            }\n            return result\n        }.joined(separator: \"\\n\")\n    }\n}\n```\n\n### Performance Considerations\n\n- **Complexity:** O(n) where n = total characters\n- **Memory:** Single pass, minimal allocations\n- **Target:** \u003c 10ms for 10KB of text\n- **Optimization:** Use `Substring` to avoid copies where possible\n\n### Testing Checklist\n\n- [ ] 2-space indented text → stripped correctly\n- [ ] 4-space indented code → relative indentation preserved\n- [ ] Mixed indentation → common prefix found and stripped\n- [ ] Empty lines → remain empty\n- [ ] Single line → leading whitespace stripped\n- [ ] No indentation → returned unchanged\n- [ ] Tab characters → handled correctly\n- [ ] Very long text (10KB+) → completes in \u003c 100ms\n\n### Success Criteria\n- Correctly strips CLI tool indentation (2-space)\n- Preserves code structure (relative indentation)\n- Handles edge cases gracefully\n- Performs within time budget (\u003c 100ms)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:05:27.167898-05:00","updated_at":"2025-12-13T13:27:19.120028-05:00","closed_at":"2025-12-13T13:27:19.120028-05:00","dependencies":[{"issue_id":"oc-j0g.2","depends_on_id":"oc-j0g","type":"parent-child","created_at":"2025-12-12T22:05:27.168457-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.2","depends_on_id":"oc-j0g.1","type":"blocks","created_at":"2025-12-12T22:05:27.169056-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-j0g.3","title":"Smart Unwrap Transformation","description":"## Task: Smart Unwrap Transformation\n\n### Background \u0026 The Real-World Problem\n\nText from older systems - emails, terminals, Usenet, git commit messages - is often \"hard-wrapped\" at a fixed column width (typically 72-80 characters). This was essential when displays had fixed widths, but today it creates visual noise and formatting problems.\n\n**The Problem Visualized:**\n\n**What You Copy (hard-wrapped at 72 chars):**\n```\nThis is a paragraph of text that was written in an email client\nthat automatically wrapped lines at 72 characters. Each line ends\nwith a hard return character, which modern editors treat as a new\nparagraph.\n```\n\n**What You Want (fluid paragraph):**\n```\nThis is a paragraph of text that was written in an email client that automatically wrapped lines at 72 characters. Each line ends with a hard return character, which modern editors treat as a new paragraph.\n```\n\n**Why This Matters:**\n- Hard-wrapped text looks broken in modern apps\n- Copy-paste from email/terminal disrupts workflows\n- Manual \"fixing\" is tedious (delete newline, add space, repeat)\n- Search/replace is dangerous (removes intentional breaks too)\n\n### Why This Is Genuinely Hard\n\nThis seems simple (\"just join lines\"), but naive approaches fail badly:\n\n**Naive Approach Failures:**\n\n1. **Join all lines** → Destroys paragraph breaks\n2. **Join unless blank line** → Destroys code indentation\n3. **Join lines under 80 chars** → Destroys poetry, lists, quotes\n\n**The Core Challenge:**\nDistinguish between:\n- **Hard wraps** (artificial breaks from line-length limits) → REMOVE\n- **Soft breaks** (intentional paragraph separations) → PRESERVE\n- **Structural breaks** (code, lists, quotes) → PRESERVE\n\n**There is no perfect solution.** We use heuristics that work for common cases.\n\n### The Smart Heuristic Algorithm\n\n**Core Insight:** Hard-wrapped paragraphs have suspiciously consistent line lengths.\n\nIf you see 5 consecutive lines that are all 70-75 characters, that is VERY unlikely to be coincidence. It is almost certainly hard-wrapped text.\n\n**Algorithm Overview:**\n\n```\n1. Split text into lines\n2. Group consecutive non-empty lines into \"blocks\"\n3. For each block:\n   a. Calculate line length statistics\n   b. If looks hard-wrapped → join with spaces\n   c. If looks intentional → preserve breaks\n4. Reassemble with original paragraph breaks\n```\n\n**Step 1: Block Detection**\n```swift\nfunc splitIntoBlocks(_ text: String) -\u003e [[String]] {\n    let lines = text.components(separatedBy: \"\\n\")\n    var blocks: [[String]] = []\n    var currentBlock: [String] = []\n\n    for line in lines {\n        if line.trimmingCharacters(in: .whitespaces).isEmpty {\n            if !currentBlock.isEmpty {\n                blocks.append(currentBlock)\n                currentBlock = []\n            }\n            blocks.append([\"\"]) // Preserve empty line as separator\n        } else {\n            currentBlock.append(line)\n        }\n    }\n\n    if !currentBlock.isEmpty {\n        blocks.append(currentBlock)\n    }\n\n    return blocks\n}\n```\n\n**Step 2: Hard-Wrap Detection**\n```swift\nfunc isHardWrapped(_ lines: [String]) -\u003e Bool {\n    // Need at least 3 lines to detect pattern\n    guard lines.count \u003e= 3 else { return false }\n\n    // Check for code indicators first\n    if containsCodeIndicators(lines) { return false }\n\n    // Calculate line lengths\n    let lengths = lines.map { $0.count }\n\n    // Check for consistency (within 5 characters of each other)\n    let sortedLengths = lengths.sorted()\n    let median = sortedLengths[sortedLengths.count / 2]\n\n    // Count lines within tolerance of median\n    let tolerance = 5\n    let consistentCount = lengths.filter { abs($0 - median) \u003c= tolerance }.count\n    let consistencyRatio = Double(consistentCount) / Double(lengths.count)\n\n    // Also check if lengths are in typical hard-wrap range (65-85 chars)\n    let inWrapRange = median \u003e= 65 \u0026\u0026 median \u003c= 85\n\n    // Hard-wrapped if high consistency AND in wrap range\n    return consistencyRatio \u003e= 0.7 \u0026\u0026 inWrapRange\n}\n```\n\n**Step 3: Code Detection**\n```swift\nfunc containsCodeIndicators(_ lines: [String]) -\u003e Bool {\n    let codeIndicators = [\n        \"func \", \"def \", \"class \", \"struct \", \"enum \",\n        \"import \", \"from \", \"require \", \"#include\",\n        \"if \", \"for \", \"while \", \"switch \", \"case \",\n        \"return \", \"throw \", \"try \", \"catch \",\n        \"{\", \"}\", \"=\u003e\", \"-\u003e\", \"//\", \"/*\", \"#\",\n    ]\n\n    for line in lines {\n        // Check for code keywords/symbols\n        for indicator in codeIndicators {\n            if line.contains(indicator) { return true }\n        }\n\n        // Check for indentation patterns (4+ spaces or tabs)\n        if line.hasPrefix(\"    \") || line.hasPrefix(\"\\t\") {\n            return true\n        }\n    }\n\n    return false\n}\n```\n\n**Step 4: Unwrap Block**\n```swift\nfunc unwrapBlock(_ lines: [String]) -\u003e String {\n    // Join lines with single space\n    // But first trim trailing whitespace from each line\n    return lines\n        .map { $0.trimmingCharacters(in: .whitespaces) }\n        .joined(separator: \" \")\n}\n```\n\n### Configuration Options\n\n```swift\nstruct SmartUnwrapConfig {\n    /// Minimum consecutive lines to consider a block \"wrapped\"\n    var minConsecutiveLines: Int = 3\n\n    /// Tolerance for line length consistency (characters)\n    var lengthTolerance: Int = 5\n\n    /// Typical hard-wrap line lengths (character range)\n    var wrapRangeLower: Int = 65\n    var wrapRangeUpper: Int = 85\n\n    /// Minimum consistency ratio to trigger unwrap\n    var consistencyThreshold: Double = 0.7\n\n    /// Always preserve code-like blocks\n    var preserveCodeBlocks: Bool = true\n\n    /// Preserve lines starting with specific characters (lists, quotes)\n    var preservePrefixes: [String] = [\"-\", \"*\", \"\u003e\", \"•\", \"1.\", \"2.\", \"3.\"]\n}\n```\n\n### Full Implementation\n\n```swift\nstruct SmartUnwrapTransformation: Transformation {\n    let config: SmartUnwrapConfig\n    let codeDetector: CodeDetector\n\n    init(config: SmartUnwrapConfig = .init(), codeDetector: CodeDetector = .init()) {\n        self.config = config\n        self.codeDetector = codeDetector\n    }\n\n    func transform(_ input: String) -\u003e String {\n        // Quick check: if high code confidence, return unchanged\n        if codeDetector.codeConfidence(input) \u003e 0.7 {\n            return input\n        }\n\n        // Split into blocks\n        let blocks = splitIntoBlocks(input)\n\n        // Process each block\n        var result: [String] = []\n        for block in blocks {\n            if block.count == 1 \u0026\u0026 block[0].isEmpty {\n                // Preserve empty line\n                result.append(\"\")\n            } else if shouldUnwrap(block) {\n                // Unwrap this block\n                result.append(unwrapBlock(block))\n            } else {\n                // Preserve original line breaks\n                result.append(contentsOf: block)\n            }\n        }\n\n        return result.joined(separator: \"\\n\")\n    }\n\n    private func shouldUnwrap(_ lines: [String]) -\u003e Bool {\n        // Too few lines to determine\n        guard lines.count \u003e= config.minConsecutiveLines else {\n            return false\n        }\n\n        // Check for code\n        if config.preserveCodeBlocks \u0026\u0026 containsCodeIndicators(lines) {\n            return false\n        }\n\n        // Check for list/quote prefixes\n        for prefix in config.preservePrefixes {\n            if lines.contains(where: { $0.hasPrefix(prefix) }) {\n                return false\n            }\n        }\n\n        // Check for hard-wrap pattern\n        return isHardWrapped(lines)\n    }\n\n    // ... helper methods as defined above\n}\n```\n\n### Edge Cases \u0026 Special Handling\n\n**1. Git Commit Messages:**\n```\nfeat: Add new feature\n\nThis commit adds a very important feature that\nsolves the problem described in issue #123. The\nimplementation follows the existing patterns.\n```\n- First line is always short (subject)\n- Body is often hard-wrapped at 72 chars\n- Algorithm correctly handles: subject unchanged, body unwrapped\n\n**2. Quoted Email Replies:**\n```\n\u003e This is the original message that was sent\n\u003e by the other person. It was wrapped at the\n\u003e time it was written.\n```\n- Lines start with `\u003e` prefix\n- Should NOT unwrap (preserve quote structure)\n- Handled by `preservePrefixes` config\n\n**3. Bulleted Lists:**\n```\n- First item in the list which might be\n  quite long\n- Second item\n- Third item\n```\n- First lines start with `-`\n- Continuation lines are indented\n- Should NOT unwrap (would destroy list structure)\n\n**4. Poetry / Intentional Short Lines:**\n```\nRoses are red,\nViolets are blue,\nSugar is sweet,\nAnd so are you.\n```\n- Lines are short but varied length\n- NOT hard-wrapped (no consistency pattern)\n- Algorithm correctly preserves\n\n**5. Mixed Content:**\n```\nHere is a paragraph of text that spans\nmultiple lines and is wrapped at around\nseventy-two characters per line.\n\ndef hello():\n    print(\"world\")\n\nAnd here is another paragraph of text\nthat continues after the code block.\n```\n- First block: unwrap\n- Code block: preserve\n- Third block: unwrap\n- Algorithm handles via block-level analysis\n\n### Performance Optimization\n\n**Target:** Process 10,000 lines in \u003c 100ms\n\n**Optimizations:**\n1. Single pass for block splitting\n2. Early exit on code detection\n3. Use `Substring` to avoid string copies\n4. Calculate statistics incrementally\n\n```swift\n// Efficient line length statistics\nfunc calculateLengthStats(_ lines: [String]) -\u003e (median: Int, variance: Double) {\n    let lengths = lines.map { $0.count }\n    let sorted = lengths.sorted()\n    let median = sorted[sorted.count / 2]\n\n    let squaredDiffs = lengths.map { Double(($0 - median) * ($0 - median)) }\n    let variance = squaredDiffs.reduce(0, +) / Double(lengths.count)\n\n    return (median, variance)\n}\n```\n\n### Testing Checklist\n\n- [ ] Hard-wrapped email → unwrapped to paragraphs\n- [ ] Regular paragraphs → preserved as-is\n- [ ] Code block → completely unchanged\n- [ ] Mixed prose + code → prose unwrapped, code preserved\n- [ ] Bulleted list → preserved\n- [ ] Quoted text (\u003e prefix) → preserved\n- [ ] Git commit message → subject preserved, body unwrapped if wrapped\n- [ ] Poetry/intentional short lines → preserved\n- [ ] Single line input → returned unchanged\n- [ ] Empty input → returned empty\n- [ ] Unicode text → handles correctly\n- [ ] 10,000+ lines → completes in \u003c 100ms\n\n### Success Criteria\n\n- [ ] Correctly unwraps typical hard-wrapped text (72-80 char lines)\n- [ ] Preserves intentional paragraph breaks\n- [ ] NEVER corrupts code (indentation, structure)\n- [ ] Handles mixed content correctly\n- [ ] Preserves lists, quotes, and special formats\n- [ ] Performance \u003c 100ms for 10,000 lines\n- [ ] Integrates with Code Preservation Safety (oc-j0g.4)\n\n### Architectural Connections\n\n- **TransformationCore Module (oc-j0g.1)**: Implements Transformation protocol\n- **Code Preservation Safety (oc-j0g.4)**: Uses CodeDetector for safety checks\n- **Whitespace Strip (oc-j0g.2)**: Often used in combination (strip then unwrap)\n- **Transformation Pipeline (oc-j0g.5)**: Can be chained with other transforms","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:06:10.631906-05:00","updated_at":"2025-12-13T13:36:35.670612-05:00","closed_at":"2025-12-13T13:36:35.670612-05:00","dependencies":[{"issue_id":"oc-j0g.3","depends_on_id":"oc-j0g","type":"parent-child","created_at":"2025-12-12T22:06:10.632604-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.3","depends_on_id":"oc-j0g.1","type":"blocks","created_at":"2025-12-12T22:06:10.633274-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.3","depends_on_id":"oc-j0g.4","type":"blocks","created_at":"2025-12-13T12:51:02.254334-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-j0g.4","title":"Code Preservation Safety","description":"## Task: Code Preservation Safety\n\n### Background \u0026 Critical Importance\n\nThis task is a SAFETY MECHANISM that prevents algorithmic transformations from corrupting code. When whitespace-stripping or unwrapping transformations run on code, they can destroy semantic meaning:\n\n**Disaster Scenario:**\n```python\n# Original Python code (correct)\ndef process():\n    if condition:\n        do_something()\n    else:\n        do_other()\n\n# After naive unwrapping (BROKEN)\ndef process(): if condition: do_something() else: do_other()\n```\n\nThe unwrapper saw consistent line lengths and merged them - destroying Python's indentation-based syntax.\n\n### Why Code Needs Special Treatment\n\n**Languages Where Whitespace Matters:**\n- **Python:** Indentation defines blocks\n- **YAML:** Indentation defines structure\n- **Makefile:** Tabs required for recipes\n- **Haskell:** Layout rule uses indentation\n\n**Languages Where Structure Matters:**\n- **All languages:** Braces `{}` define scope\n- **All languages:** Parentheses `()` group expressions\n- **All languages:** Breaking mid-statement causes syntax errors\n\n### Detection Strategy: Multi-Signal Approach\n\nWe use multiple signals to detect code, not just one:\n\n```swift\nstruct CodeDetector {\n    /// Returns confidence score 0.0 - 1.0 that text is code\n    func codeConfidence(_ text: String) -\u003e Double {\n        var signals: [Double] = []\n\n        // Signal 1: Braces and brackets\n        signals.append(hasBracesScore(text))\n\n        // Signal 2: Common keywords\n        signals.append(hasKeywordsScore(text))\n\n        // Signal 3: Indentation hierarchy\n        signals.append(hasIndentationHierarchyScore(text))\n\n        // Signal 4: Special syntax\n        signals.append(hasSpecialSyntaxScore(text))\n\n        // Signal 5: Line structure\n        signals.append(hasCodeLineStructureScore(text))\n\n        // Weighted average (braces and keywords most important)\n        let weights = [0.3, 0.3, 0.15, 0.15, 0.1]\n        return zip(signals, weights).map { $0 * $1 }.reduce(0, +)\n    }\n}\n```\n\n### Signal 1: Braces and Brackets\n\n```swift\nfunc hasBracesScore(_ text: String) -\u003e Double {\n    let braceChars = CharacterSet(charactersIn: \"{}[]\")\n    let braceCount = text.unicodeScalars.filter { braceChars.contains($0) }.count\n\n    // If we see braces, very likely code\n    if braceCount \u003e= 4 { return 1.0 }\n    if braceCount \u003e= 2 { return 0.7 }\n    if braceCount \u003e= 1 { return 0.3 }\n    return 0.0\n}\n```\n\n### Signal 2: Language Keywords\n\n```swift\nfunc hasKeywordsScore(_ text: String) -\u003e Double {\n    let codeKeywords = [\n        // Universal\n        \"function\", \"func\", \"def\", \"class\", \"interface\", \"struct\", \"enum\",\n        \"if\", \"else\", \"for\", \"while\", \"switch\", \"case\", \"return\",\n        \"import\", \"export\", \"from\", \"require\", \"include\",\n        \"const\", \"let\", \"var\", \"val\", \"mut\",\n        \"public\", \"private\", \"protected\", \"static\", \"async\", \"await\",\n        // Language-specific\n        \"fn\", \"impl\", \"trait\",  // Rust\n        \"fun\", \"suspend\",       // Kotlin\n        \"guard\", \"defer\",       // Swift\n    ]\n\n    let lowercaseText = text.lowercased()\n    let keywordMatches = codeKeywords.filter { lowercaseText.contains($0) }.count\n\n    if keywordMatches \u003e= 5 { return 1.0 }\n    if keywordMatches \u003e= 3 { return 0.7 }\n    if keywordMatches \u003e= 1 { return 0.4 }\n    return 0.0\n}\n```\n\n### Signal 3: Indentation Hierarchy\n\n```swift\nfunc hasIndentationHierarchyScore(_ text: String) -\u003e Double {\n    let lines = text.components(separatedBy: \"\\n\")\n    var indentLevels = Set\u003cInt\u003e()\n\n    for line in lines {\n        let indent = line.prefix(while: { $0 == \" \" || $0 == \"\\t\" }).count\n        if indent \u003e 0 {\n            indentLevels.insert(indent)\n        }\n    }\n\n    // Multiple distinct indent levels = likely code\n    if indentLevels.count \u003e= 3 { return 1.0 }\n    if indentLevels.count \u003e= 2 { return 0.6 }\n    return 0.0\n}\n```\n\n### Signal 4: Special Syntax\n\n```swift\nfunc hasSpecialSyntaxScore(_ text: String) -\u003e Double {\n    let syntaxPatterns = [\n        \"=\u003e\",           // Arrow functions\n        \"-\u003e\",           // Return type / lambda\n        \"::\",           // Namespace / method ref\n        \"===\", \"!==\",   // Strict equality\n        \"\u0026\u0026\", \"||\",     // Logical operators\n        \"#{\",           // String interpolation\n        \"$(\", \"${\",     // Shell/template\n        \"@\",            // Decorators/annotations\n        \"#include\", \"#define\", \"#import\",  // Preprocessor\n    ]\n\n    let matches = syntaxPatterns.filter { text.contains($0) }.count\n    if matches \u003e= 3 { return 1.0 }\n    if matches \u003e= 2 { return 0.6 }\n    if matches \u003e= 1 { return 0.3 }\n    return 0.0\n}\n```\n\n### Signal 5: Line Structure\n\n```swift\nfunc hasCodeLineStructureScore(_ text: String) -\u003e Double {\n    let lines = text.components(separatedBy: \"\\n\")\n\n    // Code often has lines ending in specific characters\n    let codeLineEndings = [\";\", \"{\", \"}\", \",\", \":\", \"(\", \")\"]\n    let codeEndingCount = lines.filter { line in\n        let trimmed = line.trimmingCharacters(in: .whitespaces)\n        return codeLineEndings.contains { trimmed.hasSuffix($0) }\n    }.count\n\n    let ratio = Double(codeEndingCount) / Double(max(lines.count, 1))\n    return min(ratio * 2, 1.0)  // Scale up, cap at 1.0\n}\n```\n\n### Using Code Detection in Transformations\n\n```swift\nstruct SmartUnwrapTransformation: Transformation {\n    let codeDetector = CodeDetector()\n\n    func transform(_ input: String) -\u003e String {\n        let confidence = codeDetector.codeConfidence(input)\n\n        if confidence \u003e 0.7 {\n            // High confidence it's code - DON'T unwrap\n            return input\n        }\n\n        if confidence \u003e 0.4 {\n            // Medium confidence - be conservative\n            return conservativeUnwrap(input)\n        }\n\n        // Low confidence - full unwrap\n        return fullUnwrap(input)\n    }\n\n    private func conservativeUnwrap(_ text: String) -\u003e String {\n        // Only unwrap paragraphs, preserve anything indented\n        // ...\n    }\n}\n```\n\n### Block-Level Detection\n\nSometimes code is embedded in prose. We need to detect code BLOCKS, not just overall text:\n\n```swift\nfunc detectCodeBlocks(_ text: String) -\u003e [Range\u003cString.Index\u003e] {\n    var codeBlocks: [Range\u003cString.Index\u003e] = []\n\n    // Pattern 1: Fenced code blocks (```)\n    let fencedPattern = try! NSRegularExpression(pattern: \"```[\\\\s\\\\S]*?```\")\n    // ... find matches\n\n    // Pattern 2: Indented blocks (4+ spaces consistent)\n    // ... detect blocks where all lines start with 4+ spaces\n\n    // Pattern 3: Inline patterns (function definitions, etc.)\n    // ... detect single lines that look like code\n\n    return codeBlocks\n}\n```\n\n### Configuration\n\n```swift\nstruct CodePreservationConfig {\n    /// Confidence threshold to skip transformation (0.0 - 1.0)\n    var skipThreshold: Double = 0.7\n\n    /// Confidence threshold for conservative mode\n    var conservativeThreshold: Double = 0.4\n\n    /// Always preserve fenced code blocks (```)\n    var preserveFencedBlocks: Bool = true\n\n    /// Always preserve 4-space indented blocks\n    var preserveIndentedBlocks: Bool = true\n}\n```\n\n### Integration with Transformation Pipeline\n\n```\nInput Text\n    │\n    ▼\n┌─────────────────────────────┐\n│   Code Detection Analysis   │ ← THIS TASK\n│   confidence = 0.85 (HIGH)  │\n└─────────────────────────────┘\n    │\n    ├─── confidence \u003e 0.7 ──→ SKIP transformation, return unchanged\n    │\n    ├─── confidence \u003e 0.4 ──→ CONSERVATIVE mode\n    │\n    ▼ (confidence ≤ 0.4)\n    Full transformation\n```\n\n### Testing Requirements\n\n| Input | Expected |\n|-------|----------|\n| Python function | confidence \u003e 0.7, preserved |\n| JavaScript with braces | confidence \u003e 0.7, preserved |\n| Plain prose paragraph | confidence \u003c 0.4, transformed |\n| Mixed prose + code | code blocks preserved, prose transformed |\n| Markdown with fenced code | fenced blocks preserved |\n| YAML config | confidence \u003e 0.6, conservative |\n| JSON data | confidence \u003e 0.7, preserved |\n\n### Success Criteria\n- [ ] Python code never unwrapped\n- [ ] JavaScript braces never broken\n- [ ] Plain text still transforms correctly\n- [ ] Fenced code blocks always preserved\n- [ ] Mixed content handled correctly\n- [ ] No false positives (prose detected as code)\n- [ ] No false negatives (code detected as prose)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-12T22:07:02.023167-05:00","updated_at":"2025-12-13T13:25:49.835494-05:00","closed_at":"2025-12-13T13:25:49.835494-05:00","dependencies":[{"issue_id":"oc-j0g.4","depends_on_id":"oc-j0g","type":"parent-child","created_at":"2025-12-12T22:07:02.023625-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.4","depends_on_id":"oc-j0g.1","type":"blocks","created_at":"2025-12-12T22:07:02.024252-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-j0g.5","title":"Transformation Pipeline Architecture","description":"BACKGROUND \u0026 CONTEXT:\nThe Transformation Pipeline is the execution engine that processes clipboard content through a series of text transformations. In Phase 4, we focus on algorithmic transformations (whitespace stripping and line unwrapping), with the architecture designed to support async LLM transformations in Phase 5.\n\nThe pipeline solves a critical sequencing problem: transformation order matters. For example:\n- Strip whitespace THEN unwrap (correct order)\n- Unwrap THEN strip whitespace (wrong - may leave partial indents)\n\nThe pipeline must be composable, allowing multiple transformations to chain together with the output of one becoming the input of the next. Each transformation can succeed or fail independently, requiring robust error handling and rollback capabilities.\n\nKey design goals:\n1. Sequential execution with result passing\n2. Early termination on error (fail-fast)\n3. Performance target: \u003c100ms for all algorithmic transforms combined\n4. Async-ready architecture (for Phase 5 LLM integration)\n5. Rollback to original on any stage failure\n\nREAL-WORLD PROBLEM/USE CASE:\nUser copies CLI output from Claude Code that has both problems:\n1. 2-space leading indent on every line (CLI decoration)\n2. Hard wraps at 80 characters (terminal width)\n\nOriginal clipboard:\n```\n  This is a very long line of text that was wrapped by the terminal at eighty\n  characters because that is the width of the user's terminal window and now\n  it looks terrible when pasted into Slack or a document editor.\n```\n\nUser presses hotkey (e.g., Cmd+Option+V) mapped to \"Quick Fix\" transformation.\n\nPipeline executes:\n1. **Stage 1 - Strip Whitespace Transform:**\n   - Input: Original text with 2-space indent\n   - Output: Text with indent removed\n   ```\n   This is a very long line of text that was wrapped by the terminal at eighty\n   characters because that is the width of the user's terminal window and now\n   it looks terrible when pasted into Slack or a document editor.\n   ```\n\n2. **Stage 2 - Unwrap Lines Transform:**\n   - Input: Output from Stage 1\n   - Detects consecutive lines of similar length (~80 chars)\n   - Joins them into single paragraph\n   - Output: Clean, unwrapped text\n   ```\n   This is a very long line of text that was wrapped by the terminal at eighty characters because that is the width of the user's terminal window and now it looks terrible when pasted into Slack or a document editor.\n   ```\n\n3. **Pipeline Result:**\n   - Text written back to clipboard\n   - Paste simulation triggered (Cmd+V)\n   - Text appears clean in target application\n\nWithout the pipeline architecture:\n- User would need separate hotkeys for each transformation\n- Manual execution in correct order\n- No automatic rollback on errors\n- Inconsistent results\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. TRANSFORMATION PROTOCOL:\n```swift\n/// Protocol defining a single transformation step\nprotocol Transformation: Sendable {\n    /// Unique identifier for this transformation\n    var id: String { get }\n    \n    /// Human-readable name\n    var name: String { get }\n    \n    /// Transform text synchronously (for algorithmic transforms)\n    func transform(_ text: String) throws -\u003e String\n    \n    /// Transform text asynchronously (for LLM transforms in Phase 5)\n    func transformAsync(_ text: String) async throws -\u003e String\n}\n\n/// Default implementation - sync transforms use sync method\nextension Transformation {\n    func transformAsync(_ text: String) async throws -\u003e String {\n        return try self.transform(text)\n    }\n}\n\n/// Errors that can occur during transformation\nenum TransformationError: Error {\n    case emptyInput\n    case invalidFormat\n    case processingFailed(String)\n    case timeout\n    case cancelled\n}\n```\n\n2. PIPELINE IMPLEMENTATION:\n```swift\n/// Executes a sequence of transformations\n@MainActor\nfinal class TransformationPipeline {\n    /// The ordered list of transformations to execute\n    private let transformations: [Transformation]\n    \n    /// Timeout for entire pipeline (default 5 seconds for algorithmic, 30s for LLM)\n    private let timeout: TimeInterval\n    \n    init(transformations: [Transformation], timeout: TimeInterval = 5.0) {\n        self.transformations = transformations\n        self.timeout = timeout\n    }\n    \n    /// Execute all transformations in sequence\n    /// - Parameter input: Original text from clipboard\n    /// - Returns: Transformed text\n    /// - Throws: TransformationError if any stage fails\n    func execute(_ input: String) async throws -\u003e String {\n        guard !input.isEmpty else {\n            throw TransformationError.emptyInput\n        }\n        \n        // Track intermediate results for debugging/rollback\n        var current = input\n        var stageResults: [(transform: String, output: String)] = []\n        \n        // Execute each transformation sequentially\n        for transform in self.transformations {\n            do {\n                // Apply transformation with timeout\n                let result = try await withTimeout(self.timeout) {\n                    try await transform.transformAsync(current)\n                }\n                \n                // Store result\n                stageResults.append((transform: transform.name, output: result))\n                current = result\n                \n            } catch {\n                // Log failure point for debugging\n                print(\"Pipeline failed at stage: \\(transform.name)\")\n                print(\"Error: \\(error)\")\n                \n                // Rethrow to trigger rollback\n                throw error\n            }\n        }\n        \n        return current\n    }\n    \n    /// Execute with timeout wrapper\n    private func withTimeout\u003cT\u003e(\n        _ duration: TimeInterval,\n        operation: @escaping () async throws -\u003e T\n    ) async throws -\u003e T {\n        try await withThrowingTaskGroup(of: T.self) { group in\n            // Add the operation\n            group.addTask {\n                try await operation()\n            }\n            \n            // Add timeout task\n            group.addTask {\n                try await Task.sleep(nanoseconds: UInt64(duration * 1_000_000_000))\n                throw TransformationError.timeout\n            }\n            \n            // Return first result (operation or timeout)\n            guard let result = try await group.next() else {\n                throw TransformationError.cancelled\n            }\n            \n            // Cancel remaining tasks\n            group.cancelAll()\n            \n            return result\n        }\n    }\n}\n```\n\n3. PIPELINE CONFIGURATION:\n```swift\n/// Defines a preset transformation configuration\nstruct TransformationPreset: Codable, Identifiable {\n    let id: String\n    let name: String\n    let transformationIDs: [String]  // IDs from registry\n    let isEnabled: Bool\n    let timeout: TimeInterval\n    \n    /// Built-in \"Quick Fix\" preset\n    static let quickFix = TransformationPreset(\n        id: \"builtin.quickfix\",\n        name: \"Quick Fix\",\n        transformationIDs: [\n            \"builtin.strip_whitespace\",\n            \"builtin.unwrap_lines\"\n        ],\n        isEnabled: true,\n        timeout: 5.0\n    )\n}\n```\n\n4. INTEGRATION WITH HOTKEY HANDLER:\n```swift\n/// Hotkey handler that triggers pipeline execution\n@MainActor\nfinal class HotkeyHandler {\n    private let clipboardMonitor: ClipboardMonitor\n    private let registry: TransformationRegistry\n    \n    func handleHotkey(presetID: String) async {\n        // 1. Read current clipboard\n        guard let originalText = clipboardMonitor.readClipboard() else {\n            print(\"No text on clipboard\")\n            return\n        }\n        \n        // 2. Get preset configuration\n        guard let preset = loadPreset(id: presetID) else {\n            print(\"Unknown preset: \\(presetID)\")\n            return\n        }\n        \n        // 3. Build transformation list from registry\n        let transforms = preset.transformationIDs.compactMap { id in\n            registry.transformation(for: id)\n        }\n        \n        guard !transforms.isEmpty else {\n            print(\"No valid transformations for preset\")\n            return\n        }\n        \n        // 4. Create and execute pipeline\n        let pipeline = TransformationPipeline(\n            transformations: transforms,\n            timeout: preset.timeout\n        )\n        \n        do {\n            // Show processing state\n            updateMenuBarState(.processing)\n            \n            // Execute transformations\n            let result = try await pipeline.execute(originalText)\n            \n            // Write to clipboard and paste\n            clipboardMonitor.writeClipboard(result)\n            simulatePaste()\n            \n            // Show success state briefly\n            updateMenuBarState(.success)\n            \n        } catch {\n            // On error, clipboard remains unchanged (automatic rollback)\n            print(\"Transformation failed: \\(error)\")\n            updateMenuBarState(.error)\n        }\n    }\n}\n```\n\n5. PERFORMANCE MONITORING:\n```swift\n/// Extension for performance tracking\nextension TransformationPipeline {\n    struct ExecutionMetrics {\n        let totalDuration: TimeInterval\n        let stageDurations: [(name: String, duration: TimeInterval)]\n        let inputCharCount: Int\n        let outputCharCount: Int\n    }\n    \n    func executeWithMetrics(_ input: String) async throws -\u003e (result: String, metrics: ExecutionMetrics) {\n        let startTime = Date()\n        var stageDurations: [(String, TimeInterval)] = []\n        var current = input\n        \n        for transform in self.transformations {\n            let stageStart = Date()\n            current = try await transform.transformAsync(current)\n            let stageDuration = Date().timeIntervalSince(stageStart)\n            stageDurations.append((transform.name, stageDuration))\n        }\n        \n        let totalDuration = Date().timeIntervalSince(startTime)\n        \n        let metrics = ExecutionMetrics(\n            totalDuration: totalDuration,\n            stageDurations: stageDurations,\n            inputCharCount: input.count,\n            outputCharCount: current.count\n        )\n        \n        return (current, metrics)\n    }\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- **Phase 2 (ClipboardMonitor):** Reads original text, writes transformed result\n- **Phase 3 (HotkeyManager):** Triggers pipeline execution via hotkey press\n- **Phase 4 (TransformationRegistry):** Looks up transformations by ID\n- **Phase 4 (Individual Transforms):** Strip whitespace, unwrap lines implementations\n- **Phase 5 (LLM Integration):** LLM transformations use async pipeline\n- **Phase 6 (History):** Logs pipeline execution metrics\n\nThe pipeline sits at the center of the application flow:\n```\nHotkey Press → HotkeyHandler \n            → Registry Lookup \n            → Pipeline Execution \n            → Clipboard Write \n            → Paste Simulation\n```\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. EMPTY INPUT:\n   - Pipeline throws TransformationError.emptyInput\n   - Hotkey handler should check clipboard before creating pipeline\n   - Don't show error to user (silent failure)\n\n2. VERY LARGE INPUT (\u003e1MB):\n   - Performance target may not be met\n   - Consider warning or truncation\n   - Test with 10K lines minimum\n\n3. TRANSFORMATION RETURNS EMPTY STRING:\n   - Valid result, but may be unexpected\n   - Log warning but don't treat as error\n   - User might want empty result\n\n4. TIMEOUT DURING EXECUTION:\n   - Pipeline throws TransformationError.timeout\n   - Original clipboard preserved (automatic rollback)\n   - Show error in menu bar briefly\n\n5. CANCELLATION:\n   - User might trigger another hotkey mid-execution\n   - Need to cancel in-flight pipeline\n   - Use Task cancellation properly\n\n6. TRANSFORMATION ORDER DEPENDENCY:\n   - Some orders produce different results\n   - Document recommended order in preset definitions\n   - Quick Fix: always strip THEN unwrap\n\n7. PARTIAL SUCCESS:\n   - If Stage 2 fails, Stage 1 result is lost\n   - This is correct behavior (rollback to original)\n   - Don't write partial results to clipboard\n\n8. UNICODE EDGE CASES:\n   - Transformations must handle Unicode correctly\n   - Don't break emoji or combining characters\n   - Use Swift String methods (not NSString)\n\n9. CONCURRENT PIPELINE EXECUTION:\n   - User might press hotkey twice quickly\n   - Need to queue or reject concurrent executions\n   - Use @MainActor to serialize\n\nTESTING REQUIREMENTS:\n\n1. UNIT TESTS:\n```swift\n@Test(\"Pipeline executes transformations in order\")\nfunc testPipelineOrder() async throws {\n    let transform1 = MockTransform(id: \"1\", suffix: \"A\")\n    let transform2 = MockTransform(id: \"2\", suffix: \"B\")\n    \n    let pipeline = TransformationPipeline(transformations: [transform1, transform2])\n    let result = try await pipeline.execute(\"Text\")\n    \n    #expect(result == \"TextAB\")\n}\n\n@Test(\"Pipeline fails fast on error\")\nfunc testFailFast() async throws {\n    let transform1 = MockTransform(id: \"1\", shouldThrow: false)\n    let transform2 = MockTransform(id: \"2\", shouldThrow: true)\n    let transform3 = MockTransform(id: \"3\", shouldThrow: false)\n    \n    let pipeline = TransformationPipeline(transformations: [transform1, transform2, transform3])\n    \n    #expect(throws: TransformationError.self) {\n        try await pipeline.execute(\"Text\")\n    }\n    \n    // Verify transform3 was never called\n    #expect(transform3.callCount == 0)\n}\n\n@Test(\"Pipeline handles empty input\")\nfunc testEmptyInput() async {\n    let pipeline = TransformationPipeline(transformations: [])\n    \n    #expect(throws: TransformationError.emptyInput) {\n        try await pipeline.execute(\"\")\n    }\n}\n\n@Test(\"Pipeline respects timeout\")\nfunc testTimeout() async {\n    let slowTransform = MockTransform(id: \"slow\", delay: 10.0)\n    let pipeline = TransformationPipeline(transformations: [slowTransform], timeout: 0.1)\n    \n    #expect(throws: TransformationError.timeout) {\n        try await pipeline.execute(\"Text\")\n    }\n}\n```\n\n2. INTEGRATION TESTS:\n   - Create pipeline with real transformations (strip + unwrap)\n   - Execute on sample CLI output\n   - Verify output matches expected result\n   - Measure execution time (\u003c100ms)\n\n3. PERFORMANCE TESTS:\n   - 10K line input should complete in \u003c100ms\n   - 100 sequential pipeline executions should not leak memory\n   - Concurrent execution should be serialized (no race conditions)\n\n4. ERROR HANDLING TESTS:\n   - Verify original clipboard preserved on error\n   - Verify menu bar state updates correctly\n   - Verify timeout works as expected\n\nSUCCESS CRITERIA:\n- Pipeline executes transformations sequentially\n- Output of one stage becomes input of next\n- Errors trigger rollback (clipboard unchanged)\n- Performance: \u003c100ms for algorithmic transforms\n- Timeout works correctly (default 5s)\n- Async architecture supports future LLM integration\n- Unit tests pass with \u003e90% coverage\n- Integration test with real transforms succeeds\n\nCONFIGURATION OPTIONS:\n- Timeout per pipeline (default 5s, 30s for LLM)\n- Max input size (default unlimited, configurable limit)\n- Retry on transient failures (default: no retry)\n- Log intermediate results (debug mode)\n\nPERFORMANCE CONSIDERATIONS:\n- Sequential execution is intentional (order matters)\n- Algorithmic transforms should be \u003c50ms each\n- Total pipeline \u003c100ms target for Phase 4\n- Phase 5 LLM transforms will be 1-5 seconds\n- Use async/await to avoid blocking main thread\n- Timeout prevents indefinite hangs\n\nIMPLEMENTATION ORDER:\n1. Define Transformation protocol\n2. Implement TransformationPipeline class\n3. Add timeout wrapper\n4. Implement error handling and rollback\n5. Add performance metrics (optional)\n6. Write unit tests\n7. Create TransformationPreset struct\n8. Integrate with HotkeyHandler\n9. Test with real transformations\n10. Performance profiling\n\nCODE ORGANIZATION:\nSources/OptimusClipCore/Transformation/Transformation.swift\nSources/OptimusClipCore/Transformation/TransformationPipeline.swift\nSources/OptimusClipCore/Transformation/TransformationPreset.swift\nSources/OptimusClipCore/Transformation/TransformationError.swift\nTests/OptimusClipTests/TransformationPipelineTests.swift\n\nPRIORITY: P1 (Core engine for Phase 4)\n\nESTIMATED TIME: 120 minutes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:07:09.627653-05:00","updated_at":"2025-12-13T13:42:49.390623-05:00","closed_at":"2025-12-13T13:42:49.390623-05:00","dependencies":[{"issue_id":"oc-j0g.5","depends_on_id":"oc-j0g","type":"parent-child","created_at":"2025-12-12T22:07:09.628161-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.5","depends_on_id":"oc-j0g.1","type":"blocks","created_at":"2025-12-12T22:07:09.628815-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.5","depends_on_id":"oc-j0g.2","type":"blocks","created_at":"2025-12-12T23:54:07.272409-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.5","depends_on_id":"oc-j0g.3","type":"blocks","created_at":"2025-12-12T23:54:08.202592-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.5","depends_on_id":"oc-j0g.4","type":"blocks","created_at":"2025-12-12T23:54:08.768416-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-j0g.6","title":"Transformation Registry","description":"BACKGROUND \u0026 CONTEXT:\nThe Transformation Registry is a centralized catalog of all available transformations in the application. It serves as the single source of truth for:\n1. Built-in algorithmic transformations (strip whitespace, unwrap lines)\n2. User-defined LLM transformations (Phase 5)\n3. Transformation metadata (name, description, enabled state)\n4. ID-based lookup for hotkey mapping\n\nThe registry solves several architectural problems:\n- **Discovery:** UI needs to list available transformations\n- **Lookup:** Hotkey handler needs to find transformation by ID\n- **Lifecycle:** Dynamic registration/unregistration of transforms\n- **State Management:** Enable/disable individual transformations\n- **Thread Safety:** Concurrent access from UI and hotkey handlers\n\nDesign pattern: Singleton with lazy initialization. Built-in transformations are auto-registered on first access. User-defined transformations are registered dynamically (Phase 5).\n\nThe registry is read-heavy (frequent lookups) and write-light (rare registration), so it's optimized for fast lookup with thread-safe mutations.\n\nREAL-WORLD PROBLEM/USE CASE:\nUser opens Settings → Transformations tab to create a new transformation:\n\n1. **Listing Available Transforms:**\n   UI asks registry for all transformations:\n   ```swift\n   let transforms = TransformationRegistry.shared.allTransformations()\n   // Returns: [\"Quick Fix\", \"Strip Whitespace\", \"Unwrap Lines\"]\n   ```\n\n2. **User Creates Hotkey Mapping:**\n   User assigns Cmd+Option+V to \"Quick Fix\" transformation\n   Mapping stored: `\"cmd-opt-v\"` → `\"builtin.quickfix\"`\n\n3. **User Presses Hotkey:**\n   ```swift\n   // Hotkey handler receives: \"builtin.quickfix\"\n   let transform = TransformationRegistry.shared.transformation(for: \"builtin.quickfix\")\n   \n   // Returns: QuickFixTransformation (which is a pipeline of strip + unwrap)\n   ```\n\n4. **User Disables Transform:**\n   User toggles \"Quick Fix\" off in UI:\n   ```swift\n   TransformationRegistry.shared.setEnabled(false, for: \"builtin.quickfix\")\n   ```\n   \n   Now hotkey press returns nil (transformation disabled):\n   ```swift\n   let transform = TransformationRegistry.shared.transformation(for: \"builtin.quickfix\")\n   // Returns: nil (disabled)\n   ```\n\nWithout the registry:\n- Hotkey handler would need to know about all transformation implementations\n- No central place to manage enabled/disabled state\n- UI would need to hardcode transformation lists\n- Tight coupling between hotkeys and transformations\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. REGISTRY INTERFACE:\n```swift\n/// Central registry for all transformations\n@MainActor\nfinal class TransformationRegistry {\n    /// Shared singleton instance\n    static let shared = TransformationRegistry()\n    \n    /// Storage for registered transformations\n    private var transformations: [String: RegistryEntry] = [:]\n    \n    /// Thread-safe lock (not needed with @MainActor, but good practice)\n    private let lock = NSLock()\n    \n    /// Private initializer (singleton)\n    private init() {\n        // Auto-register built-in transformations\n        self.registerBuiltInTransformations()\n    }\n    \n    /// Entry in the registry\n    struct RegistryEntry {\n        let transformation: Transformation\n        var isEnabled: Bool\n        let category: TransformationCategory\n        let createdAt: Date\n    }\n    \n    enum TransformationCategory {\n        case builtin       // Pre-installed algorithmic transforms\n        case userDefined   // Custom LLM transforms (Phase 5)\n    }\n}\n```\n\n2. REGISTRATION METHODS:\n```swift\nextension TransformationRegistry {\n    /// Register a new transformation\n    /// - Parameters:\n    ///   - transformation: The transformation to register\n    ///   - category: Built-in or user-defined\n    ///   - enabled: Initial enabled state (default: true)\n    /// - Returns: True if registered, false if ID already exists\n    @discardableResult\n    func register(\n        _ transformation: Transformation,\n        category: TransformationCategory = .userDefined,\n        enabled: Bool = true\n    ) -\u003e Bool {\n        self.lock.withLock {\n            // Check for duplicate ID\n            guard self.transformations[transformation.id] == nil else {\n                print(\"Warning: Transformation with ID '\\(transformation.id)' already registered\")\n                return false\n            }\n            \n            // Register\n            let entry = RegistryEntry(\n                transformation: transformation,\n                isEnabled: enabled,\n                category: category,\n                createdAt: Date()\n            )\n            \n            self.transformations[transformation.id] = entry\n            \n            print(\"Registered transformation: \\(transformation.name) (\\(transformation.id))\")\n            return true\n        }\n    }\n    \n    /// Unregister a transformation by ID\n    /// - Parameter id: Transformation ID\n    /// - Returns: True if unregistered, false if not found\n    @discardableResult\n    func unregister(_ id: String) -\u003e Bool {\n        self.lock.withLock {\n            guard self.transformations.removeValue(forKey: id) != nil else {\n                print(\"Warning: Transformation with ID '\\(id)' not found\")\n                return false\n            }\n            \n            print(\"Unregistered transformation: \\(id)\")\n            return true\n        }\n    }\n    \n    /// Register all built-in transformations\n    private func registerBuiltInTransformations() {\n        // Strip Whitespace (standalone)\n        self.register(\n            StripWhitespaceTransformation(),\n            category: .builtin,\n            enabled: true\n        )\n        \n        // Unwrap Lines (standalone)\n        self.register(\n            UnwrapLinesTransformation(),\n            category: .builtin,\n            enabled: true\n        )\n        \n        // Quick Fix (composite pipeline)\n        self.register(\n            QuickFixTransformation(),\n            category: .builtin,\n            enabled: true\n        )\n    }\n}\n```\n\n3. LOOKUP METHODS:\n```swift\nextension TransformationRegistry {\n    /// Get transformation by ID (only if enabled)\n    /// - Parameter id: Transformation ID\n    /// - Returns: Transformation if found and enabled, nil otherwise\n    func transformation(for id: String) -\u003e Transformation? {\n        self.lock.withLock {\n            guard let entry = self.transformations[id], entry.isEnabled else {\n                return nil\n            }\n            return entry.transformation\n        }\n    }\n    \n    /// Get all transformations (regardless of enabled state)\n    /// - Returns: Array of all registered transformations\n    func allTransformations() -\u003e [Transformation] {\n        self.lock.withLock {\n            return self.transformations.values.map(\\.transformation)\n        }\n    }\n    \n    /// Get transformations by category\n    /// - Parameter category: Built-in or user-defined\n    /// - Returns: Array of transformations in that category\n    func transformations(in category: TransformationCategory) -\u003e [Transformation] {\n        self.lock.withLock {\n            return self.transformations.values\n                .filter { $0.category == category }\n                .map(\\.transformation)\n        }\n    }\n    \n    /// Get enabled transformations only\n    /// - Returns: Array of enabled transformations\n    func enabledTransformations() -\u003e [Transformation] {\n        self.lock.withLock {\n            return self.transformations.values\n                .filter(\\.isEnabled)\n                .map(\\.transformation)\n        }\n    }\n    \n    /// Check if transformation exists\n    /// - Parameter id: Transformation ID\n    /// - Returns: True if registered, false otherwise\n    func exists(_ id: String) -\u003e Bool {\n        self.lock.withLock {\n            return self.transformations[id] != nil\n        }\n    }\n}\n```\n\n4. STATE MANAGEMENT:\n```swift\nextension TransformationRegistry {\n    /// Enable or disable a transformation\n    /// - Parameters:\n    ///   - enabled: New enabled state\n    ///   - id: Transformation ID\n    /// - Returns: True if updated, false if not found\n    @discardableResult\n    func setEnabled(_ enabled: Bool, for id: String) -\u003e Bool {\n        self.lock.withLock {\n            guard var entry = self.transformations[id] else {\n                print(\"Warning: Transformation with ID '\\(id)' not found\")\n                return false\n            }\n            \n            entry.isEnabled = enabled\n            self.transformations[id] = entry\n            \n            print(\"Transformation '\\(id)' \\(enabled ? \"enabled\" : \"disabled\")\")\n            return true\n        }\n    }\n    \n    /// Check if transformation is enabled\n    /// - Parameter id: Transformation ID\n    /// - Returns: True if enabled, false if disabled or not found\n    func isEnabled(_ id: String) -\u003e Bool {\n        self.lock.withLock {\n            return self.transformations[id]?.isEnabled ?? false\n        }\n    }\n    \n    /// Enable all transformations\n    func enableAll() {\n        self.lock.withLock {\n            for (id, var entry) in self.transformations {\n                entry.isEnabled = true\n                self.transformations[id] = entry\n            }\n            print(\"All transformations enabled\")\n        }\n    }\n    \n    /// Disable all transformations\n    func disableAll() {\n        self.lock.withLock {\n            for (id, var entry) in self.transformations {\n                entry.isEnabled = false\n                self.transformations[id] = entry\n            }\n            print(\"All transformations disabled\")\n        }\n    }\n}\n```\n\n5. CONVENIENCE METHODS:\n```swift\nextension TransformationRegistry {\n    /// Get transformation names for UI display\n    /// - Returns: Dictionary mapping IDs to names\n    func transformationNames() -\u003e [String: String] {\n        self.lock.withLock {\n            return Dictionary(\n                uniqueKeysWithValues: self.transformations.map { id, entry in\n                    (id, entry.transformation.name)\n                }\n            )\n        }\n    }\n    \n    /// Get count of registered transformations\n    var count: Int {\n        self.lock.withLock {\n            return self.transformations.count\n        }\n    }\n    \n    /// Get count of enabled transformations\n    var enabledCount: Int {\n        self.lock.withLock {\n            return self.transformations.values.filter(\\.isEnabled).count\n        }\n    }\n    \n    /// Debug description\n    func printRegistry() {\n        self.lock.withLock {\n            print(\"=== Transformation Registry ===\")\n            print(\"Total: \\(self.transformations.count)\")\n            for (id, entry) in self.transformations.sorted(by: { $0.key \u003c $1.key }) {\n                let status = entry.isEnabled ? \"✓\" : \"✗\"\n                print(\"  \\(status) \\(entry.transformation.name) (\\(id)) - \\(entry.category)\")\n            }\n        }\n    }\n}\n```\n\n6. UI INTEGRATION:\n```swift\n// In TransformationsTabView.swift\nstruct TransformationsTabView: View {\n    @State private var transformations: [Transformation] = []\n    @State private var selectedID: String?\n    \n    var body: some View {\n        List(transformations, id: \\.id, selection: $selectedID) { transform in\n            HStack {\n                Text(transform.name)\n                Spacer()\n                Toggle(\"\", isOn: enabledBinding(for: transform.id))\n                    .labelsHidden()\n            }\n        }\n        .onAppear {\n            self.transformations = TransformationRegistry.shared.allTransformations()\n        }\n    }\n    \n    private func enabledBinding(for id: String) -\u003e Binding\u003cBool\u003e {\n        Binding(\n            get: { TransformationRegistry.shared.isEnabled(id) },\n            set: { TransformationRegistry.shared.setEnabled($0, for: id) }\n        )\n    }\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- **Phase 3 (HotkeyManager):** Looks up transformations by ID when hotkey pressed\n- **Phase 4 (TransformationPipeline):** Receives transformations from registry\n- **Phase 4 (Built-in Transforms):** Auto-registered on app launch\n- **Phase 5 (LLM Transforms):** Dynamically registered when user creates them\n- **Settings UI:** Lists all transformations, manages enabled state\n- **Phase 6 (Persistence):** Registry state could be saved/restored (future)\n\nRegistry sits between UI and execution:\n```\nSettings UI → Registry (list/enable/disable)\nHotkey Press → Registry (lookup by ID) → Pipeline Execution\n```\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. DUPLICATE IDs:\n   - Registration fails if ID already exists\n   - Use namespacing: \"builtin.quickfix\", \"user.custom1\"\n   - Log warning but don't crash\n\n2. MISSING TRANSFORMATION:\n   - Lookup returns nil if not found\n   - Hotkey handler should handle nil gracefully\n   - Don't show error to user (silent failure)\n\n3. DISABLED TRANSFORMATION:\n   - Lookup returns nil if disabled\n   - Same handling as missing transformation\n   - User might forget they disabled it\n\n4. CONCURRENT ACCESS:\n   - Registry is @MainActor but use NSLock for extra safety\n   - Lock around all dictionary mutations\n   - No lock needed for reads (Swift's copy-on-write)\n\n5. INITIALIZATION ORDER:\n   - Registry auto-registers built-ins in init()\n   - Must happen before first hotkey registration\n   - Singleton pattern ensures correct order\n\n6. MEMORY LEAKS:\n   - Transformations are stored by value (structs) or held strongly (classes)\n   - User-defined transforms might capture closures\n   - Consider weak references for LLM clients (Phase 5)\n\n7. UNREGISTERING BUILT-INS:\n   - Should users be able to unregister built-in transforms?\n   - Current design: yes, but they can't re-register without restart\n   - Consider preventing unregistration of built-ins\n\n8. EMPTY REGISTRY:\n   - Registry should never be empty (built-ins always present)\n   - But unregister() could remove all transforms\n   - UI should handle empty state gracefully\n\nTESTING REQUIREMENTS:\n\n1. UNIT TESTS:\n```swift\n@Test(\"Registry auto-registers built-in transformations\")\nfunc testAutoRegistration() {\n    let registry = TransformationRegistry()\n    \n    // Check built-ins are registered\n    #expect(registry.exists(\"builtin.strip_whitespace\"))\n    #expect(registry.exists(\"builtin.unwrap_lines\"))\n    #expect(registry.exists(\"builtin.quickfix\"))\n}\n\n@Test(\"Registry lookup returns transformation if enabled\")\nfunc testLookupEnabled() {\n    let registry = TransformationRegistry()\n    let transform = MockTransform(id: \"test\", name: \"Test\")\n    \n    registry.register(transform, enabled: true)\n    \n    let result = registry.transformation(for: \"test\")\n    #expect(result != nil)\n    #expect(result?.id == \"test\")\n}\n\n@Test(\"Registry lookup returns nil if disabled\")\nfunc testLookupDisabled() {\n    let registry = TransformationRegistry()\n    let transform = MockTransform(id: \"test\", name: \"Test\")\n    \n    registry.register(transform, enabled: false)\n    \n    let result = registry.transformation(for: \"test\")\n    #expect(result == nil)\n}\n\n@Test(\"Registry prevents duplicate IDs\")\nfunc testDuplicateID() {\n    let registry = TransformationRegistry()\n    let transform1 = MockTransform(id: \"test\", name: \"Test 1\")\n    let transform2 = MockTransform(id: \"test\", name: \"Test 2\")\n    \n    let result1 = registry.register(transform1)\n    let result2 = registry.register(transform2)\n    \n    #expect(result1 == true)\n    #expect(result2 == false)\n    \n    // First registration wins\n    let stored = registry.transformation(for: \"test\")\n    #expect(stored?.name == \"Test 1\")\n}\n\n@Test(\"Registry unregister removes transformation\")\nfunc testUnregister() {\n    let registry = TransformationRegistry()\n    let transform = MockTransform(id: \"test\", name: \"Test\")\n    \n    registry.register(transform)\n    #expect(registry.exists(\"test\"))\n    \n    registry.unregister(\"test\")\n    #expect(!registry.exists(\"test\"))\n}\n\n@Test(\"Registry setEnabled updates state\")\nfunc testSetEnabled() {\n    let registry = TransformationRegistry()\n    let transform = MockTransform(id: \"test\", name: \"Test\")\n    \n    registry.register(transform, enabled: true)\n    #expect(registry.isEnabled(\"test\"))\n    \n    registry.setEnabled(false, for: \"test\")\n    #expect(!registry.isEnabled(\"test\"))\n    \n    registry.setEnabled(true, for: \"test\")\n    #expect(registry.isEnabled(\"test\"))\n}\n```\n\n2. INTEGRATION TESTS:\n   - Register built-in transformations\n   - Verify they can be looked up\n   - Verify disable/enable works\n   - Verify hotkey handler integration\n\n3. THREAD SAFETY TESTS:\n   - Concurrent reads should succeed\n   - Concurrent writes should be serialized\n   - No race conditions or crashes\n\nSUCCESS CRITERIA:\n- Singleton pattern implemented correctly\n- Built-in transformations auto-registered on init\n- Thread-safe concurrent access (NSLock)\n- Lookup by ID returns transformation if enabled\n- Lookup returns nil if disabled or not found\n- Register/unregister works correctly\n- Enable/disable state management works\n- No duplicate IDs allowed\n- Unit tests pass with \u003e90% coverage\n\nCONFIGURATION OPTIONS:\n- Max transformations (default: unlimited)\n- Allow unregistering built-ins (default: yes)\n- Log registration events (default: yes in debug)\n\nPERFORMANCE CONSIDERATIONS:\n- Lookup is O(1) dictionary access (very fast)\n- Registration is rare, lookup is frequent (optimized for reads)\n- NSLock adds minimal overhead (\u003c1µs)\n- @MainActor ensures UI safety\n- Small memory footprint (dozens of transforms, not thousands)\n\nSECURITY CONSIDERATIONS:\n- User-defined transformations (Phase 5) might contain sensitive prompts\n- Consider encrypting user-defined transform definitions\n- API keys stored in transforms should use Keychain (not registry)\n\nIMPLEMENTATION ORDER:\n1. Define RegistryEntry struct\n2. Implement TransformationRegistry singleton\n3. Add registration methods\n4. Add lookup methods\n5. Add state management (enable/disable)\n6. Auto-register built-in transformations\n7. Add convenience methods\n8. Write unit tests\n9. Integrate with HotkeyHandler\n10. Integrate with Settings UI\n\nCODE ORGANIZATION:\nSources/OptimusClipCore/Transformation/TransformationRegistry.swift\nSources/OptimusClipCore/Transformation/BuiltInTransformations.swift\nTests/OptimusClipTests/TransformationRegistryTests.swift\n\nPRIORITY: P1 (Required for hotkey → transformation mapping)\n\nESTIMATED TIME: 90 minutes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:07:16.829644-05:00","updated_at":"2025-12-13T13:42:38.032706-05:00","closed_at":"2025-12-13T13:42:38.032706-05:00","dependencies":[{"issue_id":"oc-j0g.6","depends_on_id":"oc-j0g","type":"parent-child","created_at":"2025-12-12T22:07:16.830196-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.6","depends_on_id":"oc-j0g.1","type":"blocks","created_at":"2025-12-12T22:07:16.830859-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.6","depends_on_id":"oc-j0g.2","type":"blocks","created_at":"2025-12-12T23:54:10.155833-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.6","depends_on_id":"oc-j0g.3","type":"blocks","created_at":"2025-12-12T23:54:10.747851-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-j0g.7","title":"Wire Hotkeys to Transformations","description":"BACKGROUND \u0026 CONTEXT:\nThis task integrates all previous phases into a cohesive end-to-end workflow. When a user presses a registered hotkey, the application must:\n1. Detect the hotkey press (Phase 3 - HotkeyManager)\n2. Read current clipboard content (Phase 2 - ClipboardMonitor)\n3. Look up the transformation mapped to that hotkey (Phase 4 - Registry)\n4. Execute the transformation pipeline (Phase 4 - Pipeline)\n5. Write the result back to clipboard (Phase 2 - ClipboardMonitor)\n6. Simulate a paste action (Phase 2 - Paste Simulation)\n7. Update menu bar state to show processing/success/error (Phase 1 - MenuBar)\n\nThis is the \"glue code\" that makes Optimus Clip functional. It's the most critical integration point in the application, connecting all architectural components into a single user-facing feature.\n\nThe wiring must handle errors gracefully:\n- Invalid clipboard data → Silent failure, no paste\n- Missing transformation → Silent failure, no paste\n- Transformation error → Rollback to original, show error state\n- Network timeout (future LLM) → Rollback, show error state\n\nMenu bar state management is crucial for user feedback:\n- Idle: Normal icon (clipboard.fill)\n- Processing: Pulse animation (.symbolEffect(.pulse))\n- Success: Brief green flash (200ms)\n- Error: Brief red flash (500ms)\n\nREAL-WORLD PROBLEM/USE CASE:\nUser copies CLI output from Claude Code and wants to paste it cleaned:\n\n**Before (Manual Process):**\n1. Copy text (Cmd+C)\n2. Open text editor\n3. Paste (Cmd+V)\n4. Manually remove leading spaces\n5. Manually join wrapped lines\n6. Select all, copy again\n7. Switch to target app\n8. Paste\n\n**After (Optimus Clip):**\n1. Copy text (Cmd+C)\n2. Press Cmd+Option+V (Quick Fix hotkey)\n3. *Text appears cleaned in target app*\n\n**What Happens Behind the Scenes:**\n```\n1. User presses Cmd+Option+V\n   ↓\n2. HotkeyManager detects keypress → calls handler\n   ↓\n3. HotkeyHandler:\n   - Shows processing state (pulse animation)\n   - Reads clipboard: \"  Line 1\\n  Line 2\"\n   - Looks up transformation: \"builtin.quickfix\"\n   - Creates pipeline: [StripWhitespace, UnwrapLines]\n   - Executes pipeline: \"Line 1 Line 2\"\n   - Writes to clipboard (with self-marker)\n   - Simulates Cmd+V paste\n   - Shows success state (green flash)\n   ↓\n4. Text appears in focused app (Slack, email, IDE)\n```\n\n**Error Case (Clipboard Empty):**\n```\nUser presses Cmd+Option+V with empty clipboard\n↓\nHotkeyHandler reads clipboard → nil\n↓\nSilent failure (no error shown)\n↓\nNo paste occurs\n```\n\n**Error Case (Transformation Fails):**\n```\nUser presses hotkey\n↓\nPipeline throws error during execution\n↓\nHotkeyHandler catches error\n↓\nClipboard NOT overwritten (original preserved)\n↓\nError state shown in menu bar (red flash 500ms)\n↓\nNo paste occurs\n```\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. HOTKEY HANDLER (MAIN ORCHESTRATOR):\n```swift\n/// Orchestrates the hotkey → transformation → paste workflow\n@MainActor\nfinal class HotkeyHandler: ObservableObject {\n    // Dependencies\n    private let clipboardMonitor: ClipboardMonitor\n    private let registry: TransformationRegistry\n    private let pasteSimulator: PasteSimulator\n    \n    // State for menu bar icon\n    @Published var menuBarState: MenuBarState = .idle\n    \n    // Hotkey-to-preset mapping (from user settings)\n    private var hotkeyMappings: [KeyboardShortcuts.Name: String] = [:]\n    \n    init(\n        clipboardMonitor: ClipboardMonitor,\n        registry: TransformationRegistry = .shared,\n        pasteSimulator: PasteSimulator\n    ) {\n        self.clipboardMonitor = clipboardMonitor\n        self.registry = registry\n        self.pasteSimulator = pasteSimulator\n    }\n    \n    /// Register a hotkey with its associated preset ID\n    func registerHotkey(_ name: KeyboardShortcuts.Name, presetID: String) {\n        self.hotkeyMappings[name] = presetID\n        \n        // Register handler with KeyboardShortcuts package\n        KeyboardShortcuts.onKeyUp(for: name) { [weak self] in\n            Task { @MainActor in\n                await self?.handleHotkey(name: name)\n            }\n        }\n    }\n    \n    /// Unregister a hotkey\n    func unregisterHotkey(_ name: KeyboardShortcuts.Name) {\n        self.hotkeyMappings.removeValue(forKey: name)\n        KeyboardShortcuts.disable(name)\n    }\n}\n```\n\n2. HOTKEY HANDLING WORKFLOW:\n```swift\nextension HotkeyHandler {\n    /// Handle hotkey press and execute transformation\n    private func handleHotkey(name: KeyboardShortcuts.Name) async {\n        // Step 1: Get preset ID for this hotkey\n        guard let presetID = self.hotkeyMappings[name] else {\n            print(\"No preset mapped to hotkey: \\(name)\")\n            return\n        }\n        \n        // Step 2: Show processing state\n        self.updateMenuBarState(.processing)\n        \n        do {\n            // Step 3: Execute transformation\n            let result = try await self.executeTransformation(presetID: presetID)\n            \n            // Step 4: Write to clipboard and paste\n            self.clipboardMonitor.writeClipboard(result)\n            try await self.pasteSimulator.simulatePaste()\n            \n            // Step 5: Show success state briefly\n            await self.showSuccessState()\n            \n        } catch {\n            // Step 6: Handle error (clipboard NOT overwritten)\n            print(\"Transformation failed: \\(error)\")\n            await self.showErrorState()\n        }\n    }\n    \n    /// Execute transformation for given preset ID\n    private func executeTransformation(presetID: String) async throws -\u003e String {\n        // Read clipboard\n        guard let originalText = self.clipboardMonitor.readClipboard() else {\n            throw TransformationError.emptyInput\n        }\n        \n        // Load preset configuration\n        guard let preset = self.loadPreset(id: presetID) else {\n            throw TransformationError.presetNotFound(presetID)\n        }\n        \n        // Build transformation list from registry\n        let transforms = preset.transformationIDs.compactMap { id in\n            self.registry.transformation(for: id)\n        }\n        \n        guard !transforms.isEmpty else {\n            throw TransformationError.noValidTransformations\n        }\n        \n        // Create and execute pipeline\n        let pipeline = TransformationPipeline(\n            transformations: transforms,\n            timeout: preset.timeout\n        )\n        \n        return try await pipeline.execute(originalText)\n    }\n    \n    /// Load preset configuration (from AppStorage or future persistence)\n    private func loadPreset(id: String) -\u003e TransformationPreset? {\n        // Phase 4: Use built-in preset\n        if id == \"builtin.quickfix\" {\n            return .quickFix\n        }\n        \n        // Phase 5: Load user-defined presets from storage\n        // return userPresets[id]\n        \n        return nil\n    }\n}\n```\n\n3. MENU BAR STATE MANAGEMENT:\n```swift\n/// Menu bar visual states\nenum MenuBarState: Equatable {\n    case idle\n    case processing\n    case success\n    case error\n}\n\nextension HotkeyHandler {\n    /// Update menu bar icon state\n    private func updateMenuBarState(_ state: MenuBarState) {\n        self.menuBarState = state\n    }\n    \n    /// Show success state briefly, then return to idle\n    private func showSuccessState() async {\n        self.updateMenuBarState(.success)\n        \n        try? await Task.sleep(nanoseconds: 200_000_000) // 200ms\n        \n        self.updateMenuBarState(.idle)\n    }\n    \n    /// Show error state briefly, then return to idle\n    private func showErrorState() async {\n        self.updateMenuBarState(.error)\n        \n        try? await Task.sleep(nanoseconds: 500_000_000) // 500ms\n        \n        self.updateMenuBarState(.idle)\n    }\n}\n```\n\n4. MENU BAR INTEGRATION:\n```swift\n// In OptimusClipApp.swift\n@main\nstruct OptimusClipApp: App {\n    @StateObject private var hotkeyHandler = HotkeyHandler(\n        clipboardMonitor: ClipboardMonitor.shared,\n        pasteSimulator: PasteSimulator.shared\n    )\n    \n    var body: some Scene {\n        MenuBarExtra {\n            MenuBarContent()\n        } label: {\n            MenuBarLabel(state: hotkeyHandler.menuBarState)\n        }\n    }\n}\n\nstruct MenuBarLabel: View {\n    let state: MenuBarState\n    @State private var pulseID = 0\n    \n    var body: some View {\n        Image(systemName: \"clipboard.fill\")\n            .symbolEffect(.pulse, options: .repeat(.periodic), value: self.pulseID)\n            .foregroundStyle(self.color)\n            .onChange(of: state) { _, newState in\n                if newState == .processing {\n                    self.pulseID += 1  // Trigger pulse animation\n                }\n            }\n    }\n    \n    private var color: Color {\n        switch self.state {\n        case .idle, .processing:\n            return .primary\n        case .success:\n            return .green\n        case .error:\n            return .red\n        }\n    }\n}\n```\n\n5. ACCESSIBILITY PERMISSION GUARD:\n```swift\nextension HotkeyHandler {\n    /// Check if accessibility permission is granted before pasting\n    private func ensureAccessibilityPermission() throws {\n        guard AXIsProcessTrusted() else {\n            throw TransformationError.accessibilityPermissionDenied\n        }\n    }\n}\n\n// Update handleHotkey to check permission:\nprivate func handleHotkey(name: KeyboardShortcuts.Name) async {\n    // ... existing code ...\n    \n    do {\n        // Check permission before attempting paste\n        try self.ensureAccessibilityPermission()\n        \n        let result = try await self.executeTransformation(presetID: presetID)\n        \n        self.clipboardMonitor.writeClipboard(result)\n        try await self.pasteSimulator.simulatePaste()\n        \n        await self.showSuccessState()\n        \n    } catch TransformationError.accessibilityPermissionDenied {\n        // Special handling: show permission alert\n        await self.showPermissionAlert()\n        \n    } catch {\n        print(\"Transformation failed: \\(error)\")\n        await self.showErrorState()\n    }\n}\n```\n\n6. SETTINGS INTEGRATION (HOTKEY REGISTRATION):\n```swift\n// In TransformationsTabView.swift\nstruct TransformationsTabView: View {\n    @EnvironmentObject var hotkeyHandler: HotkeyHandler\n    @State private var presets: [TransformationPreset] = []\n    \n    var body: some View {\n        List(presets) { preset in\n            VStack(alignment: .leading) {\n                Text(preset.name)\n                \n                // Hotkey recorder\n                KeyboardShortcuts.Recorder(\n                    for: .init(preset.id),\n                    onChange: { _ in\n                        // Re-register hotkey with handler\n                        hotkeyHandler.registerHotkey(.init(preset.id), presetID: preset.id)\n                    }\n                )\n                \n                // Enable/disable toggle\n                Toggle(\"Enabled\", isOn: Binding(\n                    get: { preset.isEnabled },\n                    set: { enabled in\n                        if enabled {\n                            hotkeyHandler.registerHotkey(.init(preset.id), presetID: preset.id)\n                        } else {\n                            hotkeyHandler.unregisterHotkey(.init(preset.id))\n                        }\n                    }\n                ))\n            }\n        }\n        .onAppear {\n            // Register default hotkeys\n            self.registerDefaultHotkeys()\n        }\n    }\n    \n    private func registerDefaultHotkeys() {\n        // Quick Fix: Cmd+Option+V\n        hotkeyHandler.registerHotkey(.quickFix, presetID: \"builtin.quickfix\")\n    }\n}\n\n// Define hotkey names\nextension KeyboardShortcuts.Name {\n    static let quickFix = Self(\"quickFix\", default: .init(.v, modifiers: [.command, .option]))\n}\n```\n\n7. ERROR HANDLING:\n```swift\nextension TransformationError {\n    case presetNotFound(String)\n    case noValidTransformations\n    case accessibilityPermissionDenied\n}\n\nextension HotkeyHandler {\n    /// Show permission alert in UI\n    private func showPermissionAlert() async {\n        // Option 1: Show macOS alert\n        let alert = NSAlert()\n        alert.messageText = \"Accessibility Permission Required\"\n        alert.informativeText = \"Optimus Clip needs Accessibility permission to paste transformed text.\"\n        alert.addButton(withTitle: \"Open Settings\")\n        alert.addButton(withTitle: \"Cancel\")\n        \n        let response = alert.runModal()\n        if response == .alertFirstButtonReturn {\n            // Open System Settings\n            let url = URL(string: \"x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility\")!\n            NSWorkspace.shared.open(url)\n        }\n    }\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- **Phase 1 (MenuBar):** Updates icon state (idle/processing/success/error)\n- **Phase 2 (ClipboardMonitor):** Reads original text, writes transformed text\n- **Phase 2 (PasteSimulator):** Simulates Cmd+V after transformation\n- **Phase 3 (HotkeyManager/KeyboardShortcuts):** Detects hotkey press\n- **Phase 4 (TransformationRegistry):** Looks up transformations by ID\n- **Phase 4 (TransformationPipeline):** Executes transformation sequence\n- **Settings UI:** Manages hotkey-to-preset mappings\n\nThis is the central orchestration layer:\n```\nUser Input (Hotkey) \n  → HotkeyHandler (orchestrator)\n  → ClipboardMonitor (read)\n  → Registry (lookup)\n  → Pipeline (execute)\n  → ClipboardMonitor (write)\n  → PasteSimulator (paste)\n  → MenuBar (visual feedback)\n```\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. EMPTY CLIPBOARD:\n   - readClipboard() returns nil\n   - Throw TransformationError.emptyInput\n   - Silent failure (no error shown to user)\n   - Common when user forgets to copy first\n\n2. BINARY CLIPBOARD DATA:\n   - Phase 2 should detect and reject binary data\n   - HotkeyHandler receives nil from readClipboard()\n   - Silent failure (no paste occurs)\n   - Future: Could show warning \"Cannot transform images\"\n\n3. VERY LONG TEXT (\u003e1MB):\n   - Pipeline might be slow (\u003e100ms)\n   - User sees processing state longer than expected\n   - Consider timeout (5 seconds default)\n   - Consider max size limit (e.g., 10MB)\n\n4. RAPID HOTKEY PRESSES:\n   - User presses hotkey twice quickly\n   - Second press should cancel/queue after first\n   - Use Task cancellation or state flag\n   - Prevent concurrent pipeline execution\n\n5. TRANSFORMATION DISABLED:\n   - Registry returns nil for disabled transforms\n   - Throw noValidTransformations error\n   - Silent failure (no paste)\n   - User might forget they disabled it\n\n6. ACCESSIBILITY PERMISSION DENIED:\n   - simulatePaste() will fail silently\n   - Must check AXIsProcessTrusted() before pasting\n   - Show alert directing user to System Settings\n   - Clipboard still updated (user can manually paste)\n\n7. CLIPBOARD OVERWRITTEN DURING PROCESSING:\n   - User copies something else mid-transformation\n   - Original text lost (no rollback possible)\n   - Rare edge case, acceptable behavior\n   - Could store original in memory as backup\n\n8. PASTE SIMULATION FAILS:\n   - CGEvent might fail in some apps (security restrictions)\n   - Clipboard still updated (manual paste works)\n   - Log error but don't show to user\n   - Known limitation of approach\n\n9. NETWORK TIMEOUT (Phase 5):\n   - LLM calls might timeout (30s default)\n   - User sees processing state entire time\n   - Must show clear error on timeout\n   - Original clipboard preserved (no partial results)\n\n10. HOTKEY CONFLICT:\n    - User assigns same hotkey to multiple presets\n    - KeyboardShortcuts package handles this (last one wins)\n    - UI should warn about conflicts\n    - Settings validation needed\n\nTESTING REQUIREMENTS:\n\n1. UNIT TESTS:\n```swift\n@Test(\"HotkeyHandler executes transformation and updates clipboard\")\nfunc testSuccessfulTransformation() async throws {\n    let mockClipboard = MockClipboardMonitor(text: \"  Test\")\n    let mockSimulator = MockPasteSimulator()\n    let handler = HotkeyHandler(\n        clipboardMonitor: mockClipboard,\n        pasteSimulator: mockSimulator\n    )\n    \n    // Register mock transformation\n    let transform = MockTransform(id: \"test\", output: \"Transformed\")\n    TransformationRegistry.shared.register(transform)\n    \n    // Register hotkey\n    handler.registerHotkey(.test, presetID: \"builtin.test\")\n    \n    // Trigger hotkey\n    await handler.handleHotkey(name: .test)\n    \n    // Verify clipboard updated\n    #expect(mockClipboard.lastWrite == \"Transformed\")\n    \n    // Verify paste simulated\n    #expect(mockSimulator.pasteCount == 1)\n    \n    // Verify state returned to idle\n    #expect(handler.menuBarState == .idle)\n}\n\n@Test(\"HotkeyHandler handles empty clipboard gracefully\")\nfunc testEmptyClipboard() async {\n    let mockClipboard = MockClipboardMonitor(text: nil)\n    let mockSimulator = MockPasteSimulator()\n    let handler = HotkeyHandler(\n        clipboardMonitor: mockClipboard,\n        pasteSimulator: mockSimulator\n    )\n    \n    handler.registerHotkey(.test, presetID: \"builtin.test\")\n    \n    await handler.handleHotkey(name: .test)\n    \n    // Verify no paste occurred\n    #expect(mockSimulator.pasteCount == 0)\n    \n    // Verify state returned to idle (silent failure)\n    #expect(handler.menuBarState == .idle)\n}\n\n@Test(\"HotkeyHandler shows error state on transformation failure\")\nfunc testTransformationError() async {\n    let mockClipboard = MockClipboardMonitor(text: \"Test\")\n    let mockSimulator = MockPasteSimulator()\n    let handler = HotkeyHandler(\n        clipboardMonitor: mockClipboard,\n        pasteSimulator: mockSimulator\n    )\n    \n    // Register failing transformation\n    let transform = MockTransform(id: \"test\", shouldThrow: true)\n    TransformationRegistry.shared.register(transform)\n    \n    handler.registerHotkey(.test, presetID: \"builtin.test\")\n    \n    await handler.handleHotkey(name: .test)\n    \n    // Verify clipboard NOT updated (rollback)\n    #expect(mockClipboard.lastWrite == nil)\n    \n    // Verify no paste occurred\n    #expect(mockSimulator.pasteCount == 0)\n    \n    // Verify error state was shown (now back to idle after delay)\n    #expect(handler.menuBarState == .idle)\n}\n```\n\n2. INTEGRATION TESTS:\n   - Register real hotkey (Cmd+Option+V)\n   - Copy test text to clipboard\n   - Programmatically trigger hotkey\n   - Verify clipboard updated with transformed text\n   - Verify paste simulation occurred\n   - Measure end-to-end latency (\u003c200ms target)\n\n3. UI TESTS:\n   - Verify menu bar icon changes color/state\n   - Verify pulse animation during processing\n   - Verify green flash on success\n   - Verify red flash on error\n\n4. MANUAL TESTS:\n   - Copy CLI output with indents and wrapping\n   - Press Cmd+Option+V\n   - Verify pasted text is cleaned\n   - Test in multiple apps (Slack, email, IDE)\n\nSUCCESS CRITERIA:\n- Hotkey press triggers transformation\n- Clipboard read/write works correctly\n- Transformation pipeline executes\n- Paste simulation works (with accessibility permission)\n- Menu bar state updates correctly (idle → processing → success/error → idle)\n- Errors handled gracefully (no crashes)\n- Original clipboard preserved on error (rollback)\n- End-to-end latency \u003c200ms for algorithmic transforms\n- Unit tests pass with \u003e85% coverage\n- Manual testing in 3+ applications succeeds\n\nCONFIGURATION OPTIONS:\n- Success/error flash duration (configurable)\n- Auto-paste vs manual paste (default: auto)\n- Show notifications on error (default: no, just menu bar state)\n- Max clipboard size for transformation (default: 10MB)\n\nPERFORMANCE CONSIDERATIONS:\n- Hotkey detection is instant (\u003c5ms)\n- Clipboard read is fast (\u003c10ms)\n- Registry lookup is O(1) (\u003c1ms)\n- Algorithmic transforms \u003c100ms total\n- Clipboard write is fast (\u003c10ms)\n- Paste simulation is fast (\u003c20ms)\n- **Total end-to-end: \u003c200ms target**\n- Phase 5 LLM transforms will be 1-5 seconds\n- Must not block main thread (use async/await)\n\nSECURITY CONSIDERATIONS:\n- Check accessibility permission before pasting\n- Don't log clipboard contents (might be sensitive)\n- Validate preset IDs (prevent injection)\n- Sanitize transformation inputs (prevent exploits)\n\nIMPLEMENTATION ORDER:\n1. Define HotkeyHandler class with dependencies\n2. Implement handleHotkey workflow\n3. Add menu bar state management\n4. Integrate with MenuBarLabel view\n5. Add accessibility permission checks\n6. Implement error handling\n7. Add hotkey registration/unregistration\n8. Integrate with Settings UI\n9. Write unit tests (mock dependencies)\n10. Manual testing with real hotkeys\n\nCODE ORGANIZATION:\nSources/OptimusClip/Core/HotkeyHandler.swift\nSources/OptimusClip/Core/MenuBarState.swift\nSources/OptimusClip/Views/MenuBar/MenuBarLabel.swift\nTests/OptimusClipTests/HotkeyHandlerTests.swift\n\nPRIORITY: P1 (Critical integration - makes app functional)\n\nESTIMATED TIME: 120 minutes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:07:25.565269-05:00","updated_at":"2025-12-13T13:46:58.99882-05:00","closed_at":"2025-12-13T13:46:58.99882-05:00","dependencies":[{"issue_id":"oc-j0g.7","depends_on_id":"oc-j0g","type":"parent-child","created_at":"2025-12-12T22:07:25.565785-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.7","depends_on_id":"oc-j0g.5","type":"blocks","created_at":"2025-12-12T22:07:25.566438-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.7","depends_on_id":"oc-j0g.6","type":"blocks","created_at":"2025-12-12T22:07:25.567011-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-j0g.8","title":"Phase 4 Verification","description":"BACKGROUND \u0026 CONTEXT:\nPhase 4 Verification is the comprehensive testing and validation gate that ensures the Transformation Engine is production-ready before moving to Phase 5 (LLM Integration). This is NOT just running unit tests - it's systematic end-to-end verification of the entire Phase 4 feature set.\n\nWhat makes this different from regular testing:\n1. **User Perspective:** Tests real-world workflows as a user would experience them\n2. **Integration Focus:** Validates all Phase 4 components working together\n3. **Performance Validation:** Measures actual latency and memory usage\n4. **Edge Case Hunting:** Deliberately tries to break the system\n5. **Documentation:** Creates evidence that Phase 4 is complete and stable\n\nPhase 4 is considered \"verified\" when:\n- All unit tests pass (\u003e90% coverage)\n- All integration tests pass\n- All manual test cases pass\n- Performance targets met (\u003c100ms, \u003c200MB)\n- No critical bugs found\n- Edge cases handled gracefully\n- Documentation complete\n\nThis task is the quality gate before Phase 5. If verification fails, go back and fix issues. Do NOT proceed to LLM integration with a broken foundation.\n\nWhy this matters:\n- Phase 5 builds on Phase 4 (bad foundation = unstable features)\n- Early bugs are cheaper to fix than late bugs\n- User trust depends on reliability\n- Performance problems compound in later phases\n\nREAL-WORLD PROBLEM/USE CASE:\nDeveloper completes Phase 4 implementation but hasn't tested real-world scenarios. They move to Phase 5, then discover:\n- Strip whitespace corrupts Python code (indentation is semantic!)\n- Unwrap algorithm joins code lines (breaks syntax)\n- Large inputs (10K+ lines) freeze the app\n- Menu bar state gets stuck in \"processing\"\n- Hotkeys stop working after 10 uses (memory leak)\n\n**Cost of skipping verification:**\n- 2+ hours debugging integration issues in Phase 5\n- User reports app crashes on real CLI output\n- Must rewrite transformation logic\n- Delays entire project timeline\n\n**Value of thorough verification:**\n- Catches bugs early (5 minutes to fix now vs 2 hours later)\n- Builds confidence in architecture\n- Documents what works (and what doesn't)\n- Provides regression test suite for future changes\n\nVERIFICATION WORKFLOW:\n\n**Step 1: Automated Test Suite**\n```bash\n# Run all tests\nswift test\n\n# Expected output:\n# ✓ TransformationPipelineTests (12 tests passed)\n# ✓ TransformationRegistryTests (8 tests passed)\n# ✓ HotkeyHandlerTests (10 tests passed)\n# ✓ StripWhitespaceTests (6 tests passed)\n# ✓ UnwrapLinesTests (8 tests passed)\n# Total: 44 tests, 0 failures\n\n# Check coverage\nswift test --enable-code-coverage\nxcrun llvm-cov report .build/debug/OptimusClipPackageTests.xctest/Contents/MacOS/OptimusClipPackageTests -instr-profile=.build/debug/codecov/default.profdata\n\n# Target: \u003e90% coverage for Phase 4 code\n```\n\n**Step 2: Real CLI Output (Claude Code Format)**\n```\nTest Case 1: Claude Code with 2-space indent and hard wraps\n\nInput (copy this):\n  This is a long line of text that was wrapped by the terminal because it exceeded\n  the maximum width configured in the user's terminal settings and now it has hard\n  line breaks that make it look terrible when pasted into Slack messages or email.\n\nExpected Output:\nThis is a long line of text that was wrapped by the terminal because it exceeded the maximum width configured in the user's terminal settings and now it has hard line breaks that make it look terrible when pasted into Slack messages or email.\n\nSteps:\n1. Copy input to clipboard (Cmd+C)\n2. Press Cmd+Option+V (Quick Fix hotkey)\n3. Paste into text editor (Cmd+V)\n4. Verify output matches expected\n\n✓ PASS / ✗ FAIL: _______\n```\n\n**Step 3: Code Preservation Test**\n```\nTest Case 2: Python code with semantic indentation\n\nInput (copy this):\n  def calculate_total(items):\n      total = 0\n      for item in items:\n          total += item.price\n      return total\n\nExpected Output (should NOT change indentation):\ndef calculate_total(items):\n    total = 0\n    for item in items:\n        total += item.price\n    return total\n\nSteps:\n1. Copy input to clipboard\n2. Press Cmd+Option+V\n3. Paste into text editor\n4. Verify indentation preserved (4 spaces, not joined)\n\n✓ PASS / ✗ FAIL: _______\n\nNote: If this fails, strip whitespace is too aggressive. Must detect code blocks.\n```\n\n**Step 4: Large Input Performance**\n```\nTest Case 3: 10,000 line input (stress test)\n\nInput: Generate 10K lines\n```bash\n# Generate test file\npython3 -c \"for i in range(10000): print(f'  Line {i:05d} with some text that is exactly eighty characters long for wrapping.')\" \u003e /tmp/large_input.txt\n\n# Copy to clipboard\npbcopy \u003c /tmp/large_input.txt\n```\n\nExpected:\n- Transformation completes in \u003c500ms (lenient for large input)\n- No memory leak (memory returns to baseline after paste)\n- Menu bar responsive during processing\n\nSteps:\n1. Copy 10K lines to clipboard (pbcopy)\n2. Note memory usage: Activity Monitor → OptimusClip\n3. Press Cmd+Option+V\n4. Measure time from press to paste complete\n5. Check memory after paste (should return to ~baseline)\n\nPerformance: _______ ms\nMemory Before: _______ MB\nMemory After: _______ MB\n✓ PASS / ✗ FAIL: _______\n```\n\n**Step 5: Empty Clipboard (Edge Case)**\n```\nTest Case 4: Hotkey with nothing copied\n\nSteps:\n1. Clear clipboard: pbcopy \u003c /dev/null\n2. Press Cmd+Option+V\n3. Verify no paste occurs\n4. Verify no crash\n5. Verify menu bar returns to idle state\n\n✓ PASS / ✗ FAIL: _______\n```\n\n**Step 6: Menu Bar State Transitions**\n```\nTest Case 5: Visual feedback verification\n\nSteps:\n1. Copy test text: \"  Test line\"\n2. Watch menu bar icon\n3. Press Cmd+Option+V\n4. Observe state transitions:\n   - Idle (normal icon)\n   → Processing (pulse animation starts)\n   → Success (green flash ~200ms)\n   → Idle (returns to normal)\n\nExpected timing:\n- Processing state: 10-100ms (algorithmic transform)\n- Success state: ~200ms flash\n- Total: \u003c500ms from press to idle\n\n✓ PASS / ✗ FAIL: _______\n```\n\n**Step 7: Hotkey Mapping Verification**\n```\nTest Case 6: Hotkey registration and lookup\n\nSteps:\n1. Open Settings → Transformations tab\n2. Verify \"Quick Fix\" listed\n3. Verify hotkey shows: Cmd+Option+V\n4. Change hotkey to Cmd+Shift+V\n5. Press old hotkey (Cmd+Option+V) → should do nothing\n6. Press new hotkey (Cmd+Shift+V) → should transform\n7. Change back to Cmd+Option+V\n\n✓ PASS / ✗ FAIL: _______\n```\n\n**Step 8: Enable/Disable Transformation**\n```\nTest Case 7: Toggle transformation on/off\n\nSteps:\n1. Open Settings → Transformations tab\n2. Toggle \"Quick Fix\" to OFF\n3. Copy text with indents\n4. Press Cmd+Option+V\n5. Verify no transformation (paste original)\n6. Toggle \"Quick Fix\" to ON\n7. Copy text with indents\n8. Press Cmd+Option+V\n9. Verify transformation applied\n\n✓ PASS / ✗ FAIL: _______\n```\n\n**Step 9: Multiple Application Compatibility**\n```\nTest Case 8: Paste in different apps\n\nTest text: \"  Line 1\\n  Line 2\"\n\nApps to test:\n1. TextEdit: ✓ PASS / ✗ FAIL: _______\n2. Slack (desktop app): ✓ PASS / ✗ FAIL: _______\n3. VS Code: ✓ PASS / ✗ FAIL: _______\n4. Terminal: ✓ PASS / ✗ FAIL: _______\n5. Notes app: ✓ PASS / ✗ FAIL: _______\n\nNote: Paste simulation might fail in some security-restricted apps (expected).\n```\n\n**Step 10: Rapid Hotkey Presses (Concurrency)**\n```\nTest Case 9: Press hotkey 10 times rapidly\n\nSteps:\n1. Copy short text: \"Test\"\n2. Press Cmd+Option+V 10 times as fast as possible\n3. Verify no crashes\n4. Verify app responsive\n5. Verify memory stable (no leak)\n\nExpected behavior:\n- Either: Queue executions (all 10 pastes occur)\n- Or: Cancel in-flight (only last paste occurs)\n- Both acceptable, as long as no crash\n\n✓ PASS / ✗ FAIL: _______\n```\n\n**Step 11: Accessibility Permission (Error Path)**\n```\nTest Case 10: No accessibility permission\n\nSteps:\n1. Open System Settings → Privacy \u0026 Security → Accessibility\n2. Remove OptimusClip from allowed apps\n3. Copy text: \"Test\"\n4. Press Cmd+Option+V\n5. Expected:\n   - Clipboard updated with transformed text\n   - Paste simulation fails (permission denied)\n   - Alert shown directing user to Settings\n   - No crash\n\n✓ PASS / ✗ FAIL: _______\n\n6. Re-grant permission\n7. Press Cmd+Option+V again\n8. Verify paste now works\n\n✓ PASS / ✗ FAIL: _______\n```\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. VERIFICATION SCRIPT (AUTOMATED):\n```swift\n// Tests/OptimusClipTests/Phase4VerificationTests.swift\n\nimport Testing\n@testable import OptimusClip\n\n@Suite(\"Phase 4 End-to-End Verification\")\nstruct Phase4VerificationTests {\n    \n    @Test(\"Quick Fix transformation on CLI output\")\n    func testQuickFixRealWorld() async throws {\n        let input = \"\"\"\n          This is a long line of text that was wrapped by the terminal at eighty\n          characters and now needs to be cleaned up for pasting into Slack or docs.\n          \"\"\"\n        \n        let expected = \"This is a long line of text that was wrapped by the terminal at eighty characters and now needs to be cleaned up for pasting into Slack or docs.\"\n        \n        // Execute Quick Fix transformation\n        let registry = TransformationRegistry.shared\n        let transforms = [\"builtin.strip_whitespace\", \"builtin.unwrap_lines\"]\n            .compactMap { registry.transformation(for: $0) }\n        \n        let pipeline = TransformationPipeline(transformations: transforms)\n        let result = try await pipeline.execute(input)\n        \n        #expect(result == expected)\n    }\n    \n    @Test(\"Code preservation - Python indentation\")\n    func testCodePreservation() async throws {\n        let input = \"\"\"\n          def calculate(x):\n              return x * 2\n          \"\"\"\n        \n        // Should strip leading 2 spaces but preserve internal indentation\n        let expected = \"\"\"\n          def calculate(x):\n              return x * 2\n          \"\"\"\n        \n        let registry = TransformationRegistry.shared\n        let stripTransform = registry.transformation(for: \"builtin.strip_whitespace\")!\n        \n        let result = try await stripTransform.transformAsync(input)\n        \n        // Verify relative indentation preserved\n        #expect(result.contains(\"    return\"))  // 4 spaces still present\n    }\n    \n    @Test(\"Performance - 10K lines under 500ms\")\n    func testLargeInputPerformance() async throws {\n        // Generate 10K lines\n        let lines = (0..\u003c10_000).map { i in\n            \"  Line \\(String(format: \"%05d\", i)) with text\"\n        }\n        let input = lines.joined(separator: \"\\n\")\n        \n        let registry = TransformationRegistry.shared\n        let transforms = [\"builtin.strip_whitespace\", \"builtin.unwrap_lines\"]\n            .compactMap { registry.transformation(for: $0) }\n        \n        let pipeline = TransformationPipeline(transformations: transforms)\n        \n        // Measure execution time\n        let start = Date()\n        let _ = try await pipeline.execute(input)\n        let duration = Date().timeIntervalSince(start)\n        \n        // Verify under 500ms\n        #expect(duration \u003c 0.5)\n    }\n    \n    @Test(\"Registry lookup - disabled transformation returns nil\")\n    func testDisabledTransformation() {\n        let registry = TransformationRegistry.shared\n        \n        // Disable transform\n        registry.setEnabled(false, for: \"builtin.quickfix\")\n        \n        // Lookup should return nil\n        let result = registry.transformation(for: \"builtin.quickfix\")\n        #expect(result == nil)\n        \n        // Re-enable\n        registry.setEnabled(true, for: \"builtin.quickfix\")\n    }\n}\n```\n\n2. MANUAL TEST CHECKLIST:\n```markdown\n# Phase 4 Verification Checklist\n\n## Automated Tests\n- [ ] All unit tests pass (swift test)\n- [ ] Code coverage \u003e90% for Phase 4 modules\n- [ ] No test failures or warnings\n\n## Real-World CLI Output\n- [ ] Test Case 1: Claude Code output (2-space + wrap) ✓ PASS\n- [ ] Test Case 2: Python code preservation ✓ PASS\n- [ ] Test Case 3: 10K line performance \u003c500ms ✓ PASS\n\n## Edge Cases\n- [ ] Test Case 4: Empty clipboard (silent failure) ✓ PASS\n- [ ] Test Case 5: Very long lines (\u003e1000 chars) ✓ PASS\n- [ ] Test Case 6: Unicode/emoji preservation ✓ PASS\n\n## UI/UX\n- [ ] Test Case 5: Menu bar state transitions ✓ PASS\n- [ ] Test Case 6: Hotkey registration/change ✓ PASS\n- [ ] Test Case 7: Enable/disable transformation ✓ PASS\n\n## Integration\n- [ ] Test Case 8: Paste in 5 different apps ✓ PASS\n- [ ] Test Case 9: Rapid hotkey presses (no crash) ✓ PASS\n- [ ] Test Case 10: Accessibility permission handling ✓ PASS\n\n## Performance\n- [ ] Algorithmic transforms \u003c100ms (typical input)\n- [ ] End-to-end latency \u003c200ms (press to paste)\n- [ ] Memory usage \u003c200MB\n- [ ] No memory leaks (10 consecutive executions)\n\n## Documentation\n- [ ] All task descriptions complete\n- [ ] Code comments present\n- [ ] README updated with Phase 4 features\n- [ ] Known limitations documented\n\n## Success Criteria (from Epic)\n- [ ] TransformationCore module created\n- [ ] Strip whitespace algorithm implemented\n- [ ] Unwrap lines algorithm implemented\n- [ ] Transformation pipeline architecture complete\n- [ ] Registry lookup working\n- [ ] Hotkeys trigger transformations\n- [ ] Menu bar shows processing state\n- [ ] All tests pass\n\n## Sign-Off\nVerified by: _____________\nDate: _____________\nPhase 4 Status: [ ] READY FOR PHASE 5 / [ ] NEEDS FIXES\n```\n\nARCHITECTURAL CONNECTIONS:\nThis task verifies integration of:\n- **Phase 1:** Menu bar icon and state management\n- **Phase 2:** Clipboard read/write and paste simulation\n- **Phase 3:** Hotkey detection and handler registration\n- **Phase 4:** All transformation components (pipeline, registry, algorithms)\n\nIt validates the complete flow:\n```\nUser Action → Hotkey Detection → Clipboard Read → Transformation → \nClipboard Write → Paste Simulation → Visual Feedback\n```\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. TEST DATA MUST BE REPRESENTATIVE:\n   - Use real Claude Code output (not synthetic)\n   - Include edge cases (empty, huge, Unicode)\n   - Test multiple languages (Python, Swift, Markdown)\n\n2. FLAKY TESTS:\n   - Performance tests might fail on slow machines\n   - Use generous timeouts (500ms vs 100ms)\n   - Run multiple times to detect intermittent failures\n\n3. MANUAL TESTS ARE SUBJECTIVE:\n   - \"Does the text look cleaned?\" is subjective\n   - Use exact string comparisons where possible\n   - Document expected vs actual for review\n\n4. ACCESSIBILITY PERMISSION:\n   - Can't automate permission grant/revoke\n   - Must test manually\n   - Document steps clearly\n\n5. APPLICATION COMPATIBILITY:\n   - Paste might fail in sandboxed apps\n   - Not a bug, just a limitation\n   - Document known incompatible apps\n\n6. TIMING-DEPENDENT TESTS:\n   - Menu bar state transitions are async\n   - Must wait for state changes\n   - Use polling or delays in tests\n\n7. UNICODE EDGE CASES:\n   - Test emoji: \"😀🎉\"\n   - Test combining characters: \"é\" (e + ´)\n   - Test RTL text: \"مرحبا\"\n   - Verify no corruption\n\n8. MEMORY LEAKS:\n   - Single execution might not show leak\n   - Must run 10+ times and measure\n   - Use Instruments for deeper analysis\n\nTESTING REQUIREMENTS:\n\n1. PREREQUISITES:\n   - Phase 4 code complete (all 3 tasks)\n   - Unit tests written and passing\n   - Build succeeds without warnings\n   - App launches and shows menu bar icon\n\n2. AUTOMATED TESTS:\n   ```bash\n   # Full test suite\n   swift test\n   \n   # With coverage\n   swift test --enable-code-coverage\n   \n   # Specific suite\n   swift test --filter Phase4VerificationTests\n   ```\n\n3. MANUAL TESTS:\n   - Follow checklist above\n   - Document PASS/FAIL for each case\n   - Take screenshots of failures\n   - Record performance numbers\n\n4. REGRESSION TESTS:\n   - Re-run all tests after bug fixes\n   - Ensure fixes don't break other tests\n   - Update test suite with new edge cases\n\nSUCCESS CRITERIA:\n- All automated tests pass (100%)\n- All manual test cases pass (≥9/10, document any expected fails)\n- Performance targets met:\n  - Algorithmic transforms: \u003c100ms\n  - End-to-end latency: \u003c200ms\n  - Memory usage: \u003c200MB\n  - No memory leaks\n- No critical bugs found\n- All edge cases handled gracefully\n- Documentation complete and accurate\n- Phase 4 ready for Phase 5 integration\n\nCOMPLETION CHECKLIST:\n- [ ] Ran `swift test` - all tests pass\n- [ ] Verified code coverage \u003e90%\n- [ ] Completed all 10 manual test cases\n- [ ] Measured performance on 10K line input\n- [ ] Tested in 5 different applications\n- [ ] Verified menu bar state transitions\n- [ ] Tested enable/disable functionality\n- [ ] Verified hotkey registration/change\n- [ ] Tested accessibility permission paths\n- [ ] Tested rapid hotkey presses (concurrency)\n- [ ] Documented any failures or limitations\n- [ ] Created bug tickets for any issues found\n- [ ] Updated README with Phase 4 status\n- [ ] Sign-off: Phase 4 VERIFIED ✓\n\nCONFIGURATION OPTIONS:\n- Performance timeout thresholds (configurable for CI)\n- Test input sizes (1K, 10K, 100K lines)\n- Enable/disable manual tests (CI vs local)\n\nPERFORMANCE CONSIDERATIONS:\n- Large input tests (10K lines) take ~500ms\n- Manual tests take ~30 minutes total\n- Full verification ~45-60 minutes\n- Run verification before each release\n\nIMPLEMENTATION ORDER:\n1. Ensure all Phase 4 tasks complete\n2. Run automated test suite\n3. Fix any test failures\n4. Run manual test cases 1-10\n5. Document results in checklist\n6. Fix any bugs found\n7. Re-run failed tests\n8. Measure performance metrics\n9. Update documentation\n10. Sign off on Phase 4 completion\n\nCODE ORGANIZATION:\nTests/OptimusClipTests/Phase4VerificationTests.swift\nTests/OptimusClipTests/ManualTestChecklist.md\nScripts/generate_test_data.sh\nScripts/run_verification.sh\n\nPRIORITY: P1 (Quality gate before Phase 5)\n\nESTIMATED TIME: 60 minutes (assumes Phase 4 code complete)\n\nDELIVERABLES:\n1. All automated tests passing\n2. Manual test checklist completed (PASS/FAIL documented)\n3. Performance metrics recorded\n4. Bug list (if any issues found)\n5. Sign-off confirmation\n6. Phase 4 → Phase 5 transition approval","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:07:34.255457-05:00","updated_at":"2025-12-13T15:47:30.831241-05:00","closed_at":"2025-12-13T15:47:30.831241-05:00","dependencies":[{"issue_id":"oc-j0g.8","depends_on_id":"oc-j0g","type":"parent-child","created_at":"2025-12-12T22:07:34.256385-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-j0g.8","depends_on_id":"oc-j0g.7","type":"blocks","created_at":"2025-12-12T22:07:34.25716-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-js9","title":"Missing network error catch in LLM provider clients","description":"## Problem\nThe LLM provider clients (AnthropicProviderClient, OpenAIProviderClient, etc.) don't catch URLSession network errors before they propagate up. When URLSession.shared.data(for:) throws network errors like:\n- URLError.notConnectedToInternet\n- URLError.networkConnectionLost  \n- URLError.timedOut\n\nThese get thrown without being mapped to LLMProviderError.network, bypassing the proper error categorization in ErrorRecoveryManager.\n\n## Root Cause\nIn AnthropicProviderClient.swift:26:\n```swift\nlet (data, response) = try await URLSession.shared.data(for: urlRequest)\n```\nThis line can throw URLError but it's not caught and mapped.\n\n## Fix\nWrap URLSession calls in do/catch and map URLErrors to LLMProviderError.network.\n\n## Impact\n- Users see cryptic error messages instead of friendly 'Check your internet connection'\n- ErrorRecoveryManager cannot properly categorize and recover from network errors","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-16T18:57:13.785196-05:00","updated_at":"2025-12-16T20:35:11.305355-05:00","closed_at":"2025-12-16T20:35:11.305355-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:08:18.029332-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-klf","title":"Missing Retry-After header parsing for rate limit errors","description":"## Problem\nWhen LLM providers return 429 (rate limited), they often include a Retry-After header indicating when the client should retry. Currently this header is not parsed.\n\n## Affected Code\nAnthropicProviderClient.swift:69:\n```swift\ncase 429:\n    throw LLMProviderError.rateLimited(retryAfter: nil)  // Always nil\n```\n\n## Fix\nParse the Retry-After header from HTTPURLResponse.allHeaderFields and pass it to the error.\n\n## Impact\n- User isn't told how long to wait\n- ErrorRecoveryManager can't provide specific retry timing","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-16T18:57:37.743148-05:00","updated_at":"2025-12-16T20:35:11.311287-05:00","closed_at":"2025-12-16T20:35:11.311287-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:08:18.036424-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-l9j","title":"Phase 6 - Data \u0026 Security (FINAL MVP)","description":"## Epic: Phase 6 - Data \u0026 Security (FINAL MVP)\n\n### Context \u0026 Strategic Importance\nPhase 6 is the FINAL phase of the MVP, transforming Optimus Clip from a functional prototype into a production-ready, secure, and reliable application. While earlier phases focused on features (clipboard, hotkeys, transformations, LLM), Phase 6 ensures the app is safe to use with real API keys and user data.\n\nThis phase is strategically placed LAST because:\n1. **Security depends on understanding attack surface** - We need all features complete to know what to secure\n2. **Error handling needs real error scenarios** - LLM integration (Phase 5) reveals actual failure modes\n3. **Data models depend on what we capture** - Transformation flow must exist before logging it\n4. **Launch-at-login requires stable app** - Only enable auto-start when app is reliable\n\n### Why Each Component Is Critical\n\n**Keychain API Key Storage (NFR-2.1 Compliance)**\nAPI keys are the crown jewels of Optimus Clip. A leaked key means:\n- Unauthorized usage billed to the user\n- Potential data exposure through the provider\n- User trust completely destroyed\n\nUserDefaults stores data in plain XML at ~/Library/Preferences/. Anyone with file access can read it. macOS Keychain encrypts data at rest, requires user authentication, and follows the principle of least privilege. This is a HARD REQUIREMENT for any app handling API credentials.\n\n**SwiftData History Logging (User Value)**\nHistory logging enables:\n- **Debugging**: \"Why did my last paste look weird?\" - check history\n- **Learning**: See which transformations get used most\n- **Recovery**: \"I need that text I transformed yesterday\"\n- **Future analytics UI**: Charts showing usage patterns (post-MVP)\n\nWe store metadata + input/output text (100 entries, configurable) in local SwiftData. No cloud sync, no telemetry - everything stays on device.\n\n**Launch at Login (User Expectation)**\nClipboard utilities MUST be always-available. If the user has to remember to launch it, they won't use it. Every competitor (Paste, Maccy, Flycut) has this feature. SMAppService is the modern, Apple-sanctioned approach (replaces deprecated LSSharedFileList and LaunchAtLogin frameworks).\n\n**Binary/Image Safety (Crash Prevention)**\nPhase 2 adds basic binary detection, but Phase 6 does a FINAL audit to ensure:\n- Images never reach text-only LLM APIs (prevents crashes)\n- Files never get processed (prevents data corruption)\n- All edge cases covered (screen recordings, PDFs, etc.)\n\n**Error Recovery \u0026 Resilience (Production Quality)**\nReal-world users will experience:\n- Network dropouts mid-transformation\n- API rate limits during heavy usage\n- Invalid API keys (expired, revoked, typos)\n- LLM timeouts on large inputs\n- Clipboard race conditions\n\nPhase 6 ensures graceful handling: preserve original clipboard, show clear errors, never crash, never lose data.\n\n### Technical Architecture\n\nThe architecture centers on:\n1. **KeychainWrapper Service** - Clean API for secure credential CRUD\n2. **SwiftData History Models** - Transformation logs with bounded storage\n3. **History Logging Service** - Fire-and-forget recording (async, non-blocking)\n4. **SMAppService Launch Manager** - Modern launch-at-login handling\n5. **Error Recovery System** - Graceful degradation and user notifications\n6. **Security Audit Checklist** - Comprehensive verification of all security requirements\n\n### Non-Functional Requirements Addressed\n- **NFR-2.1**: API Keys stored in macOS Keychain\n- **NFR-2.2**: No telemetry data sent to developer\n- **Performance**: Algorithmic transforms \u003c 100ms\n- **Reliability**: Failed transforms preserve clipboard\n- **Memory**: \u003c 200MB footprint (history logging bounded)\n\n### Success Criteria\n- ALL API keys stored exclusively in Keychain\n- History logging captures all transformations\n- Launch at login toggle works correctly\n- Binary clipboard content never crashes app\n- Network errors show user-friendly messages\n- App can run unattended for days without issues\n- Security audit checklist 100% complete\n- Performance verification passes (\u003c 100ms algorithmic)\n\n### Risk Mitigation\n| Risk | Mitigation |\n|------|------------|\n| Keychain access denied | Check entitlements, provide clear error message |\n| SwiftData corruption | Use migrations, backup/restore capability |\n| SMAppService fails | Graceful fallback, manual instructions in Settings |\n| Memory leak in history | Bounded storage (100 entries), explicit cleanup |\n\n### Dependencies\nDepends on Phase 5 (LLM Integration) being complete - we need actual LLM calls to implement proper error handling and history logging.\n\n### Milestone\nComplete, secure, production-ready MVP that users can trust with their API keys and daily workflow.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-12T22:04:52.118839-05:00","updated_at":"2025-12-14T22:50:13.471155-05:00","closed_at":"2025-12-14T22:50:13.471155-05:00","dependencies":[{"issue_id":"oc-l9j","depends_on_id":"oc-tmx","type":"blocks","created_at":"2025-12-13T09:40:12.680469-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.1","title":"SwiftData History Models","description":"## Task: SwiftData History Models\n\n### Background \u0026 Strategic Purpose\n\nThe History Models form the data layer that persists transformation records, enabling Optimus Clip to maintain an audit trail of all clipboard transformations. While the History UI is deferred to post-MVP, storing this data from day one is critical because:\n\n1. **Data Accumulation**: Users start building history immediately; retrofitting is impossible\n2. **Debug Support**: When transformations behave unexpectedly, history helps diagnose\n3. **Usage Insights**: Data enables future analytics (most-used transformations, peak times, etc.)\n4. **Recovery Option**: Users can potentially recover past transformations\n\n### Why SwiftData Over Alternatives\n\n**Option 1: UserDefaults**\n- ❌ Not designed for structured data\n- ❌ No query support\n- ❌ Poor performance with large datasets\n- ❌ Synchronous read/write blocks UI\n\n**Option 2: Core Data**\n- ✓ Mature, battle-tested\n- ❌ Complex boilerplate (NSManagedObjectContext, NSPersistentContainer)\n- ❌ Steep learning curve\n- ❌ Threading model confusing\n\n**Option 3: SQLite (raw)**\n- ✓ Maximum control\n- ❌ No Swift type safety\n- ❌ Manual query building\n- ❌ No automatic migrations\n\n**Option 4: SwiftData (CHOSEN)**\n- ✓ Swift-native, type-safe\n- ✓ Automatic schema migrations\n- ✓ Async-friendly with modern concurrency\n- ✓ Minimal boilerplate (@Model macro)\n- ✓ Built into macOS 14+/iOS 17+\n- ✓ Automatic CloudKit sync (future option)\n\n### Data Model Design\n\n```swift\nimport SwiftData\n\n/// A single transformation operation record\n@Model\nfinal class TransformationLog {\n    /// Unique identifier for this log entry\n    var id: UUID\n    \n    /// When the transformation occurred\n    var timestamp: Date\n    \n    /// Name of the transformation used (e.g., \"Quick Fix\", \"Jira Format\")\n    var transformationName: String\n    \n    /// Provider used for LLM transformations (nil for algorithmic)\n    var providerName: String?\n    \n    /// Model used for LLM transformations (nil for algorithmic)\n    var modelUsed: String?\n    \n    /// System prompt used for LLM transformations\n    var systemPrompt: String?\n    \n    /// Original text from clipboard (before transformation)\n    var inputText: String\n    \n    /// Transformed text (after transformation)\n    var outputText: String\n    \n    /// Character count of input (for analytics)\n    var inputCharCount: Int\n    \n    /// Processing time in milliseconds\n    var processingTimeMs: Int\n    \n    /// Whether transformation was successful\n    var wasSuccessful: Bool\n    \n    /// Error message if transformation failed (nil on success)\n    var errorMessage: String?\n    \n    init(\n        transformationName: String,\n        providerName: String? = nil,\n        modelUsed: String? = nil,\n        systemPrompt: String? = nil,\n        inputText: String,\n        outputText: String,\n        processingTimeMs: Int,\n        wasSuccessful: Bool = true,\n        errorMessage: String? = nil\n    ) {\n        self.id = UUID()\n        self.timestamp = Date()\n        self.transformationName = transformationName\n        self.providerName = providerName\n        self.modelUsed = modelUsed\n        self.systemPrompt = systemPrompt\n        self.inputText = inputText\n        self.outputText = outputText\n        self.inputCharCount = inputText.count\n        self.processingTimeMs = processingTimeMs\n        self.wasSuccessful = wasSuccessful\n        self.errorMessage = errorMessage\n    }\n}\n```\n\n### Schema Considerations\n\n**Why Store Both Input and Output?**\n- Debugging: Compare what went in vs what came out\n- Learning: See how transformations affect different inputs\n- Recovery: User might want original back\n- Analytics: Calculate compression ratios, etc.\n\n**Why Store Character Count Separately?**\n- Performance: Dont recount on every query\n- Analytics: Quick aggregation without loading full text\n- Indexing: Can create index on numeric field\n\n**Why Track Processing Time?**\n- Performance monitoring: Identify slow transformations\n- Provider comparison: Which LLM is fastest?\n- User feedback: Help users optimize their workflows\n\n### Configuration: Entry Limit\n\n```swift\nextension UserDefaults {\n    @AppStorage(\"history_entry_limit\") \n    var historyEntryLimit: Int = 100\n}\n```\n\n**Why 100 as default?**\n- Balances storage vs usefulness\n- 100 entries at ~2KB each = ~200KB (negligible)\n- Covers ~2-3 weeks of moderate use\n- Users can increase if needed (future settings UI)\n\n### Cleanup Strategy\n\n```swift\n@MainActor\nclass HistoryManager {\n    let modelContext: ModelContext\n    let entryLimit: Int\n    \n    /// Delete oldest entries beyond the limit\n    func pruneOldEntries() async throws {\n        let descriptor = FetchDescriptor\u003cTransformationLog\u003e(\n            sortBy: [SortDescriptor(\\.timestamp, order: .reverse)]\n        )\n        \n        let allEntries = try modelContext.fetch(descriptor)\n        \n        if allEntries.count \u003e entryLimit {\n            let entriesToDelete = allEntries.dropFirst(entryLimit)\n            for entry in entriesToDelete {\n                modelContext.delete(entry)\n            }\n            try modelContext.save()\n        }\n    }\n}\n```\n\n**Cleanup Trigger Points:**\n1. After each new log entry (check and prune if needed)\n2. On app launch (catch up if app was killed)\n3. When user changes limit in settings\n\n### Integration with App Lifecycle\n\n```swift\n@main\nstruct OptimusClipApp: App {\n    let modelContainer: ModelContainer\n    \n    init() {\n        do {\n            modelContainer = try ModelContainer(for: TransformationLog.self)\n        } catch {\n            fatalError(\"Failed to initialize SwiftData: \\\\(error)\")\n        }\n    }\n    \n    var body: some Scene {\n        MenuBarExtra(\"Optimus Clip\", systemImage: \"clipboard\") {\n            // ...\n        }\n        .modelContainer(modelContainer)\n    }\n}\n```\n\n### Query Patterns (For Future History UI)\n\n```swift\n// Most recent entries\nlet recentDescriptor = FetchDescriptor\u003cTransformationLog\u003e(\n    sortBy: [SortDescriptor(\\.timestamp, order: .reverse)]\n)\nrecentDescriptor.fetchLimit = 20\n\n// Filter by transformation name\nlet quickFixDescriptor = FetchDescriptor\u003cTransformationLog\u003e(\n    predicate: #Predicate { $0.transformationName == \"Quick Fix\" }\n)\n\n// Filter by provider\nlet anthropicDescriptor = FetchDescriptor\u003cTransformationLog\u003e(\n    predicate: #Predicate { $0.providerName == \"Anthropic\" }\n)\n\n// Failed transformations only\nlet failedDescriptor = FetchDescriptor\u003cTransformationLog\u003e(\n    predicate: #Predicate { $0.wasSuccessful == false }\n)\n\n// Search input text (for future search feature)\nlet searchDescriptor = FetchDescriptor\u003cTransformationLog\u003e(\n    predicate: #Predicate { $0.inputText.contains(\"TODO\") }\n)\n```\n\n### Security Considerations\n\n**What NOT to Store:**\n- ❌ API keys (use Keychain)\n- ❌ Passwords or secrets from clipboard\n- ❌ Any PII detection/filtering (future consideration)\n\n**What We DO Store:**\n- ✓ Transformation metadata\n- ✓ Input/output text (user accepts this implicitly)\n- ✓ Provider/model names (not credentials)\n\n**Future Enhancement: Sensitive Content Detection**\nConsider adding opt-in feature to NOT log entries containing:\n- Credit card patterns\n- Social security numbers\n- API key patterns\n- Password-like strings\n\n### Performance Considerations\n\n**Async Operations:**\n- All SwiftData operations should be async\n- Use detached tasks for logging (dont block transformation)\n- ModelContext is NOT thread-safe - use @MainActor or dedicated actor\n\n**Batch Operations:**\n- Cleanup can process many entries; do in batches\n- Use autoreleasepool for large deletions\n\n**Memory Management:**\n- Fetch only what you need (use fetchLimit)\n- Dont keep ModelContext alive longer than needed\n- Consider fetchOffset for pagination\n\n### Testing Requirements\n\n- [ ] Create TransformationLog entry with all fields\n- [ ] Query recent entries by timestamp\n- [ ] Filter by transformation name\n- [ ] Filter by provider\n- [ ] Prune entries beyond limit\n- [ ] Handle missing optional fields gracefully\n- [ ] Verify automatic schema migration on model changes\n- [ ] Test with 1000+ entries for performance\n- [ ] Verify SwiftData persistence across app restarts\n\n### Success Criteria\n\n- [ ] @Model class compiles without errors\n- [ ] ModelContainer initializes successfully\n- [ ] Can create, read, update, delete entries\n- [ ] Automatic cleanup keeps entries under limit\n- [ ] No UI blocking during log operations\n- [ ] Data persists across app restarts\n- [ ] Queries perform acceptably with 100 entries\n\n### Architectural Connections\n\n- **History Logging Service (oc-l9j.11)**: Uses this model for persistence\n- **TransformationCoordinator**: Calls logging after each transformation\n- **Future History UI**: Will query and display this data\n- **Settings**: Will configure entry limit","notes":"Implemented SwiftData-backed history logging (models/store + coordinator wiring), tagged transformations with metadata, and added Settings UI to manage history entry limits and recent entries.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:59.430003-05:00","updated_at":"2025-12-14T22:04:02.171021-05:00","closed_at":"2025-12-14T22:04:02.171021-05:00","dependencies":[{"issue_id":"oc-l9j.1","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-13T09:39:53.14482-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.1","depends_on_id":"oc-tmx","type":"blocks","created_at":"2025-12-13T09:40:24.178244-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.10","title":"Phase 6 (MVP) Verification","description":"BACKGROUND \u0026 CONTEXT:\nPhase 6 (MVP) Verification is the comprehensive quality gate that validates ALL features from ALL phases are working correctly before declaring the Minimum Viable Product complete. This is the final checklist before the app transitions from \"in development\" to \"ready for daily use.\"\n\nUnlike individual phase verifications (which test one area), this is a full integration test of the entire system:\n- Menu bar UI (Phase 1)\n- Clipboard monitoring and paste simulation (Phase 2)\n- Hotkeys and settings (Phase 3)\n- Transformation engine (Phase 4)\n- LLM integration (Phase 5)\n- Data persistence and security (Phase 6)\n\nThis task ensures that features work correctly in ISOLATION and IN COMBINATION. For example:\n- Settings persist across app restarts\n- Hotkeys trigger transformations that save to history\n- API keys from Keychain successfully authenticate LLM calls\n- Binary data safety prevents corrupted transformations\n- All NFRs are met under real-world load\n\nThe deliverable is a signed-off checklist confirming every requirement from the PRD is implemented, tested, and working. This is the foundation for Phase 7 (release infrastructure) and eventual public distribution.\n\nThink of this as a \"pre-flight checklist\" for a rocket launch. Every system must be green before proceeding.\n\nREAL-WORLD PROBLEM/USE CASE:\nScenario: Team declares MVP \"done\" without comprehensive verification\n\n1. WITHOUT VERIFICATION:\n   - Developer tests own features in isolation\n   - \"Settings work for me\" ✓\n   - \"Transformations work\" ✓\n   - Ships to beta users\n   \n2. ACTUAL USER EXPERIENCE:\n   - User installs app\n   - Sets up API keys in Settings\n   - Keys appear to save\n   - User quits app\n   - Reopens app next day\n   - API keys GONE (Keychain integration broken)\n   - User reconfigures\n   - Creates LLM transformation\n   - Hotkey doesn't trigger (hotkey registration broken after quit/relaunch)\n   - User tries algorithmic transformation\n   - Copies image, presses hotkey\n   - App crashes (binary data safety not implemented)\n   - User uninstalls\n   - Negative review: \"Unstable, loses settings\"\n\n3. WITH COMPREHENSIVE VERIFICATION:\n   - All integration points tested\n   - Keychain persistence verified across restarts\n   - Hotkey registration verified after quit/relaunch\n   - Binary data safety confirmed\n   - User has smooth experience\n   - Positive review: \"Rock solid, works as expected\"\n\nAnother scenario: Performance regression\n- Developer adds feature in Phase 5\n- Accidentally blocks main thread with synchronous API call\n- Individual feature works, but UI becomes janky\n- Without comprehensive verification, ships to users\n- With verification, caught before release\n\nThis task prevents \"it works on my machine\" syndrome.\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. COMPREHENSIVE VERIFICATION SCRIPT:\n```bash\n#!/usr/bin/env bash\n# Scripts/verify_mvp_complete.sh\n# Comprehensive MVP verification checklist\n\nset -euo pipefail\n\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m' # No Color\n\nPASS_COUNT=0\nFAIL_COUNT=0\n\ncheck() {\n    local description=\"$1\"\n    local command=\"$2\"\n    \n    echo -n \"Checking: $description... \"\n    \n    if eval \"$command\" \u0026\u003e/dev/null; then\n        echo -e \"${GREEN}✓${NC}\"\n        ((PASS_COUNT++))\n        return 0\n    else\n        echo -e \"${RED}✗${NC}\"\n        ((FAIL_COUNT++))\n        return 1\n    fi\n}\n\necho \"=== Optimus Clip MVP Verification ===\"\necho \"Running comprehensive feature checklist...\"\necho \"\"\n\n# === PHASE 0: Project Structure ===\necho \"--- Phase 0: Project Structure ---\"\ncheck \"Package.swift exists\" \"test -f Package.swift\"\ncheck \"version.env exists\" \"test -f version.env\"\ncheck \"Info.plist exists\" \"test -f Info.plist\"\ncheck \"CLAUDE.md exists\" \"test -f CLAUDE.md\"\ncheck \"Project builds (debug)\" \"swift build\"\ncheck \"Project builds (release)\" \"swift build -c release\"\ncheck \"Tests pass\" \"swift test\"\n\n# === PHASE 1: Menu Bar Shell ===\necho \"\"\necho \"--- Phase 1: Menu Bar Shell ---\"\ncheck \"OptimusClip.app bundle exists\" \"test -d OptimusClip.app\"\ncheck \"Info.plist has LSUIElement=true\" \"grep -q '\u003ckey\u003eLSUIElement\u003c/key\u003e' OptimusClip.app/Contents/Info.plist\"\ncheck \"App launches\" \"pgrep -x OptimusClip || (open OptimusClip.app \u0026\u0026 sleep 2 \u0026\u0026 pgrep -x OptimusClip)\"\ncheck \"Menu bar icon visible\" \"osascript -e 'tell application \\\"System Events\\\" to get name of every process whose background only is true' | grep -q OptimusClip\"\n\n# === PHASE 2: Clipboard \u0026 Paste ===\necho \"\"\necho \"--- Phase 2: Clipboard \u0026 Paste ---\"\ncheck \"ClipboardMonitor.swift exists\" \"test -f Sources/OptimusClip/Services/ClipboardMonitor.swift\"\ncheck \"Self-write marker implemented\" \"grep -q 'com.optimusclip.marker' Sources/OptimusClip/Services/ClipboardMonitor.swift\"\ncheck \"Accessibility permission check exists\" \"grep -q 'AXIsProcessTrusted' Sources/OptimusClip/**/*.swift\"\n\n# === PHASE 3: Hotkeys \u0026 Settings ===\necho \"\"\necho \"--- Phase 3: Hotkeys \u0026 Settings ---\"\ncheck \"KeyboardShortcuts dependency\" \"grep -q 'KeyboardShortcuts' Package.swift\"\ncheck \"SettingsView exists\" \"test -f Sources/OptimusClip/Views/Settings/SettingsView.swift\"\ncheck \"Transformations tab exists\" \"test -f Sources/OptimusClip/Views/Settings/Transformations/*.swift\"\ncheck \"Providers tab exists\" \"test -f Sources/OptimusClip/Views/Settings/Providers/*.swift\"\ncheck \"Permissions tab exists\" \"test -f Sources/OptimusClip/Views/Settings/Permissions/*.swift\"\n\n# === PHASE 4: Transformation Engine ===\necho \"\"\necho \"--- Phase 4: Transformation Engine ---\"\ncheck \"TransformationEngine exists\" \"test -f Sources/OptimusClip/Services/TransformationEngine.swift\"\ncheck \"Algorithmic transformations implemented\" \"grep -q 'AlgorithmicTransformation' Sources/OptimusClip/**/*.swift\"\ncheck \"Transformation tests exist\" \"test -f Tests/OptimusClipTests/TransformationTests.swift\"\n\n# === PHASE 5: LLM Integration ===\necho \"\"\necho \"--- Phase 5: LLM Integration ---\"\ncheck \"LLMChatOpenAI dependency\" \"grep -q 'LLMChatOpenAI' Package.swift\"\ncheck \"LLMChatAnthropic dependency\" \"grep -q 'LLMChatAnthropic' Package.swift\"\ncheck \"LLM provider clients exist\" \"test -d Sources/OptimusClip/Services/LLM/\"\ncheck \"Timeout handling implemented\" \"grep -q 'timeout' Sources/OptimusClip/Services/LLM/*.swift\"\n\n# === PHASE 6: Data \u0026 Security ===\necho \"\"\necho \"--- Phase 6: Data \u0026 Security ---\"\ncheck \"SwiftData models exist\" \"test -f Sources/OptimusClip/Models/HistoryEntry.swift\"\ncheck \"Keychain integration exists\" \"grep -q 'SecAddGenericPassword\\|SecItemCopyMatching' Sources/OptimusClip/**/*.swift\"\ncheck \"Launch at login implemented\" \"grep -q 'SMAppService' Sources/OptimusClip/**/*.swift\"\ncheck \"Binary data safety check exists\" \"grep -q 'clipboardContainsProcessableText' Sources/OptimusClip/**/*.swift\"\n\n# === NFR VERIFICATION ===\necho \"\"\necho \"--- Non-Functional Requirements ---\"\ncheck \"Performance tests exist\" \"test -f Tests/OptimusClipTests/Performance/*.swift\"\ncheck \"Memory \u003c 200MB verified\" \"grep -q '\u003c 200' Tests/OptimusClipTests/Performance/*.swift\"\ncheck \"Algorithmic \u003c 100ms verified\" \"grep -q '\u003c 100' Tests/OptimusClipTests/Performance/*.swift\"\n\n# === SECURITY AUDIT ===\necho \"\"\necho \"--- Security Audit ---\"\ncheck \"No hardcoded API keys\" \"! grep -r 'sk-[a-zA-Z0-9]\\\\{48\\\\}' Sources/\"\ncheck \"No API keys in logs\" \"! grep -r 'print.*apiKey\\|NSLog.*apiKey' Sources/\"\ncheck \"Keychain storage for secrets\" \"grep -q 'kSecClass' Sources/OptimusClip/**/*.swift\"\n\necho \"\"\necho \"===================================\"\necho \"Results: ${GREEN}${PASS_COUNT} passed${NC}, ${RED}${FAIL_COUNT} failed${NC}\"\necho \"===================================\"\n\nif [ $FAIL_COUNT -eq 0 ]; then\n    echo -e \"${GREEN}✅ MVP VERIFICATION COMPLETE - ALL CHECKS PASSED${NC}\"\n    exit 0\nelse\n    echo -e \"${RED}❌ MVP VERIFICATION FAILED - FIX ISSUES ABOVE${NC}\"\n    exit 1\nfi\n```\n\n2. INTERACTIVE MANUAL TESTING CHECKLIST:\n```markdown\n# Manual Testing Checklist (Interactive)\n\n## Phase 1: Menu Bar UI\n- [ ] App appears in menu bar (no Dock icon)\n- [ ] Click menu bar icon → dropdown appears\n- [ ] \"Settings/Preferences\" menu item exists\n- [ ] Cmd+, opens Settings\n- [ ] \"Quit\" menu item exists and works\n- [ ] Icon shows idle state (full opacity)\n- [ ] Icon shows processing state (pulse animation) during transformation\n\n## Phase 2: Clipboard \u0026 Paste\n- [ ] Copy text → clipboard monitoring detects change\n- [ ] Trigger transformation → processed text written to clipboard\n- [ ] Paste simulation works (Cmd+V sent)\n- [ ] Self-write marker prevents reprocessing\n- [ ] Grace delay handles promised data (copy from browser)\n\n## Phase 3: Hotkeys \u0026 Settings\n- [ ] Settings window opens with TabView\n- [ ] Transformations tab shows list\n- [ ] Add new transformation button works\n- [ ] Hotkey recorder captures shortcuts\n- [ ] Custom hotkey triggers transformation\n- [ ] Enable/disable toggle works\n- [ ] Settings persist across app restart\n- [ ] Accessibility permission callout appears (if not granted)\n- [ ] \"Open Settings\" button launches System Settings\n\n## Phase 4: Transformation Engine\n- [ ] Uppercase transformation works\n- [ ] Lowercase transformation works\n- [ ] Title case transformation works\n- [ ] Trim transformation works\n- [ ] Unwrap transformation works\n- [ ] Large text (10KB) transforms successfully\n- [ ] Special characters preserved\n- [ ] Unicode emoji preserved\n\n## Phase 5: LLM Integration\n- [ ] OpenAI provider configuration works\n- [ ] Anthropic provider configuration works\n- [ ] OpenRouter provider configuration works\n- [ ] Ollama provider configuration works (if server running)\n- [ ] AWS Bedrock provider configuration works\n- [ ] Model list fetches dynamically\n- [ ] LLM transformation with OpenAI works\n- [ ] LLM transformation with Anthropic works\n- [ ] System prompt customization works\n- [ ] Timeout triggers on slow network (30s default)\n- [ ] Error handling for invalid API key\n- [ ] Processing animation shows during LLM call\n\n## Phase 6: Data \u0026 Security\n- [ ] History entries saved to SwiftData\n- [ ] History includes timestamp, provider, model, prompt\n- [ ] API keys stored in Keychain (verify with Keychain Access.app)\n- [ ] API keys NOT in UserDefaults (check ~/Library/Preferences/)\n- [ ] API keys NOT in plaintext anywhere\n- [ ] API keys persist across app restart\n- [ ] Launch at login toggle works\n- [ ] App launches at login when enabled\n- [ ] Binary data safety: Copy image → no transformation\n- [ ] Binary data safety: Copy PDF → no transformation\n- [ ] Binary data safety: User feedback (beep or icon flash)\n- [ ] Error recovery: Invalid API key → error message\n- [ ] Error recovery: No network → timeout + error\n\n## Cross-Phase Integration\n- [ ] Quit app → Relaunch → Settings persisted\n- [ ] Quit app → Relaunch → API keys still work\n- [ ] Quit app → Relaunch → Hotkeys still registered\n- [ ] Multiple rapid transformations → no crashes\n- [ ] Switch provider mid-session → works correctly\n- [ ] Edit transformation → changes take effect immediately\n- [ ] Delete transformation → hotkey unregistered\n\n## NFR Verification\n- [ ] Algorithmic transformation \u003c 100ms (feel instant)\n- [ ] UI responsive during LLM call (menu bar clickable)\n- [ ] Memory usage \u003c 200MB (Activity Monitor)\n- [ ] No memory leaks (run Instruments)\n- [ ] CPU usage \u003c 5% idle (Activity Monitor)\n- [ ] No excessive battery drain\n\n## Security Verification\n- [ ] No API keys in Console.app logs\n- [ ] API keys masked in UI (SecureField shows dots)\n- [ ] No telemetry data sent to developer\n- [ ] All data stored locally\n- [ ] Clipboard never sent anywhere except configured LLM providers\n```\n\n3. AUTOMATED INTEGRATION TESTS:\n```swift\n// IntegrationTests.swift\nimport Testing\nimport Foundation\n\n@Suite(\"MVP Integration Tests\")\nstruct MVPIntegrationTests {\n    \n    @Test(\"End-to-end: Text transformation\")\n    func testEndToEndTransformation() async throws {\n        // Setup\n        let app = OptimusClipApp()\n        let input = \"  hello world  \"\n        \n        // Simulate user workflow\n        NSPasteboard.general.clearContents()\n        NSPasteboard.general.setString(input, forType: .string)\n        \n        // Trigger transformation\n        try await app.transformationEngine.executeTransformation(hotkey: .defaultTrim)\n        \n        // Verify\n        let output = NSPasteboard.general.string(forType: .string)\n        #expect(output == \"hello world\")\n    }\n    \n    @Test(\"Settings persistence across restart\")\n    func testSettingsPersistence() async throws {\n        // Set API key\n        let keychain = KeychainManager()\n        try keychain.save(key: \"test_key_12345\", for: .openai)\n        \n        // Simulate app restart (clear memory)\n        let keychain2 = KeychainManager()\n        let retrieved = try keychain2.load(for: .openai)\n        \n        #expect(retrieved == \"test_key_12345\")\n    }\n    \n    @Test(\"Binary data safety\")\n    func testBinaryDataSafety() async throws {\n        // Copy image\n        let image = NSImage(systemSymbolName: \"star\", accessibilityDescription: nil)!\n        NSPasteboard.general.clearContents()\n        NSPasteboard.general.writeObjects([image])\n        \n        // Attempt transformation\n        let monitor = ClipboardMonitor()\n        let canProcess = monitor.clipboardContainsProcessableText()\n        \n        #expect(!canProcess, \"Should reject binary data\")\n    }\n    \n    @Test(\"LLM timeout enforcement\")\n    func testLLMTimeout() async throws {\n        let engine = TransformationEngine()\n        engine.timeoutSeconds = 2\n        \n        let start = Date()\n        do {\n            _ = try await engine.transformWithLLM(\n                text: \"test\",\n                provider: MockSlowLLMProvider(delaySeconds: 5),\n                model: \"test\",\n                systemPrompt: \"test\"\n            )\n            Issue.record(\"Should have timed out\")\n        } catch TransformationError.timeout {\n            let elapsed = Date().timeIntervalSince(start)\n            #expect(elapsed \u003e= 2.0 \u0026\u0026 elapsed \u003c 3.0)\n        }\n    }\n}\n```\n\n4. HISTORY VERIFICATION:\n```swift\n// HistoryVerificationTests.swift\n@Test(\"History logging works\")\nfunc testHistoryLogging() async throws {\n    let manager = HistoryManager()\n    \n    // Perform transformation\n    let entry = HistoryEntry(\n        timestamp: Date(),\n        transformationName: \"Test Transform\",\n        provider: \"OpenAI\",\n        model: \"gpt-4o-mini\",\n        systemPrompt: \"Test prompt\",\n        originalText: \"input\",\n        processedText: \"output\",\n        inputCharCount: 5,\n        processingTimeMs: 123.4\n    )\n    \n    manager.addEntry(entry)\n    \n    // Verify saved\n    let entries = try await manager.fetchRecentEntries(limit: 10)\n    #expect(entries.count \u003e= 1)\n    #expect(entries.first?.transformationName == \"Test Transform\")\n}\n```\n\nARCHITECTURAL CONNECTIONS:\nThis task touches EVERY component in the system:\n- Menu Bar UI (Phase 1)\n- ClipboardMonitor (Phase 2)\n- PasteSimulation (Phase 2)\n- AccessibilityPermissionManager (Phase 2/3)\n- HotkeyManager (Phase 3)\n- SettingsView (Phase 3)\n- TransformationEngine (Phase 4)\n- AlgorithmicTransformations (Phase 4)\n- LLMProviderClients (Phase 5)\n- HistoryManager (Phase 6)\n- KeychainManager (Phase 6)\n- LaunchAtLoginManager (Phase 6)\n- BinaryDataSafety (Phase 6)\n\nThis is the ultimate integration test.\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. RESTART BEHAVIOR:\n   - Settings must persist (UserDefaults)\n   - API keys must persist (Keychain)\n   - Hotkeys must re-register (KeyboardShortcuts re-init)\n   - SwiftData context must reconnect\n   - Test cold start vs warm restart\n\n2. PERMISSION REVOCATION:\n   - User grants Accessibility, then revokes later\n   - App must detect and show warning again\n   - Hotkeys should gracefully fail (not crash)\n\n3. RACE CONDITIONS:\n   - Rapid clipboard changes (user copies multiple times quickly)\n   - Multiple transformations triggered in succession\n   - Settings changed during active transformation\n\n4. RESOURCE EXHAUSTION:\n   - 100+ transformations in a session\n   - Large clipboard content (1MB text)\n   - All 5 LLM providers configured\n   - History database with 10,000 entries\n\n5. NETWORK CONDITIONS:\n   - No internet connection\n   - Slow/flaky connection\n   - API provider down\n   - Rate limiting\n\n6. SYSTEM STATES:\n   - Low memory warning\n   - Computer sleep/wake\n   - User logout/login\n   - macOS update\n\n7. MULTI-USER:\n   - Different macOS user accounts\n   - Fast user switching\n   - Each user has separate settings/history\n\nTESTING REQUIREMENTS:\n\n**Automated:**\n- Run verify_mvp_complete.sh → all checks pass\n- Run swift test → all tests pass\n- Run integration test suite → all pass\n- Run performance benchmarks → NFRs met\n\n**Manual:**\n- Complete manual testing checklist (interactive)\n- Test on fresh macOS install (no cached data)\n- Test with real API providers (OpenAI, Anthropic, etc.)\n- Test all transformation types\n- Test all edge cases listed above\n\n**Real-World:**\n- Use app for actual work for 1 week\n- Test with daily CLI workflows\n- Verify stability under real usage patterns\n- Collect feedback from team members\n\nSUCCESS CRITERIA:\n- All automated tests pass\n- Manual checklist 100% complete\n- No critical bugs found\n- No memory leaks\n- No crashes during 1-week dogfooding\n- All PRD requirements implemented\n- All NFRs met with measurements documented\n- README updated with current features\n- CHANGELOG updated with v1.0.0 MVP entry\n- Team consensus: \"Ready for daily use\"\n\nDELIVERABLES:\n1. ✅ verify_mvp_complete.sh passes\n2. ✅ Manual testing checklist completed\n3. ✅ Integration test suite passes\n4. ✅ Performance benchmarks meet NFRs\n5. ✅ Security audit checklist passed\n6. ✅ 1-week dogfooding completed\n7. ✅ No critical bugs in backlog\n8. ✅ Documentation updated\n9. ✅ Team sign-off: \"MVP COMPLETE\"\n\nPOST-VERIFICATION:\nOnce this task passes, the MVP is DONE. Next steps:\n- Tag release: v1.0.0-mvp\n- Optional: Proceed to Phase 7 (Release Infrastructure)\n- Optional: TestFlight beta distribution\n- Optional: Public release preparation\n\nCONFIGURATION OPTIONS:\n- Verification strictness: permissive vs strict\n- Manual test requirement: optional vs required\n- Dogfooding duration: 1 week (default) vs 2 weeks\n- Performance thresholds: standard vs aggressive\n\nPERFORMANCE CONSIDERATIONS:\n- Verification itself should run fast (\u003c 5 minutes)\n- Automated tests should be deterministic\n- Manual tests should be quick to execute\n- Don't block development on slow network tests\n\nSECURITY CONSIDERATIONS:\n- Verify no secrets leaked in code\n- Verify no telemetry to developer\n- Verify Keychain permissions correct\n- Verify clipboard data stays local\n- Audit all network calls (only to configured providers)\n\nIMPLEMENTATION ORDER:\n1. Create verify_mvp_complete.sh script\n2. Create manual testing checklist (Markdown)\n3. Write integration test suite\n4. Run automated verification\n5. Fix any failures\n6. Complete manual testing\n7. Document results\n8. Begin 1-week dogfooding\n9. Address any bugs found\n10. Final team review and sign-off\n\nCODE ORGANIZATION:\nScripts/verify_mvp_complete.sh (new)\ndocs/manual_testing_checklist.md (new)\nTests/OptimusClipTests/IntegrationTests.swift (new)\nTests/OptimusClipTests/HistoryVerificationTests.swift (new)\nverification_results/latest.json (new)\n\nPRIORITY: P1 (Blocks MVP completion)\n\nESTIMATED TIME: 240 minutes (4 hours)\n- Script creation: 60 min\n- Automated test writing: 60 min\n- Running verification: 30 min\n- Manual testing: 60 min\n- Documentation: 30 min\n\nDEPENDENCIES:\n- ALL previous phases must be complete\n- All individual phase verifications must pass\n- Performance verification (oc-l9j.9) must pass\n- Binary safety check (oc-l9j.6) must pass\n\nACCEPTANCE:\n- ✅ verify_mvp_complete.sh passes with 100% checks\n- ✅ All automated tests pass\n- ✅ Manual checklist 100% complete\n- ✅ 1-week dogfooding with no critical bugs\n- ✅ Team consensus: \"MVP READY\"\n- ✅ Documentation complete and up-to-date\n- ✅ v1.0.0-mvp tagged in git\n\nFINAL MILESTONE:\n🎉 **OPTIMUS CLIP MVP COMPLETE**\nReady for daily use, dogfooding, and optional public release preparation.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:06:04.621672-05:00","updated_at":"2025-12-16T19:47:03.824727-05:00","closed_at":"2025-12-16T19:47:03.824727-05:00","close_reason":"All 62 MVP verification checks pass: Phase 0-6 structure, security audit, NFRs, and 271 tests. MVP ready for release.","dependencies":[{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-12T22:06:04.622129-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j.1","type":"blocks","created_at":"2025-12-12T23:53:56.567691-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j.3","type":"blocks","created_at":"2025-12-12T23:53:56.737179-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j.5","type":"blocks","created_at":"2025-12-12T23:53:56.99679-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j.6","type":"blocks","created_at":"2025-12-12T23:53:57.190246-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j.7","type":"blocks","created_at":"2025-12-12T23:53:57.498685-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j.8","type":"blocks","created_at":"2025-12-12T23:54:08.653894-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j.9","type":"blocks","created_at":"2025-12-12T23:54:08.76979-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j.11","type":"blocks","created_at":"2025-12-12T23:54:09.084816-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.10","depends_on_id":"oc-l9j.12","type":"blocks","created_at":"2025-12-12T23:54:09.343732-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.11","title":"History Logging Service","description":"## Task: History Logging Service\n\n### Background \u0026 Purpose\n\nThe History Logging Service is the write path for transformation records. Every transformation - whether successful or failed - flows through this service to be persisted in SwiftData. This creates the audit trail that powers debugging, analytics, and the future History UI.\n\n**Key Design Principle:**\n\u003e Logging is a side effect. Transformation success must NEVER depend on logging success.\n\nIf the database is corrupted, full, or inaccessible, transformations must still work. Users care about their clipboard working, not about whether we logged it.\n\n### Why a Dedicated Service?\n\n**Separation of Concerns:**\n- TransformationCoordinator: Orchestrates the flow\n- TransformationEngine: Does the actual work\n- HistoryLoggingService: Records what happened\n\nEach component has one job. The logging service doesn't know about hotkeys, clipboard, or LLMs - it just logs.\n\n**Testability:**\n- Can mock the logging service in tests\n- Can verify logging calls without running real transformations\n- Can test logging failure handling in isolation\n\n**Future Flexibility:**\n- Could add remote logging (analytics)\n- Could add export functionality\n- Could add sync across devices\n- Service abstraction makes changes easy\n\n### Technical Implementation\n\n```swift\nimport SwiftData\nimport os.log\n\n/// Service responsible for persisting transformation history\n@MainActor\nfinal class HistoryLoggingService {\n    private let modelContext: ModelContext\n    private let logger = Logger(subsystem: \"com.optimusclip\", category: \"history\")\n\n    /// Maximum entries to retain (from user settings)\n    @AppStorage(\"history_entry_limit\") private var entryLimit: Int = 100\n\n    init(modelContext: ModelContext) {\n        self.modelContext = modelContext\n    }\n\n    /// Log a transformation result\n    /// - Note: This method never throws. Logging failures are swallowed.\n    func log(\n        transformationName: String,\n        providerName: String? = nil,\n        modelUsed: String? = nil,\n        systemPrompt: String? = nil,\n        inputText: String,\n        outputText: String,\n        processingTimeMs: Int,\n        wasSuccessful: Bool = true,\n        errorMessage: String? = nil\n    ) {\n        Task.detached(priority: .utility) { [weak self] in\n            await self?.performLog(\n                transformationName: transformationName,\n                providerName: providerName,\n                modelUsed: modelUsed,\n                systemPrompt: systemPrompt,\n                inputText: inputText,\n                outputText: outputText,\n                processingTimeMs: processingTimeMs,\n                wasSuccessful: wasSuccessful,\n                errorMessage: errorMessage\n            )\n        }\n    }\n\n    @MainActor\n    private func performLog(\n        transformationName: String,\n        providerName: String?,\n        modelUsed: String?,\n        systemPrompt: String?,\n        inputText: String,\n        outputText: String,\n        processingTimeMs: Int,\n        wasSuccessful: Bool,\n        errorMessage: String?\n    ) {\n        do {\n            // Create new entry\n            let entry = TransformationLog(\n                transformationName: transformationName,\n                providerName: providerName,\n                modelUsed: modelUsed,\n                systemPrompt: systemPrompt,\n                inputText: inputText,\n                outputText: outputText,\n                processingTimeMs: processingTimeMs,\n                wasSuccessful: wasSuccessful,\n                errorMessage: errorMessage\n            )\n\n            modelContext.insert(entry)\n            try modelContext.save()\n\n            // Prune old entries if over limit\n            try pruneIfNeeded()\n\n            logger.debug(\"Logged transformation: \\(transformationName)\")\n\n        } catch {\n            // CRITICAL: Never propagate logging errors\n            logger.error(\"Failed to log transformation: \\(error.localizedDescription)\")\n        }\n    }\n\n    private func pruneIfNeeded() throws {\n        var descriptor = FetchDescriptor\u003cTransformationLog\u003e(\n            sortBy: [SortDescriptor(\\.timestamp, order: .reverse)]\n        )\n\n        let count = try modelContext.fetchCount(descriptor)\n\n        guard count \u003e entryLimit else { return }\n\n        // Fetch entries beyond limit\n        descriptor.fetchOffset = entryLimit\n        let entriesToDelete = try modelContext.fetch(descriptor)\n\n        for entry in entriesToDelete {\n            modelContext.delete(entry)\n        }\n\n        try modelContext.save()\n        logger.debug(\"Pruned \\(entriesToDelete.count) old entries\")\n    }\n}\n```\n\n### Non-Blocking Architecture\n\n**Why Task.detached?**\n- Transformation flow: Hotkey -\u003e Read -\u003e Transform -\u003e Write -\u003e Paste\n- Logging happens AFTER paste is complete\n- User sees result immediately, logging happens in background\n- If logging is slow, user doesn't notice\n\n**Flow Diagram:**\n```\nUser presses hotkey\n        |\n        v\n   Read clipboard\n        |\n        v\n   Transform text -----\u003e Log started (detached)\n        |                      |\n        v                      v\n   Write clipboard      Insert to SwiftData\n        |                      |\n        v                      |\n   Paste (CGEvent)       Prune old entries\n        |                      |\n        v                      v\n   User sees result       Save complete\n   (immediate)            (background)\n```\n\n### Error Handling Philosophy\n\n**Logging errors are NON-FATAL:**\n```swift\n} catch {\n    // Log to os.log for debugging, but don't crash or throw\n    logger.error(\"Failed to log: \\(error)\")\n    // User's transformation still worked!\n}\n```\n\n**When might logging fail?**\n- Disk full (SwiftData storage exhausted)\n- Database corruption (rare but possible)\n- Permission issues (sandboxing problems)\n- Memory pressure (system killing background tasks)\n\n**What we do about it:**\n- Log to os.log (visible in Console.app)\n- Continue operation normally\n- Don't show error to user (they don't care about logging)\n- Consider alerting on repeated failures (future enhancement)\n\n### Integration with TransformationCoordinator\n\n```swift\nclass TransformationCoordinator {\n    private let historyService: HistoryLoggingService\n\n    func executeTransformation(\n        _ transformation: Transformation,\n        input: String\n    ) async throws -\u003e String {\n        let startTime = CFAbsoluteTimeGetCurrent()\n\n        do {\n            let result = try await transformation.transform(input)\n            let elapsedMs = Int((CFAbsoluteTimeGetCurrent() - startTime) * 1000)\n\n            // Log success (fire and forget)\n            historyService.log(\n                transformationName: transformation.displayName,\n                providerName: transformation.providerName,\n                modelUsed: transformation.modelName,\n                systemPrompt: transformation.systemPrompt,\n                inputText: input,\n                outputText: result,\n                processingTimeMs: elapsedMs,\n                wasSuccessful: true\n            )\n\n            return result\n\n        } catch {\n            let elapsedMs = Int((CFAbsoluteTimeGetCurrent() - startTime) * 1000)\n\n            // Log failure (fire and forget)\n            historyService.log(\n                transformationName: transformation.displayName,\n                providerName: transformation.providerName,\n                modelUsed: transformation.modelName,\n                systemPrompt: transformation.systemPrompt,\n                inputText: input,\n                outputText: \"\",\n                processingTimeMs: elapsedMs,\n                wasSuccessful: false,\n                errorMessage: error.localizedDescription\n            )\n\n            throw error  // Re-throw to coordinator for user notification\n        }\n    }\n}\n```\n\n### Performance Considerations\n\n**Async Logging:**\n- `Task.detached(priority: .utility)` runs at low priority\n- System scheduler manages resources\n- Does not block main thread or transformation pipeline\n\n**Batch Pruning:**\n- Check count before fetching all entries\n- Only fetch entries beyond limit\n- Single save() call for all deletions\n\n**Memory Management:**\n- SwiftData handles memory efficiently\n- Large text fields (input/output) not loaded until accessed\n- Use fetch limits when querying for UI\n\n### Configuration Options\n\n```swift\nextension UserDefaults {\n    /// Maximum number of history entries to retain\n    @AppStorage(\"history_entry_limit\")\n    var historyEntryLimit: Int = 100\n\n    /// Whether to log failed transformations\n    @AppStorage(\"history_log_failures\")\n    var historyLogFailures: Bool = true\n\n    /// Whether to store full input/output text (vs truncated)\n    @AppStorage(\"history_store_full_text\")\n    var historyStoreFullText: Bool = true\n}\n```\n\n### Testing Checklist\n\n- [ ] Successful transformation is logged\n- [ ] Failed transformation is logged with error message\n- [ ] Processing time is accurate (within 10ms)\n- [ ] Logging failure does not crash app\n- [ ] Logging failure does not prevent transformation\n- [ ] Entries are pruned when over limit\n- [ ] Oldest entries are pruned (not random)\n- [ ] Concurrent transformations log correctly\n- [ ] Large text inputs are handled\n- [ ] Empty input/output handled gracefully\n\n### Success Criteria\n\n- [ ] Every transformation creates a log entry\n- [ ] Log entries contain all required fields\n- [ ] Entries automatically pruned at limit\n- [ ] No UI blocking during logging\n- [ ] Logging failures are silent to user\n- [ ] os.log captures logging errors for debugging\n- [ ] Performance impact \u003c 10ms on transformation time\n\n### Architectural Connections\n\n- **SwiftData History Models (oc-l9j.1)**: Data model this service writes to\n- **TransformationCoordinator (oc-74q.7)**: Calls logging after each transformation\n- **Future History UI**: Will query data this service creates\n- **Settings General Tab**: Will configure entry limit","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:18.13134-05:00","updated_at":"2025-12-14T22:29:45.934484-05:00","closed_at":"2025-12-14T22:29:45.934484-05:00","dependencies":[{"issue_id":"oc-l9j.11","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-12T22:06:18.13187-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.11","depends_on_id":"oc-l9j.1","type":"blocks","created_at":"2025-12-12T23:53:55.842531-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.12","title":"Keychain Wrapper Service","description":"## Task: Keychain Wrapper Service\n\n### Background \u0026 Motivation\n\nThe macOS Security framework provides Keychain Services - a powerful but low-level C-style API for secure credential storage. While functional, the raw API is verbose, error-prone, and not idiomatic Swift. A wrapper service abstracts this complexity into a clean, type-safe Swift interface.\n\n**The Problem with Raw Keychain API:**\n```swift\n// This is what the raw API looks like\nvar query: [CFString: Any] = [\n    kSecClass: kSecClassGenericPassword,\n    kSecAttrService: \"com.example.service\" as CFString,\n    kSecAttrAccount: \"api_key\" as CFString,\n    kSecReturnData: kCFBooleanTrue as Any,\n    kSecMatchLimit: kSecMatchLimitOne\n]\n\nvar result: AnyObject?\nlet status = SecItemCopyMatching(query as CFDictionary, \u0026result)\n\n// Now handle every possible OSStatus...\nswitch status {\ncase errSecSuccess:\n    // Cast, decode, handle...\ncase errSecItemNotFound:\n    // ...\ncase errSecDuplicateItem:\n    // ...\n// 50+ other error codes...\n}\n```\n\n**The Solution - Our Wrapper:**\n```swift\n// Clean, Swift-idiomatic API\nlet key = try KeychainWrapper.shared.getString(\n    service: \"com.optimusclip.openai\",\n    account: \"api_key\"\n)\n```\n\n### Why a Wrapper is Essential\n\n1. **Ergonomics**: Swift developers expect throwing functions, not OSStatus codes\n2. **Type Safety**: Raw API uses `CFString`, `CFDictionary`, `AnyObject` - not safe\n3. **Error Clarity**: OSStatus -25300 means nothing; `KeychainError.itemNotFound` is clear\n4. **Testability**: Can mock the wrapper in tests\n5. **Single Responsibility**: All Keychain logic in one place\n6. **Consistency**: Same patterns for all credential types\n\n### Technical Implementation\n\n```swift\nimport Security\nimport Foundation\n\n/// Type-safe wrapper for macOS Keychain Services\nfinal class KeychainWrapper {\n    static let shared = KeychainWrapper()\n\n    private init() {}\n\n    // MARK: - Save Operations\n\n    /// Save a string value to the Keychain\n    func saveString(\n        _ value: String,\n        service: String,\n        account: String,\n        accessibility: CFString = kSecAttrAccessibleAfterFirstUnlock\n    ) throws {\n        guard let data = value.data(using: .utf8) else {\n            throw KeychainError.encodingFailed\n        }\n\n        try saveData(data, service: service, account: account, accessibility: accessibility)\n    }\n\n    /// Save raw data to the Keychain\n    func saveData(\n        _ data: Data,\n        service: String,\n        account: String,\n        accessibility: CFString = kSecAttrAccessibleAfterFirstUnlock\n    ) throws {\n        // First, try to delete existing item (if any)\n        let deleteQuery: [CFString: Any] = [\n            kSecClass: kSecClassGenericPassword,\n            kSecAttrService: service,\n            kSecAttrAccount: account\n        ]\n        SecItemDelete(deleteQuery as CFDictionary)\n\n        // Add new item\n        let addQuery: [CFString: Any] = [\n            kSecClass: kSecClassGenericPassword,\n            kSecAttrService: service,\n            kSecAttrAccount: account,\n            kSecValueData: data,\n            kSecAttrAccessible: accessibility\n        ]\n\n        let status = SecItemAdd(addQuery as CFDictionary, nil)\n\n        guard status == errSecSuccess else {\n            throw KeychainError(status: status)\n        }\n    }\n\n    // MARK: - Retrieve Operations\n\n    /// Retrieve a string value from the Keychain\n    func getString(service: String, account: String) throws -\u003e String? {\n        guard let data = try getData(service: service, account: account) else {\n            return nil\n        }\n\n        guard let string = String(data: data, encoding: .utf8) else {\n            throw KeychainError.decodingFailed\n        }\n\n        return string\n    }\n\n    /// Retrieve raw data from the Keychain\n    func getData(service: String, account: String) throws -\u003e Data? {\n        let query: [CFString: Any] = [\n            kSecClass: kSecClassGenericPassword,\n            kSecAttrService: service,\n            kSecAttrAccount: account,\n            kSecReturnData: true,\n            kSecMatchLimit: kSecMatchLimitOne\n        ]\n\n        var result: AnyObject?\n        let status = SecItemCopyMatching(query as CFDictionary, \u0026result)\n\n        switch status {\n        case errSecSuccess:\n            return result as? Data\n        case errSecItemNotFound:\n            return nil\n        default:\n            throw KeychainError(status: status)\n        }\n    }\n\n    // MARK: - Delete Operations\n\n    /// Delete an item from the Keychain\n    func delete(service: String, account: String) throws {\n        let query: [CFString: Any] = [\n            kSecClass: kSecClassGenericPassword,\n            kSecAttrService: service,\n            kSecAttrAccount: account\n        ]\n\n        let status = SecItemDelete(query as CFDictionary)\n\n        // Item not found is OK for delete (idempotent)\n        guard status == errSecSuccess || status == errSecItemNotFound else {\n            throw KeychainError(status: status)\n        }\n    }\n\n    // MARK: - Utility Operations\n\n    /// Check if an item exists in the Keychain (without retrieving it)\n    func exists(service: String, account: String) -\u003e Bool {\n        let query: [CFString: Any] = [\n            kSecClass: kSecClassGenericPassword,\n            kSecAttrService: service,\n            kSecAttrAccount: account,\n            kSecMatchLimit: kSecMatchLimitOne\n        ]\n\n        let status = SecItemCopyMatching(query as CFDictionary, nil)\n        return status == errSecSuccess\n    }\n}\n```\n\n### Error Handling\n\n```swift\n/// Errors that can occur during Keychain operations\nenum KeychainError: LocalizedError {\n    case itemNotFound\n    case duplicateItem\n    case authFailed\n    case userCanceled\n    case accessDenied\n    case encodingFailed\n    case decodingFailed\n    case unhandledError(OSStatus)\n\n    init(status: OSStatus) {\n        switch status {\n        case errSecItemNotFound:\n            self = .itemNotFound\n        case errSecDuplicateItem:\n            self = .duplicateItem\n        case errSecAuthFailed:\n            self = .authFailed\n        case errSecUserCanceled:\n            self = .userCanceled\n        case errSecInteractionNotAllowed:\n            self = .accessDenied\n        default:\n            self = .unhandledError(status)\n        }\n    }\n\n    var errorDescription: String? {\n        switch self {\n        case .itemNotFound:\n            return \"The requested item was not found in the Keychain.\"\n        case .duplicateItem:\n            return \"An item with this identifier already exists.\"\n        case .authFailed:\n            return \"Authentication failed. Check your credentials.\"\n        case .userCanceled:\n            return \"The operation was canceled by the user.\"\n        case .accessDenied:\n            return \"Access to the Keychain was denied. The device may be locked.\"\n        case .encodingFailed:\n            return \"Failed to encode the value for storage.\"\n        case .decodingFailed:\n            return \"Failed to decode the stored value.\"\n        case .unhandledError(let status):\n            return \"Keychain error: \\(status)\"\n        }\n    }\n}\n```\n\n### Usage Patterns in Optimus Clip\n\n**Provider-Specific Convenience Methods:**\n```swift\nextension KeychainWrapper {\n    private enum Service {\n        static let openai = \"com.optimusclip.openai\"\n        static let anthropic = \"com.optimusclip.anthropic\"\n        static let openrouter = \"com.optimusclip.openrouter\"\n        static let awsAccessKey = \"com.optimusclip.aws.accesskey\"\n        static let awsSecretKey = \"com.optimusclip.aws.secretkey\"\n    }\n\n    private static let account = \"api_key\"\n\n    // OpenAI\n    func saveOpenAIKey(_ key: String) throws {\n        try saveString(key, service: Service.openai, account: Self.account)\n    }\n\n    func getOpenAIKey() throws -\u003e String? {\n        try getString(service: Service.openai, account: Self.account)\n    }\n\n    func deleteOpenAIKey() throws {\n        try delete(service: Service.openai, account: Self.account)\n    }\n\n    // Anthropic\n    func saveAnthropicKey(_ key: String) throws {\n        try saveString(key, service: Service.anthropic, account: Self.account)\n    }\n\n    func getAnthropicKey() throws -\u003e String? {\n        try getString(service: Service.anthropic, account: Self.account)\n    }\n\n    // ... similar for other providers\n}\n```\n\n### Thread Safety Considerations\n\nThe Security framework's Keychain APIs are **thread-safe** at the system level. However, our wrapper should be designed with concurrent access in mind:\n\n```swift\nfinal class KeychainWrapper: @unchecked Sendable {\n    // Singleton is safe because underlying APIs are thread-safe\n    static let shared = KeychainWrapper()\n\n    // No mutable state in the wrapper itself\n    private init() {}\n\n    // All methods are pure functions over the system Keychain\n}\n```\n\n### Testability\n\n```swift\n/// Protocol for Keychain operations (enables mocking)\nprotocol KeychainService {\n    func saveString(_ value: String, service: String, account: String) throws\n    func getString(service: String, account: String) throws -\u003e String?\n    func delete(service: String, account: String) throws\n}\n\nextension KeychainWrapper: KeychainService {}\n\n/// Mock for testing\nclass MockKeychainService: KeychainService {\n    var storage: [String: String] = [:]\n\n    func saveString(_ value: String, service: String, account: String) throws {\n        storage[\"\\(service):\\(account)\"] = value\n    }\n\n    func getString(service: String, account: String) throws -\u003e String? {\n        storage[\"\\(service):\\(account)\"]\n    }\n\n    func delete(service: String, account: String) throws {\n        storage.removeValue(forKey: \"\\(service):\\(account)\")\n    }\n}\n```\n\n### Edge Cases \u0026 Gotchas\n\n**1. First Launch After Reboot:**\n- With `kSecAttrAccessibleAfterFirstUnlock`, keys are not accessible until first unlock\n- App should handle gracefully (prompt user, show settings)\n\n**2. iCloud Keychain Sync:**\n- By default, items may sync across devices (if user enabled iCloud Keychain)\n- Use `kSecAttrSynchronizable: false` if you want device-local only\n\n**3. Keychain Access Prompts:**\n- When accessing items first time, system may prompt for permission\n- Handle `errSecUserCanceled` gracefully\n\n**4. Sandbox Boundaries:**\n- App can only access its own Keychain items (by bundle ID)\n- Cannot access items created by other apps\n\n**5. Migration from UserDefaults:**\n- If app previously stored keys in UserDefaults, migrate on first launch\n- Delete from UserDefaults after successful migration\n\n### Testing Checklist\n\n- [ ] Save string value - retrieves correctly\n- [ ] Save empty string - handles gracefully\n- [ ] Save Unicode characters - encodes/decodes correctly\n- [ ] Retrieve non-existent item - returns nil (not error)\n- [ ] Delete existing item - succeeds\n- [ ] Delete non-existent item - succeeds (idempotent)\n- [ ] Overwrite existing item - new value stored\n- [ ] exists() returns true for stored item\n- [ ] exists() returns false for missing item\n- [ ] Error messages are user-friendly\n- [ ] Works after system reboot (after first unlock)\n- [ ] Mock implementation works for tests\n\n### Success Criteria\n\n- [ ] Clean, Swift-idiomatic API surface\n- [ ] All OSStatus errors mapped to typed errors\n- [ ] Singleton pattern for shared access\n- [ ] Provider-specific convenience methods\n- [ ] Protocol-based for testability\n- [ ] Thread-safe design\n- [ ] Comprehensive error messages\n\n### Architectural Connections\n\n- **Keychain API Key Storage (oc-l9j.3)**: Uses this wrapper for actual storage\n- **Providers Tab UI (oc-4tw.5)**: Calls wrapper via provider settings\n- **LLM Providers (Phase 5)**: Retrieve keys at runtime via wrapper\n- **Settings Migration (future)**: Would use wrapper for key migration","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:06:18.65958-05:00","updated_at":"2025-12-13T19:08:45.024292-05:00","closed_at":"2025-12-13T19:08:45.024292-05:00","dependencies":[{"issue_id":"oc-l9j.12","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-12T22:06:18.66006-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.12","depends_on_id":"oc-l9j.3","type":"blocks","created_at":"2025-12-12T23:53:56.331997-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.2","title":"History Logging Service","description":"Implement service to log each transformation to SwiftData. WHY NEEDED: Provides audit trail of all transformations for debugging and user insights. IMPLEMENTATION: Create HistoryLoggingService with async log() method. After each transformation, log to SwiftData in background. Automatic cleanup of entries beyond configured limit (default 100). CRITICAL: Must be async and non-blocking - if logging fails, transformation still succeeds. Error handling with os_log for debugging but never throw errors to caller. ARCHITECTURE: Called by TransformationCoordinator after successful transformation. Uses SwiftData ModelContext for persistence. PERFORMANCE: Async logging ensures no impact on transformation speed. Background cleanup prevents memory issues. FUTURE: This data will power a History UI (post-MVP) showing past transformations with search/filter capabilities.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:00.136146-05:00","updated_at":"2025-12-12T22:17:40.032462-05:00","closed_at":"2025-12-12T22:17:40.032462-05:00","dependencies":[{"issue_id":"oc-l9j.2","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-12T22:06:00.136978-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.3","title":"Keychain API Key Storage","description":"## Task: Keychain API Key Storage\n\n### Background \u0026 Security Imperative\n\nAPI keys are credentials. Like passwords, they grant access to paid services and must NEVER be stored in plaintext. This is not a \"nice to have\" - it is a fundamental security requirement.\n\n**What happens if API keys are exposed:**\n- **Financial Damage**: Attacker uses your OpenAI/Anthropic credits (hundreds to thousands of dollars)\n- **Account Termination**: Provider bans your account for TOS violation\n- **Privacy Breach**: Attacker can see all API usage, potentially sensitive prompts\n- **Reputation Damage**: If you distribute app with exposed keys, your reputation is destroyed\n\n### Why Keychain Over Alternatives\n\n**Option 1: UserDefaults (NEVER DO THIS)**\n- Stored in plaintext XML: `~/Library/Preferences/com.bundle.id.plist`\n- Readable by any process\n- Visible with `defaults read com.bundle.id`\n- Backed up to iCloud/Time Machine (keys spread everywhere)\n\n**Option 2: File on disk (NEVER DO THIS)**\n- `.env` file, config.json, etc.\n- No encryption at rest\n- Git accidents waiting to happen\n- Backup software copies it everywhere\n\n**Option 3: Environment Variables (Development only)**\n- OK for local dev, not for distribution\n- User would have to set them manually\n- Not persistent across reboots without shell config\n\n**Option 4: macOS Keychain (CORRECT CHOICE)**\n- Encrypted at rest (AES-256-GCM)\n- Protected by user login password\n- Sandboxed access (only your app can read its items)\n- Secure Enclave integration on Apple Silicon\n- Native macOS API (Security framework)\n- Survives app updates (keyed by service+account)\n\n### Security Framework Implementation\n\n**Core Concepts:**\n- **Service**: Identifies your app (e.g., \"com.optimusclip.openai\")\n- **Account**: Identifies the key within that service (e.g., \"api_key\")\n- **Class**: Type of item (`kSecClassGenericPassword` for API keys)\n\n**Save Key to Keychain:**\n```swift\nimport Security\n\nfunc saveAPIKey(_ key: String, provider: String) throws {\n    let service = \"com.optimusclip.\\(provider)\"\n    let account = \"api_key\"\n\n    // Convert key to data\n    guard let keyData = key.data(using: .utf8) else {\n        throw KeychainError.invalidData\n    }\n\n    // Build query\n    let query: [CFString: Any] = [\n        kSecClass: kSecClassGenericPassword,\n        kSecAttrService: service,\n        kSecAttrAccount: account,\n        kSecValueData: keyData,\n        kSecAttrAccessible: kSecAttrAccessibleAfterFirstUnlock\n    ]\n\n    // Delete existing (if any) then add\n    SecItemDelete(query as CFDictionary)\n    let status = SecItemAdd(query as CFDictionary, nil)\n\n    guard status == errSecSuccess else {\n        throw KeychainError.unhandledError(status: status)\n    }\n}\n```\n\n**Retrieve Key from Keychain:**\n```swift\nfunc getAPIKey(provider: String) throws -\u003e String? {\n    let service = \"com.optimusclip.\\(provider)\"\n    let account = \"api_key\"\n\n    let query: [CFString: Any] = [\n        kSecClass: kSecClassGenericPassword,\n        kSecAttrService: service,\n        kSecAttrAccount: account,\n        kSecReturnData: true,\n        kSecMatchLimit: kSecMatchLimitOne\n    ]\n\n    var result: AnyObject?\n    let status = SecItemCopyMatching(query as CFDictionary, \u0026result)\n\n    switch status {\n    case errSecSuccess:\n        guard let data = result as? Data,\n              let key = String(data: data, encoding: .utf8) else {\n            throw KeychainError.invalidData\n        }\n        return key\n    case errSecItemNotFound:\n        return nil\n    default:\n        throw KeychainError.unhandledError(status: status)\n    }\n}\n```\n\n**Delete Key from Keychain:**\n```swift\nfunc deleteAPIKey(provider: String) throws {\n    let service = \"com.optimusclip.\\(provider)\"\n    let account = \"api_key\"\n\n    let query: [CFString: Any] = [\n        kSecClass: kSecClassGenericPassword,\n        kSecAttrService: service,\n        kSecAttrAccount: account\n    ]\n\n    let status = SecItemDelete(query as CFDictionary)\n\n    guard status == errSecSuccess || status == errSecItemNotFound else {\n        throw KeychainError.unhandledError(status: status)\n    }\n}\n```\n\n### Accessibility Options Explained\n\nThe `kSecAttrAccessible` attribute controls WHEN the key can be accessed:\n\n| Value | When Accessible | Use Case |\n|-------|-----------------|----------|\n| `kSecAttrAccessibleWhenUnlocked` | Only while device unlocked | Most secure, but fails if screen locked |\n| `kSecAttrAccessibleAfterFirstUnlock` | After first unlock until reboot | **RECOMMENDED** - balances security/usability |\n| `kSecAttrAccessibleAlways` | Always (deprecated) | Don't use - security risk |\n| `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly` | Requires passcode, not backed up | Very secure, but loses keys on passcode change |\n\n**Why `kSecAttrAccessibleAfterFirstUnlock`:**\n- Keys available immediately after login\n- Works when screen locks (background operations)\n- Still encrypted when device is off\n- Syncs to iCloud Keychain (if user enabled)\n\n### Service Identifiers by Provider\n\n| Provider | Service Name |\n|----------|-------------|\n| OpenAI | `com.optimusclip.openai` |\n| Anthropic | `com.optimusclip.anthropic` |\n| OpenRouter | `com.optimusclip.openrouter` |\n| AWS Access Key | `com.optimusclip.aws.accesskey` |\n| AWS Secret Key | `com.optimusclip.aws.secretkey` |\n\n### Error Handling\n\n```swift\nenum KeychainError: LocalizedError {\n    case itemNotFound\n    case duplicateItem\n    case invalidData\n    case accessDenied\n    case unhandledError(status: OSStatus)\n\n    var errorDescription: String? {\n        switch self {\n        case .itemNotFound:\n            return \"API key not found. Please configure in Settings.\"\n        case .duplicateItem:\n            return \"API key already exists.\"\n        case .invalidData:\n            return \"Invalid API key data.\"\n        case .accessDenied:\n            return \"Keychain access denied. Check system permissions.\"\n        case .unhandledError(let status):\n            return \"Keychain error: \\(status)\"\n        }\n    }\n}\n```\n\n### Integration with Settings UI\n\n```swift\nstruct ProviderAPIKeyField: View {\n    let provider: String\n    @State private var apiKey: String = \"\"\n    @State private var isSaved: Bool = false\n\n    var body: some View {\n        HStack {\n            SecureField(\"API Key\", text: $apiKey)\n                .textFieldStyle(.roundedBorder)\n                .onChange(of: apiKey) { _, _ in\n                    isSaved = false\n                }\n\n            Button(isSaved ? \"Saved\" : \"Save\") {\n                saveKey()\n            }\n            .disabled(apiKey.isEmpty || isSaved)\n        }\n        .onAppear {\n            loadKey()\n        }\n    }\n\n    private func loadKey() {\n        if let key = try? KeychainManager.shared.getAPIKey(provider: provider) {\n            apiKey = key\n            isSaved = true\n        }\n    }\n\n    private func saveKey() {\n        do {\n            try KeychainManager.shared.saveAPIKey(apiKey, provider: provider)\n            isSaved = true\n        } catch {\n            // Show error alert\n        }\n    }\n}\n```\n\n### CRITICAL Security Rules\n\n1. **NEVER log API keys** - not even in debug builds\n2. **NEVER include keys in error messages** - use generic messages\n3. **NEVER store keys in UserDefaults** - even \"temporarily\"\n4. **NEVER hardcode keys in source** - not even for testing\n5. **NEVER transmit keys except to the provider** - no analytics, no telemetry\n\n### Testing Checklist\n\n- [ ] Save API key - verify stored in Keychain (use Keychain Access.app)\n- [ ] Retrieve API key - verify correct value returned\n- [ ] Delete API key - verify removed from Keychain\n- [ ] Missing key - returns nil, no crash\n- [ ] Invalid data - throws appropriate error\n- [ ] Duplicate save - overwrites without error\n- [ ] App restart - keys persist\n- [ ] Different providers - keys isolated correctly\n- [ ] Keychain Access.app shows correct service names\n\n### Success Criteria\n\n- [ ] All API keys stored in Keychain, not UserDefaults\n- [ ] Keys persist across app restarts\n- [ ] Keys survive app updates\n- [ ] Keys isolated per provider\n- [ ] Clear error messages without exposing keys\n- [ ] Settings UI can save/load/delete keys\n- [ ] No keys visible in any log output\n\n### Architectural Connections\n\n- **Keychain Wrapper Service (oc-l9j.12)**: Provides clean Swift API\n- **Providers Tab UI (oc-4tw.5)**: Uses this for save/load\n- **LLM Providers (Phase 5)**: Retrieve keys at runtime\n- **Security Audit Checklist (oc-l9j.8)**: Verifies this implementation","notes":"Implemented Keychain-backed API key storage surface: added APIKeyStore (Keychain with legacy @AppStorage migration), ProviderCredentialsResolver to emit LLMCredentials from Keychain + settings (OpenAI/Anthropic/OpenRouter/Ollama/AWS Bedrock with bearer-token preference), updated ProvidersTabView to save/load via Keychain, and added tests for APIKeyStore + resolver. Build green: make check, make test. Remaining: wire runtime LLM consumers to use ProviderCredentialsResolver/factory.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:06:00.6727-05:00","updated_at":"2025-12-14T22:01:04.697527-05:00","closed_at":"2025-12-14T22:01:04.697527-05:00","dependencies":[{"issue_id":"oc-l9j.3","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-13T09:39:52.09507-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.3","depends_on_id":"oc-tmx","type":"blocks","created_at":"2025-12-13T09:40:23.781336-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.4","title":"Keychain Wrapper Service","description":"Create clean Swift interface for Keychain operations. WHY NEEDED: Security framework's Keychain API is low-level C-style. A wrapper provides type-safe, Swift-friendly interface with proper error handling. IMPLEMENTATION: KeychainWrapper class with methods: save(key: String, value: String, service: String) throws, retrieve(key: String, service: String) throws -\u003e String?, delete(key: String, service: String) throws. Use SecItemAdd, SecItemCopyMatching, SecItemUpdate, SecItemDelete APIs. ERROR HANDLING: Map Keychain OSStatus codes to Swift errors: KeychainError.itemNotFound, .duplicateItem, .accessDenied, .unhandledError(OSStatus). Provide user-friendly error messages for Settings UI. SECURITY: Use kSecClass = kSecClassGenericPassword. Set kSecAttrService to bundle ID + provider name for uniqueness. Use kSecAttrAccount as key identifier. ARCHITECTURE: Single source of truth for all Keychain operations. Used by Settings UI for persistence and by LLM providers for runtime key retrieval. TESTING: Must handle edge cases like missing keys, duplicate saves, and access denied scenarios gracefully.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:06:01.325175-05:00","updated_at":"2025-12-12T22:17:34.042932-05:00","closed_at":"2025-12-12T22:17:34.042932-05:00","dependencies":[{"issue_id":"oc-l9j.4","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-12T22:06:01.325635-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.5","title":"Launch at Login via SMAppService","description":"## Task: Launch at Login via SMAppService\n\n### Background \u0026 User Expectation\n\nClipboard utilities are inherently \"always on\" tools. Users expect them to be available the moment they log in, without manual launching. Every major clipboard manager (Paste, Maccy, Clipy, Alfred) supports this feature, and its absence would be a significant usability gap.\n\n**User Mental Model:**\n\u003e \"I set up Optimus Clip, configured my hotkeys, and now I expect it to just work. Forever. I should not have to remember to launch it.\"\n\n### Why Launch at Login Matters\n\n1. **Seamless Experience**: User configures once, benefits forever\n2. **Reduced Friction**: No manual launching = no forgotten launches\n3. **Professional Expectation**: All similar tools offer this\n4. **Background Services**: Menu bar apps are expected to auto-start\n\n### Historical Context: Evolution of Launch at Login APIs\n\n**Legacy Approach 1: Login Items (deprecated)**\n- Manual manipulation of `~/Library/Preferences/com.apple.loginitems.plist`\n- Brittle, undocumented, removed in modern macOS\n\n**Legacy Approach 2: LSSharedFileList (deprecated macOS 13+)**\n- `LSSharedFileListInsertItemURL`, `LSSharedFileListRemove`\n- Better but still complex, deprecated in Ventura\n\n**Legacy Approach 3: LaunchAtLogin-Modern (community package)**\n- Wrapper around various APIs\n- Works but adds dependency\n\n**Modern Approach: SMAppService (macOS 13+, RECOMMENDED)**\n- Apple's official, supported API\n- Part of ServiceManagement framework\n- Simple, clean API\n- Automatic cleanup on app uninstall\n- No third-party dependencies\n\n### Technical Implementation\n\n**Basic Usage:**\n```swift\nimport ServiceManagement\n\n// Enable launch at login\nfunc enableLaunchAtLogin() {\n    do {\n        try SMAppService.mainApp.register()\n        print(\"Launch at login enabled\")\n    } catch {\n        print(\"Failed to enable launch at login: \\(error)\")\n    }\n}\n\n// Disable launch at login\nfunc disableLaunchAtLogin() {\n    do {\n        try SMAppService.mainApp.unregister()\n        print(\"Launch at login disabled\")\n    } catch {\n        print(\"Failed to disable launch at login: \\(error)\")\n    }\n}\n\n// Check current status\nfunc isLaunchAtLoginEnabled() -\u003e Bool {\n    return SMAppService.mainApp.status == .enabled\n}\n```\n\n**SMAppService.Status Values:**\n- `.notRegistered` - Never been registered\n- `.enabled` - Currently enabled\n- `.requiresApproval` - Waiting for user approval (rare)\n- `.notFound` - App bundle not found (error state)\n\n### Integration with Settings UI\n\n```swift\nstruct GeneralTabView: View {\n    @AppStorage(\"launchAtLogin\") private var launchAtLoginSetting = false\n    @State private var actualStatus: SMAppService.Status = .notRegistered\n\n    var body: some View {\n        Form {\n            Section(\"Startup\") {\n                Toggle(\"Launch at Login\", isOn: $launchAtLoginSetting)\n                    .onChange(of: launchAtLoginSetting) { _, newValue in\n                        updateLaunchAtLogin(enabled: newValue)\n                    }\n\n                if actualStatus == .requiresApproval {\n                    Label(\"Requires approval in System Settings\", systemImage: \"exclamationmark.triangle\")\n                        .foregroundColor(.orange)\n                        .font(.caption)\n                }\n            }\n        }\n        .onAppear {\n            syncStateWithSystem()\n        }\n    }\n\n    private func updateLaunchAtLogin(enabled: Bool) {\n        do {\n            if enabled {\n                try SMAppService.mainApp.register()\n            } else {\n                try SMAppService.mainApp.unregister()\n            }\n            actualStatus = SMAppService.mainApp.status\n        } catch {\n            // Revert toggle on failure\n            launchAtLoginSetting = !enabled\n            // Show error to user\n        }\n    }\n\n    private func syncStateWithSystem() {\n        actualStatus = SMAppService.mainApp.status\n        launchAtLoginSetting = (actualStatus == .enabled)\n    }\n}\n```\n\n### State Synchronization Considerations\n\n**Problem: Toggle vs Reality Mismatch**\n\nUser can disable launch at login in System Settings \u003e General \u003e Login Items. If they do, our toggle would show \"enabled\" but app will not auto-launch.\n\n**Solution: Sync on View Appear**\n```swift\n.onAppear {\n    // Always check actual system state\n    let actuallyEnabled = SMAppService.mainApp.status == .enabled\n    if launchAtLoginSetting != actuallyEnabled {\n        launchAtLoginSetting = actuallyEnabled\n    }\n}\n```\n\n### User Experience Design\n\n**Default State: OFF**\n- Do not auto-enable without user consent\n- First-launch guide can suggest enabling it\n- Respects user autonomy\n\n**Label Text:**\n- Primary: \"Launch at Login\"\n- Help text (optional): \"Start Optimus Clip automatically when you log in\"\n\n**Error Handling:**\n- If registration fails, show toast/alert\n- Revert toggle to previous state\n- Provide \"Open Login Items\" button for manual fix\n\n### Verification in System Settings\n\nAfter enabling, user should see Optimus Clip in:\n- **System Settings \u003e General \u003e Login Items**\n- Under \"Open at Login\" section\n\nProgrammatic verification:\n```swift\nfunc verifyInSystemSettings() {\n    let status = SMAppService.mainApp.status\n    print(\"SMAppService status: \\(status)\")\n    // .enabled = appears in Login Items\n    // .notRegistered = not in Login Items\n}\n```\n\n### Edge Cases \u0026 Gotchas\n\n**1. Multiple Calls Are Safe**\n```swift\n// This is OK - idempotent\ntry SMAppService.mainApp.register()\ntry SMAppService.mainApp.register() // No error, no-op\n```\n\n**2. Unregister When Not Registered**\n```swift\n// Also safe - no error thrown\ntry SMAppService.mainApp.unregister() // Works even if never registered\n```\n\n**3. Sandbox Considerations**\n- SMAppService works in sandboxed apps\n- No special entitlements required\n- Works with App Sandbox enabled\n\n**4. Bundle ID Must Match**\n- SMAppService uses bundle ID to identify app\n- If bundle ID changes, registration lost\n- This is expected behavior\n\n**5. App Store vs Direct Distribution**\n- Works identically in both\n- No special configuration needed\n\n**6. Development Builds**\n- Works with unsigned debug builds\n- Useful for testing during development\n\n### Testing Checklist\n\n- [ ] Enable toggle - verify app appears in Login Items\n- [ ] Disable toggle - verify app removed from Login Items\n- [ ] Quit app - reboot/relogin - app auto-launches\n- [ ] Disable in System Settings - our toggle syncs to OFF\n- [ ] Enable when already enabled - no error, toggle stays ON\n- [ ] Disable when already disabled - no error, toggle stays OFF\n- [ ] Fresh install - default is OFF\n- [ ] Debug build - launch at login still works\n\n### Success Criteria\n\n- [ ] Toggle in General settings tab\n- [ ] Enable/disable via SMAppService works\n- [ ] State syncs with System Settings\n- [ ] Default is OFF (respects user choice)\n- [ ] Clear label and optional help text\n- [ ] No crashes on enable/disable\n- [ ] Works with both debug and release builds\n- [ ] App launches on next login when enabled\n\n### Architectural Connections\n\n- **GeneralTabView (oc-4tw.6)**: Contains the toggle UI\n- **@AppStorage**: Persists user preference (syncs with SMAppService state)\n- **Info.plist**: No special keys needed for SMAppService\n\n### Security \u0026 Privacy\n\n- SMAppService is the official Apple way - safe and documented\n- No system modifications required\n- Automatic cleanup when app uninstalled\n- User can always override in System Settings","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:01.859468-05:00","updated_at":"2025-12-14T20:54:28.330336-05:00","closed_at":"2025-12-14T20:54:28.330336-05:00","dependencies":[{"issue_id":"oc-l9j.5","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-13T09:39:59.031164-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.5","depends_on_id":"oc-tmx","type":"blocks","created_at":"2025-12-13T09:40:24.542807-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.6","title":"Binary/Image Safety Final Check","description":"BACKGROUND \u0026 CONTEXT:\nThe Binary/Image Safety Final Check is a critical guardrail that prevents the app from attempting to process non-text clipboard content. While Optimus Clip is designed for text transformations, users frequently copy images, PDFs, files, and other binary data. Without proper type detection, the app would attempt to:\n1. Read binary data as text (resulting in garbled Unicode)\n2. Send binary data to text-only LLMs (causing API errors or crashes)\n3. Corrupt clipboard contents by writing malformed data back\n4. Waste API tokens and processing time on invalid content\n\nThis check sits at the entry point of the transformation pipeline, before any processing occurs. It's the first line of defense against undefined behavior.\n\nPer the spec (FR-1.3): \"If binary data is detected, the app must abort the transformation to prevent crashes and notify the user via a system beep or UI flash.\"\n\nThe implementation uses macOS's pasteboard type system, which provides rich metadata about clipboard contents without reading the actual data. This allows for fast, safe detection.\n\nREAL-WORLD PROBLEM/USE CASE:\nUser workflow that must be handled gracefully:\n\n1. User copies screenshot from Slack (PNG image)\n2. Clipboard now contains binary image data\n3. User presses Cmd+Shift+V (transformation hotkey) by habit\n4. WITHOUT SAFETY CHECK:\n   - App reads binary data as text → garbled Unicode\n   - Sends to LLM API → 400 Bad Request or timeout\n   - Writes corrupted data back to clipboard\n   - User pastes garbled text or nothing\n   - Confusion and frustration\n\n5. WITH SAFETY CHECK:\n   - App detects clipboard contains .png type (not .string)\n   - Immediately returns without processing\n   - Plays subtle beep via NSSound.beep()\n   - Clipboard remains unchanged with original image\n   - User pastes image successfully\n   - Logs skip event: \"Skipped transformation (binary data: image/png)\"\n\nAnother scenario:\n- User copies PDF from Preview\n- Hotkey triggered\n- App detects .pdf type\n- Skips processing\n- User informed via menu bar icon flash (1-second dim)\n- History logs: \"Binary data detected (application/pdf)\"\n\nWithout this check, the app becomes unreliable and users lose trust.\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. PASTEBOARD TYPE DETECTION:\n```swift\n// ClipboardMonitor.swift\nextension ClipboardMonitor {\n    /// Checks if clipboard contains processable text data\n    func clipboardContainsProcessableText() -\u003e Bool {\n        let pasteboard = NSPasteboard.general\n        \n        // Get all available types\n        guard let types = pasteboard.types else {\n            return false\n        }\n        \n        // Safe types we can process\n        let safeTypes: [NSPasteboard.PasteboardType] = [\n            .string,\n            .rtf,              // Rich text (will strip to plain text)\n            .html,             // HTML (will strip to plain text)\n        ]\n        \n        // Unsafe types that must be skipped\n        let unsafeTypes: [NSPasteboard.PasteboardType] = [\n            .tiff,             // Images\n            .png,\n            .pdf,\n            .fileURL,          // File paths\n            .tabularText,      // Spreadsheet data\n            NSPasteboard.PasteboardType(\"public.file-url\"),\n            NSPasteboard.PasteboardType(\"com.apple.pasteboard.promised-file-url\"),\n        ]\n        \n        // Check for unsafe types first (higher priority)\n        for unsafeType in unsafeTypes {\n            if types.contains(unsafeType) {\n                logSkipEvent(reason: \"Binary data detected\", type: unsafeType.rawValue)\n                return false\n            }\n        }\n        \n        // Check for at least one safe type\n        for safeType in safeTypes {\n            if types.contains(safeType) {\n                return true\n            }\n        }\n        \n        // No recognized text type found\n        logSkipEvent(reason: \"No text data found\", type: types.first?.rawValue ?? \"unknown\")\n        return false\n    }\n    \n    private func logSkipEvent(reason: String, type: String) {\n        print(\"[ClipboardMonitor] \\(reason): \\(type)\")\n        \n        // Log to history database\n        Task { @MainActor in\n            let event = HistoryEntry(\n                timestamp: Date(),\n                transformationName: nil,\n                skipped: true,\n                skipReason: reason,\n                dataType: type,\n                originalText: nil,\n                processedText: nil\n            )\n            historyManager.addEntry(event)\n        }\n    }\n}\n```\n\n2. INTEGRATION WITH TRANSFORMATION PIPELINE:\n```swift\n// TransformationEngine.swift\nfunc executeTransformation(hotkey: KeyboardShortcuts.Name) async {\n    // CRITICAL: Check data type BEFORE any processing\n    guard clipboardMonitor.clipboardContainsProcessableText() else {\n        // Provide user feedback\n        await provideBinaryDataFeedback()\n        return  // Exit early, clipboard unchanged\n    }\n    \n    // Safe to proceed with text transformation\n    guard let originalText = clipboardMonitor.readClipboard() else {\n        return\n    }\n    \n    // ... continue with transformation logic\n}\n```\n\n3. USER FEEDBACK MECHANISMS:\n```swift\n// FeedbackManager.swift\n@MainActor\nfunc provideBinaryDataFeedback() async {\n    // Option 1: System beep (subtle, non-intrusive)\n    NSSound.beep()\n    \n    // Option 2: Menu bar icon flash (visual feedback)\n    await flashMenuBarIcon()\n    \n    // Option 3: Both (recommended)\n    NSSound.beep()\n    await flashMenuBarIcon()\n}\n\nprivate func flashMenuBarIcon() async {\n    // Dim icon for 1 second\n    statusItemManager.setIconOpacity(0.3)\n    try? await Task.sleep(for: .seconds(1))\n    statusItemManager.setIconOpacity(1.0)\n}\n```\n\n4. RTF HANDLING (MIXED CONTENT):\n```swift\n// ClipboardReader.swift\nfunc readClipboard() -\u003e String? {\n    let pasteboard = NSPasteboard.general\n    \n    // Try string first (most common)\n    if let string = pasteboard.string(forType: .string) {\n        return string\n    }\n    \n    // Try RTF, strip to plain text\n    if let rtfData = pasteboard.data(forType: .rtf) {\n        let attributedString = NSAttributedString(rtf: rtfData, documentAttributes: nil)\n        return attributedString?.string  // Strips formatting, keeps text\n    }\n    \n    // Try HTML, strip to plain text\n    if let htmlData = pasteboard.data(forType: .html) {\n        let attributedString = NSAttributedString(html: htmlData, documentAttributes: nil)\n        return attributedString?.string\n    }\n    \n    return nil\n}\n```\n\n5. TESTING HELPER:\n```swift\n// ClipboardMonitorTests.swift\n@Test func testBinaryDataDetection() async {\n    let monitor = ClipboardMonitor()\n    let pasteboard = NSPasteboard.general\n    \n    // Test image data\n    pasteboard.clearContents()\n    pasteboard.setData(NSImage(systemSymbolName: \"star\", accessibilityDescription: nil)!.tiffRepresentation, forType: .tiff)\n    #expect(!monitor.clipboardContainsProcessableText())\n    \n    // Test PDF\n    pasteboard.clearContents()\n    pasteboard.setData(Data(), forType: .pdf)\n    #expect(!monitor.clipboardContainsProcessableText())\n    \n    // Test string (safe)\n    pasteboard.clearContents()\n    pasteboard.setString(\"Hello\", forType: .string)\n    #expect(monitor.clipboardContainsProcessableText())\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- Called at entry point of TransformationEngine.executeTransformation()\n- Integrates with ClipboardMonitor (existing Phase 2 component)\n- Uses HistoryManager to log skip events (Phase 6 SwiftData integration)\n- Triggers FeedbackManager for user notification\n- Works with StatusItemManager for icon flash animation\n- Preceded by: Clipboard monitoring (Phase 2)\n- Followed by: Text reading and transformation (Phase 4/5)\n- Feeds into: History analytics (tracks binary data frequency)\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. RTF WITH EMBEDDED IMAGES:\n   - RTF can contain both text and images\n   - Solution: Strip to plain text, ignore embedded resources\n   - Use NSAttributedString.string property (removes formatting)\n\n2. MULTIPLE CLIPBOARD TYPES:\n   - Clipboard often has multiple representations (e.g., .string + .rtf + .html)\n   - Solution: Check for unsafe types FIRST (higher priority)\n   - If image AND text present, treat as binary (conservative approach)\n   - Example: Copying from Word might include text + embedded objects\n\n3. EMPTY CLIPBOARD:\n   - types array can be nil or empty\n   - Solution: Early return with false (no processable content)\n   - Don't trigger feedback (no user action to respond to)\n\n4. PROMISED CLIPBOARD DATA:\n   - Some apps use \"promised\" types that aren't immediately available\n   - Solution: Check types synchronously, don't wait for content\n   - Existing 80ms grace delay (Phase 2) handles promise resolution\n\n5. FILE PATHS AS TEXT:\n   - Copying file in Finder adds .fileURL type\n   - User might expect path string, but clipboard has binary file reference\n   - Solution: Detect .fileURL type, skip transformation\n   - Future enhancement: Convert file URL to path string if text type also present\n\n6. CUSTOM PASTEBOARD TYPES:\n   - Some apps use custom UTI types (e.g., \"com.apple.mail.PasteboardTypeMessageTransfer\")\n   - Solution: Default to safe - if no recognized text type, skip\n   - Log custom types for debugging\n\n7. UNICODE EDGE CASES:\n   - Binary data might be valid UTF-8 by accident\n   - Solution: Type checking prevents this (don't read content first)\n   - Never attempt to decode binary as text\n\n8. PERFORMANCE:\n   - Type checking is fast (metadata only, no content read)\n   - No network calls, no file I/O\n   - Should complete in \u003c 1ms\n\nTESTING REQUIREMENTS:\n- Copy PNG image, trigger hotkey → beep + no transformation + clipboard unchanged\n- Copy JPEG image → same behavior\n- Copy PDF document → same behavior\n- Copy file from Finder → same behavior\n- Copy RTF with embedded images → strips to plain text successfully\n- Copy HTML content → strips to plain text successfully\n- Copy plain text → processes normally\n- Empty clipboard → no feedback, graceful skip\n- Rapid type changes (text → image → text) → correct detection each time\n- History logs skip events with correct data type\n- Menu bar icon flash animation triggers (if enabled)\n- System beep plays (if enabled)\n- No crashes or errors with any clipboard content type\n- Performance: Type detection \u003c 1ms\n- Memory: No leaks from repeated type checks\n\nSUCCESS CRITERIA:\n- clipboardContainsProcessableText() method implemented\n- All unsafe types detected and rejected\n- Safe types (string, rtf, html) accepted\n- User feedback mechanism working (beep + icon flash)\n- History logs skip events with data type\n- No crashes with binary clipboard data\n- No garbled text from attempted binary processing\n- No wasted LLM API calls on binary data\n- RTF correctly strips to plain text\n- HTML correctly strips to plain text\n- Performance \u003c 1ms for type detection\n- All edge cases handled gracefully\n- Tests pass for all data types\n- Documentation updated with supported types\n\nCONFIGURATION OPTIONS:\n- Feedback method: beep only, icon flash only, or both (default: both)\n- Skip logging: enable/disable history logging for skip events (default: enabled)\n- Conservative mode: reject mixed-type clipboard (default: false)\n- Future: Allow binary-to-text conversion (image → OCR, PDF → text extraction)\n\nSECURITY CONSIDERATIONS:\n- Type checking prevents malformed binary data from crashing app\n- No content read until type confirmed safe (defense in depth)\n- Prevents potential exploits via crafted binary payloads\n- No execution of clipboard content (passive detection only)\n- History logs sanitized data type names (no raw binary)\n\nIMPLEMENTATION ORDER:\n1. Add clipboardContainsProcessableText() to ClipboardMonitor\n2. Define safe and unsafe type arrays\n3. Implement type detection logic\n4. Add skip event logging to HistoryManager\n5. Implement user feedback methods (beep + icon flash)\n6. Integrate check at TransformationEngine entry point\n7. Add RTF/HTML stripping to ClipboardReader\n8. Write comprehensive tests for all data types\n9. Test with real-world clipboard content\n10. Document supported types in UI (help text)\n\nCODE ORGANIZATION:\nSources/OptimusClip/Services/ClipboardMonitor.swift (add method)\nSources/OptimusClip/Services/FeedbackManager.swift (new file)\nSources/OptimusClip/Services/ClipboardReader.swift (enhance)\nTests/OptimusClipTests/ClipboardSafetyTests.swift (new file)\n\nPRIORITY: P2 (Required for production stability)\n\nESTIMATED TIME: 120 minutes\n- Type detection logic: 30 min\n- User feedback: 20 min\n- RTF/HTML handling: 25 min\n- History logging integration: 15 min\n- Testing: 30 min\n\nDEPENDENCIES:\n- Phase 2: ClipboardMonitor existing\n- Phase 6: HistoryManager (SwiftData) for logging\n- Phase 1: StatusItemManager for icon animation\n\nACCEPTANCE:\n- No crashes with any clipboard content type\n- Binary data gracefully skipped\n- User informed via subtle feedback\n- All tests pass\n- Production-ready stability","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:02.435544-05:00","updated_at":"2025-12-14T20:48:28.968732-05:00","closed_at":"2025-12-14T20:48:28.968732-05:00","dependencies":[{"issue_id":"oc-l9j.6","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-13T09:39:59.56485-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.6","depends_on_id":"oc-tmx","type":"blocks","created_at":"2025-12-13T09:40:31.895594-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.7","title":"Error Recovery \u0026 Resilience","description":"## Task: Error Recovery \u0026 Resilience\n\n### Background \u0026 Strategic Importance\nThis task is CRITICAL for production quality. Users will encounter failures - it's not a matter of \"if\" but \"when.\" The difference between a frustrating app and a reliable tool is how it handles these inevitable failures.\n\n**Real-world failure scenarios users WILL experience:**\n1. Network drops mid-LLM-request (WiFi hiccup, sleep/wake)\n2. API rate limits (heavy usage, shared API key)\n3. Invalid/expired API keys (rotated, typo during setup)\n4. LLM service outages (OpenAI has ~99.9% uptime = ~8 hours downtime/year)\n5. Timeout on large inputs (10KB text to slow model)\n6. Clipboard race conditions (rapid copy-paste)\n7. Accessibility permission revoked (system update, user accident)\n\n### Core Principle: Never Lose User Data\n\n**The Golden Rule:** If transformation fails, the clipboard MUST contain the original content. Never leave the user with empty or corrupted clipboard.\n\n**Implementation Pattern:**\n```swift\nfunc performTransformation() async {\n    // 1. Capture original BEFORE any processing\n    let originalContent = ClipboardManager.shared.readText()\n    guard let original = originalContent else { return }\n\n    // 2. Attempt transformation\n    do {\n        let result = try await transformationEngine.transform(original)\n\n        // 3. Write result (with self-write marker)\n        ClipboardManager.shared.write(result)\n\n        // 4. Simulate paste\n        PasteSimulator.shared.paste()\n\n    } catch {\n        // 5. CRITICAL: Restore original on ANY failure\n        ClipboardManager.shared.write(original)\n\n        // 6. Notify user (don't paste - clipboard unchanged)\n        NotificationManager.shared.showError(error)\n    }\n}\n```\n\n### Error Categories \u0026 Handling Strategies\n\n#### Category 1: Network Errors\n**Symptoms:** URLError.notConnectedToInternet, URLError.timedOut, URLError.networkConnectionLost\n\n**User-Facing Message:** \"Unable to connect. Check your internet connection and try again.\"\n\n**Recovery Strategy:**\n- Preserve clipboard (don't modify)\n- Flash menu bar icon red briefly\n- Play system alert sound (optional, respect user preference)\n- NO automatic retry (user controls when to retry via hotkey)\n\n#### Category 2: Authentication Errors\n**Symptoms:** HTTP 401, 403, \"invalid_api_key\" in response\n\n**User-Facing Message:** \"Invalid API key for [Provider]. Please check your API key in Settings.\"\n\n**Recovery Strategy:**\n- Preserve clipboard\n- Show notification with \"Open Settings\" action\n- Disable that provider's transformations until key updated\n- Log error (without exposing key) for debugging\n\n#### Category 3: Rate Limits\n**Symptoms:** HTTP 429, \"rate_limit_exceeded\"\n\n**User-Facing Message:** \"Rate limit reached. Please wait a moment and try again.\"\n\n**Recovery Strategy:**\n- Preserve clipboard\n- Parse `Retry-After` header if present\n- Show countdown in menu bar (optional enhancement)\n- No automatic retry (respects user control)\n\n#### Category 4: Timeout\n**Symptoms:** Task.sleep exceeded, URLSession timeout\n\n**User-Facing Message:** \"Request timed out. Try shorter text or increase timeout in Settings.\"\n\n**Recovery Strategy:**\n- Cancel in-flight request immediately\n- Preserve clipboard\n- Offer suggestions (shorter text, different model, local transformation)\n\n#### Category 5: Service Errors\n**Symptoms:** HTTP 500, 502, 503, 504\n\n**User-Facing Message:** \"[Provider] service temporarily unavailable. Try again shortly.\"\n\n**Recovery Strategy:**\n- Preserve clipboard\n- Don't spam retries (service is overloaded)\n- Suggest trying different provider if configured\n\n### Visual Feedback System\n\n**Menu Bar Icon States:**\n- **Processing:** Pulse animation (`.symbolEffect(.pulse)`)\n- **Error:** Brief red tint + return to normal\n- **Success:** Brief green flash (optional)\n\n**Notification Strategy:**\n- Use `UNUserNotificationCenter` for non-intrusive alerts\n- Notifications auto-dismiss after 5 seconds\n- Include actionable buttons (\"Open Settings\", \"Try Again\")\n- Respect system notification settings\n\n### Graceful Degradation\n\nWhen LLM providers fail, offer fallback options:\n\n1. **Provider Fallback:** If OpenAI fails, try Anthropic (if configured)\n2. **Local Fallback:** Offer algorithmic transformation as alternative\n3. **Pass-through:** If all fails, at least paste original content\n\n**Configuration:**\n```swift\nstruct ResilienceConfig {\n    var enableProviderFallback: Bool = false  // User preference\n    var fallbackOrder: [LLMProvider] = []     // User-configured priority\n    var enableLocalFallback: Bool = true      // Algorithmic as last resort\n}\n```\n\n### Testing Requirements\n\n**Simulate each failure mode:**\n- [ ] Disable WiFi during transformation → verify clipboard preserved\n- [ ] Use invalid API key → verify clear error message\n- [ ] Make rapid requests to trigger rate limit → verify graceful handling\n- [ ] Set 1-second timeout with large text → verify timeout handling\n- [ ] Kill LLM provider connection mid-stream → verify no partial data\n\n**Chaos testing:**\n- Run app for 24+ hours with intermittent network\n- Verify no memory leaks from error handling\n- Verify no zombie tasks from cancelled requests\n\n### Architectural Integration\n\n```\n┌─────────────────────────────────────────────────┐\n│           TransformationFlowCoordinator         │\n│  ┌─────────────────────────────────────────┐   │\n│  │     1. Capture Original Clipboard       │   │\n│  └──────────────────┬──────────────────────┘   │\n│                     ▼                           │\n│  ┌─────────────────────────────────────────┐   │\n│  │     2. Execute Transformation           │   │\n│  │        (with timeout wrapper)           │   │\n│  └──────────────────┬──────────────────────┘   │\n│                     │                           │\n│         ┌──────────┴──────────┐                │\n│         ▼                     ▼                │\n│    ┌─────────┐          ┌──────────┐          │\n│    │ Success │          │ Failure  │          │\n│    └────┬────┘          └────┬─────┘          │\n│         ▼                    ▼                 │\n│  ┌──────────────┐   ┌───────────────────┐     │\n│  │ Write Result │   │ Restore Original  │     │\n│  │ + Paste      │   │ + Show Error      │     │\n│  └──────────────┘   └───────────────────┘     │\n└─────────────────────────────────────────────────┘\n```\n\n### Success Criteria\n- [ ] Network errors preserve clipboard and show clear message\n- [ ] Auth errors guide user to fix API key\n- [ ] Rate limits handled gracefully without spam\n- [ ] Timeouts cancel cleanly without hanging\n- [ ] Service errors suggest alternatives\n- [ ] No data loss under any failure scenario\n- [ ] App remains responsive during error recovery\n- [ ] Error logging captures enough for debugging (without secrets)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:06:02.95926-05:00","updated_at":"2025-12-14T20:42:31.174918-05:00","closed_at":"2025-12-14T20:42:31.174918-05:00","dependencies":[{"issue_id":"oc-l9j.7","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-12T22:06:02.95979-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.7","depends_on_id":"oc-tmx","type":"blocks","created_at":"2025-12-13T09:40:32.683332-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.8","title":"Security Audit Checklist","description":"## Task: Security Audit Checklist\n\n### Background \u0026 Purpose\nBefore shipping the MVP, we MUST verify all security requirements are met. This checklist serves as the final gate before public release. Security issues discovered post-release damage user trust irreparably.\n\n**Why This Matters:**\n- API keys are worth money (OpenAI charges per token)\n- Clipboard often contains sensitive data (passwords, tokens, PII)\n- Users trust us with their data - we must honor that trust\n- One breach = reputation destroyed\n\n### The Comprehensive Security Checklist\n\n#### Section 1: API Key Protection (NFR-2.1)\n\n**1.1 Storage Location Verification**\n- [ ] OpenAI API key stored ONLY in Keychain (NOT UserDefaults)\n- [ ] Anthropic API key stored ONLY in Keychain\n- [ ] OpenRouter API key stored ONLY in Keychain\n- [ ] AWS credentials stored ONLY in Keychain (or use ~/.aws/credentials)\n- [ ] Ollama has no keys (local only) - verify no accidental storage\n\n**Verification Method:**\n```bash\n# Check UserDefaults for leaked keys\ndefaults read com.yourname.optimusclip | grep -i \"key\\|api\\|secret\\|token\"\n# Should return NOTHING\n\n# Check Keychain has the keys\nsecurity find-generic-password -s \"com.optimusclip.openai\" -w\n# Should return the key (or error if not set)\n```\n\n**1.2 Key Handling in Code**\n- [ ] Keys never logged to console (search codebase for `print.*key` patterns)\n- [ ] Keys never included in error messages\n- [ ] Keys cleared from memory after use (for extra paranoia)\n- [ ] No hardcoded keys in source code\n- [ ] No keys in Info.plist or config files\n\n**Verification Method:**\n```bash\n# Search for potential key leaks\ngrep -r \"sk-\" Sources/  # OpenAI key prefix\ngrep -r \"print.*[Kk]ey\" Sources/\ngrep -r \"description.*[Kk]ey\" Sources/  # String interpolation\n```\n\n**1.3 Key Display in UI**\n- [ ] API keys masked in Settings UI (show only last 4 chars)\n- [ ] Copy button for keys disabled or warns user\n- [ ] Keys not visible in screen recordings/screenshots\n\n#### Section 2: Data Privacy (NFR-2.2)\n\n**2.1 No External Telemetry**\n- [ ] No analytics SDKs included (Mixpanel, Amplitude, etc.)\n- [ ] No crash reporting that sends clipboard content\n- [ ] No network calls except to user-configured LLM providers\n- [ ] Verify with network monitor (Charles Proxy, Wireshark)\n\n**Verification Method:**\n```bash\n# Check for analytics frameworks\ngrep -r \"Analytics\\|Tracking\\|Telemetry\" Package.swift\n# Should return NOTHING\n\n# Monitor network during usage\n# Use Charles Proxy or `nettop -p $(pgrep OptimusClip)`\n```\n\n**2.2 Local-Only History**\n- [ ] History stored in local SwiftData only\n- [ ] No iCloud sync enabled for history\n- [ ] History not backed up to iCloud (use .excludedFromBackup if needed)\n- [ ] History cleared on user request\n\n**2.3 Clipboard Content Handling**\n- [ ] Clipboard content never logged\n- [ ] Transformed content not stored longer than necessary\n- [ ] Original content not retained after transformation complete\n\n#### Section 3: Binary/Image Safety\n\n**3.1 Content Type Detection**\n- [ ] Images detected and rejected before LLM call\n- [ ] Files/folders detected and rejected\n- [ ] Rich text handled correctly (strip formatting or preserve)\n- [ ] PDFs detected and rejected (or handled appropriately)\n\n**Verification Method:**\n1. Copy an image to clipboard\n2. Press transformation hotkey\n3. Verify: No crash, no API call, clear user message\n\n**3.2 Large Content Protection**\n- [ ] Maximum content size enforced (e.g., 100KB)\n- [ ] User warned before sending large content to LLM\n- [ ] Timeout prevents indefinite hangs\n\n#### Section 4: Accessibility \u0026 Permissions\n\n**4.1 Permission Justification**\n- [ ] Only request Accessibility permission (required for paste simulation)\n- [ ] Clear explanation of why permission is needed\n- [ ] App functions (degraded) without permission\n- [ ] No unnecessary permissions requested\n\n**4.2 Permission Scope**\n- [ ] Accessibility permission used ONLY for paste simulation\n- [ ] Not used to monitor other app activity\n- [ ] Not used to log keystrokes\n\n#### Section 5: Code Signing \u0026 Distribution\n\n**5.1 Pre-Release Verification**\n- [ ] App signed with Developer ID (not ad-hoc)\n- [ ] Notarized by Apple\n- [ ] Hardened runtime enabled\n- [ ] No known vulnerable dependencies\n\n**Verification Method:**\n```bash\ncodesign --verify --deep --strict OptimusClip.app\nspctl -a -t exec -vv OptimusClip.app\n```\n\n#### Section 6: Secure Coding Practices\n\n**6.1 Input Validation**\n- [ ] System prompts sanitized (no injection attacks)\n- [ ] Clipboard content length validated\n- [ ] URL inputs validated (for Ollama endpoint)\n\n**6.2 Error Handling**\n- [ ] Errors don't expose internal paths\n- [ ] Errors don't expose API keys\n- [ ] Stack traces not shown to users\n\n**6.3 Memory Safety**\n- [ ] No force unwraps on user input\n- [ ] Proper cleanup of sensitive data\n- [ ] No buffer overflows (Swift helps here)\n\n### Audit Process\n\n**Step 1: Automated Scan**\nRun SwiftLint with security rules enabled:\n```bash\nswiftlint analyze --config .swiftlint-security.yml\n```\n\n**Step 2: Manual Code Review**\nReview all files in:\n- `Sources/OptimusClip/Services/Keychain/`\n- `Sources/OptimusClip/Services/LLM/`\n- `Sources/OptimusClip/Services/Clipboard/`\n\n**Step 3: Runtime Verification**\n- Monitor network traffic during normal usage\n- Check UserDefaults after using all features\n- Verify Keychain entries are correct\n\n**Step 4: Sign-Off**\n- [ ] All checklist items verified\n- [ ] No critical or high-severity issues\n- [ ] Date of audit: ____________\n- [ ] Auditor: ____________\n\n### Success Criteria\n- 100% of checklist items verified\n- Zero API keys in UserDefaults\n- Zero network calls to unexpected hosts\n- Zero clipboard content in logs\n- All permissions justified and minimal","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:06:03.519538-05:00","updated_at":"2025-12-14T22:22:32.364801-05:00","closed_at":"2025-12-14T22:22:32.364801-05:00","dependencies":[{"issue_id":"oc-l9j.8","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-12T22:06:03.520003-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.8","depends_on_id":"oc-l9j.3","type":"blocks","created_at":"2025-12-12T23:53:54.478041-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.8","depends_on_id":"oc-l9j.6","type":"blocks","created_at":"2025-12-12T23:53:54.700252-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.8","depends_on_id":"oc-l9j.7","type":"blocks","created_at":"2025-12-12T23:53:54.985656-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-l9j.9","title":"Performance Verification","description":"BACKGROUND \u0026 CONTEXT:\nPerformance Verification is the quality gate that ensures Optimus Clip meets all Non-Functional Requirements (NFRs) specified in the PRD before declaring MVP complete. This is not about adding features—it's about measuring, validating, and documenting that existing features meet performance standards.\n\nThe PRD (Section 5.1) specifies hard performance requirements:\n- NFR-1.1: Algorithmic transformations must complete in \u003c 100ms\n- NFR-1.2: LLM call timeout must be configurable (default 30 seconds)\n- NFR-1.3: Application memory footprint should remain \u003c 200MB\n- Implied: UI must remain responsive during all operations (no main thread blocking)\n\nThis task uses Xcode Instruments and profiling tools to scientifically measure actual performance against these targets. It's the difference between \"it feels fast\" and \"it IS fast\" with data to prove it.\n\nPerformance verification happens after all features are built but before release. It catches:\n- Memory leaks from improper cleanup\n- Accidental main thread blocking from async/await mistakes\n- Algorithmic inefficiencies in transformation logic\n- Resource exhaustion under stress conditions\n- Battery drain from excessive polling\n\nThe output is both a pass/fail checklist AND baseline measurements for future regression testing.\n\nREAL-WORLD PROBLEM/USE CASE:\nScenario 1: User in active coding session\n1. User has Xcode, VS Code, Chrome (20 tabs), Slack, Terminal open\n2. System memory already at 12GB/16GB\n3. User launches Optimus Clip\n4. WITHOUT VERIFICATION:\n   - App allocates 300MB due to memory leak in LLM response caching\n   - System starts swapping to disk\n   - All apps slow down\n   - User force quits Optimus Clip\n   - App gets reputation as \"memory hog\"\n\n5. WITH VERIFICATION:\n   - Measured memory \u003c 200MB even after 100 transformations\n   - Runs alongside other apps smoothly\n   - User keeps app running 24/7\n\nScenario 2: User copying large code block\n1. User copies 5000-line file from IDE\n2. Presses Cmd+Shift+V (algorithmic transformation)\n3. WITHOUT VERIFICATION:\n   - Transformation takes 2 seconds on main thread\n   - UI freezes, menu bar unresponsive\n   - User thinks app crashed\n   - Force quit\n\n4. WITH VERIFICATION:\n   - Measured transformation time: 45ms\n   - UI stays responsive\n   - Instant feedback\n   - Smooth experience\n\nScenario 3: Slow network + LLM transformation\n1. User on coffee shop WiFi (high latency)\n2. Triggers LLM transformation\n3. WITHOUT TIMEOUT:\n   - Request hangs for 5 minutes\n   - UI shows \"Processing...\" forever\n   - User force quits app\n\n4. WITH VERIFIED TIMEOUT:\n   - 30-second timeout fires\n   - Error message: \"Transformation timed out. Check network connection.\"\n   - Clipboard unchanged\n   - User retries or switches to algorithmic transformation\n\nThis verification prevents all these failure modes.\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. XCODE INSTRUMENTS SETUP:\n```bash\n# Launch Instruments from command line\ninstruments -t \"Time Profiler\" -D ~/Desktop/optimus_profile.trace -l 60000 ./OptimusClip.app\n\n# Memory profiling\ninstruments -t \"Allocations\" -D ~/Desktop/optimus_memory.trace -l 60000 ./OptimusClip.app\n\n# Leaks detection\ninstruments -t \"Leaks\" -D ~/Desktop/optimus_leaks.trace -l 60000 ./OptimusClip.app\n```\n\n2. ALGORITHMIC TRANSFORMATION BENCHMARKING:\n```swift\n// PerformanceBenchmarks.swift\nimport Testing\nimport Foundation\n\n@Suite(\"Performance Benchmarks\")\nstruct TransformationPerformanceTests {\n    \n    @Test(\"Uppercase transformation \u003c 100ms\", .timeLimit(.minutes(1)))\n    func testUppercasePerformance() async throws {\n        let engine = TransformationEngine()\n        let input = String(repeating: \"hello world\\n\", count: 1000)  // ~12KB\n        \n        let start = CFAbsoluteTimeGetCurrent()\n        let _ = try await engine.applyAlgorithmic(.uppercase, to: input)\n        let duration = (CFAbsoluteTimeGetCurrent() - start) * 1000  // Convert to ms\n        \n        print(\"Uppercase transformation: \\(duration)ms\")\n        #expect(duration \u003c 100.0, \"Exceeded 100ms limit: \\(duration)ms\")\n    }\n    \n    @Test(\"Trim transformation \u003c 100ms\")\n    func testTrimPerformance() async throws {\n        let engine = TransformationEngine()\n        let input = String(repeating: \"  hello world  \\n\", count: 1000)\n        \n        let start = CFAbsoluteTimeGetCurrent()\n        let _ = try await engine.applyAlgorithmic(.trim, to: input)\n        let duration = (CFAbsoluteTimeGetCurrent() - start) * 1000\n        \n        print(\"Trim transformation: \\(duration)ms\")\n        #expect(duration \u003c 100.0)\n    }\n    \n    @Test(\"Unwrap transformation \u003c 100ms\")\n    func testUnwrapPerformance() async throws {\n        let engine = TransformationEngine()\n        let input = \"\"\"\n        This is a long line that wraps at 80\n        characters and needs to be joined into\n        a single paragraph for better readability.\n        \"\"\"\n        let repeated = String(repeating: input + \"\\n\", count: 100)\n        \n        let start = CFAbsoluteTimeGetCurrent()\n        let _ = try await engine.applyAlgorithmic(.unwrap, to: repeated)\n        let duration = (CFAbsoluteTimeGetCurrent() - start) * 1000\n        \n        print(\"Unwrap transformation: \\(duration)ms\")\n        #expect(duration \u003c 100.0)\n    }\n    \n    @Test(\"Large payload stress test\")\n    func testLargePayloadPerformance() async throws {\n        let engine = TransformationEngine()\n        let input = String(repeating: \"a\", count: 100_000)  // 100KB\n        \n        let start = CFAbsoluteTimeGetCurrent()\n        let _ = try await engine.applyAlgorithmic(.uppercase, to: input)\n        let duration = (CFAbsoluteTimeGetCurrent() - start) * 1000\n        \n        print(\"Large payload (100KB): \\(duration)ms\")\n        // Allow more time for large payloads, but still reasonable\n        #expect(duration \u003c 500.0, \"Large payload too slow: \\(duration)ms\")\n    }\n}\n```\n\n3. MEMORY FOOTPRINT MEASUREMENT:\n```swift\n// MemoryMonitor.swift\nimport Foundation\n\nclass MemoryMonitor {\n    /// Get current memory usage in MB\n    static func getCurrentMemoryUsage() -\u003e Double {\n        var info = mach_task_basic_info()\n        var count = mach_msg_type_number_t(MemoryLayout\u003cmach_task_basic_info\u003e.size) / 4\n        \n        let result = withUnsafeMutablePointer(to: \u0026info) {\n            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {\n                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, \u0026count)\n            }\n        }\n        \n        guard result == KERN_SUCCESS else { return 0 }\n        return Double(info.resident_size) / 1024.0 / 1024.0  // Convert to MB\n    }\n    \n    /// Stress test memory under load\n    static func runMemoryStressTest() async {\n        print(\"=== Memory Stress Test ===\")\n        let baseline = getCurrentMemoryUsage()\n        print(\"Baseline: \\(baseline)MB\")\n        \n        // Simulate 100 transformations\n        let engine = TransformationEngine()\n        for i in 1...100 {\n            let input = String(repeating: \"test data \\(i)\\n\", count: 100)\n            _ = try? await engine.applyAlgorithmic(.uppercase, to: input)\n            \n            if i % 10 == 0 {\n                let current = getCurrentMemoryUsage()\n                print(\"After \\(i) transformations: \\(current)MB\")\n            }\n        }\n        \n        let final = getCurrentMemoryUsage()\n        print(\"Final: \\(final)MB\")\n        print(\"Growth: \\(final - baseline)MB\")\n        \n        assert(final \u003c 200.0, \"Memory exceeded 200MB limit: \\(final)MB\")\n    }\n}\n```\n\n4. LLM TIMEOUT VERIFICATION:\n```swift\n// TimeoutTests.swift\n@Test(\"LLM timeout configuration\")\nfunc testLLMTimeoutSetting() async throws {\n    @AppStorage(\"llm_timeout_seconds\") var timeoutSeconds = 30\n    \n    #expect(timeoutSeconds == 30, \"Default timeout should be 30 seconds\")\n    \n    // Test configuration change\n    timeoutSeconds = 60\n    #expect(timeoutSeconds == 60)\n    \n    // Reset to default\n    timeoutSeconds = 30\n}\n\n@Test(\"LLM timeout enforcement\")\nfunc testTimeoutFiresCorrectly() async throws {\n    let engine = TransformationEngine()\n    engine.timeoutSeconds = 2  // Short timeout for testing\n    \n    // Mock slow LLM provider\n    let slowProvider = MockSlowLLMProvider(delaySeconds: 5)\n    \n    let start = Date()\n    do {\n        _ = try await engine.transformWithLLM(\n            text: \"test\",\n            provider: slowProvider,\n            model: \"test-model\",\n            systemPrompt: \"test\"\n        )\n        Issue.record(\"Should have timed out\")\n    } catch TransformationError.timeout {\n        let elapsed = Date().timeIntervalSince(start)\n        print(\"Timeout fired after \\(elapsed)s\")\n        #expect(elapsed \u003e= 2.0 \u0026\u0026 elapsed \u003c 3.0, \"Timeout should fire around 2s\")\n    } catch {\n        Issue.record(\"Wrong error type: \\(error)\")\n    }\n}\n```\n\n5. UI RESPONSIVENESS CHECK:\n```swift\n// MainThreadMonitor.swift\nclass MainThreadMonitor {\n    private static var violations: [String] = []\n    \n    /// Assert operation runs on background thread\n    static func assertBackgroundThread(operation: String) {\n        if Thread.isMainThread {\n            let violation = \"VIOLATION: \\(operation) running on main thread!\"\n            violations.append(violation)\n            print(\"⚠️ \\(violation)\")\n        }\n    }\n    \n    /// Report all violations\n    static func reportViolations() {\n        if violations.isEmpty {\n            print(\"✅ No main thread violations detected\")\n        } else {\n            print(\"❌ Main thread violations:\")\n            violations.forEach { print(\"  - \\($0)\") }\n        }\n    }\n}\n\n// Usage in transformation code\nfunc performLLMTransformation() async {\n    MainThreadMonitor.assertBackgroundThread(operation: \"LLM API call\")\n    // ... API call\n}\n```\n\n6. COMPREHENSIVE BENCHMARK SCRIPT:\n```bash\n#!/usr/bin/env bash\n# Scripts/run_performance_verification.sh\n\nset -euo pipefail\n\necho \"=== Optimus Clip Performance Verification ===\"\necho \"Running comprehensive performance tests...\"\n\n# 1. Build release configuration\necho \"\\n[1/5] Building release configuration...\"\nswift build -c release\n\n# 2. Run performance tests\necho \"\\n[2/5] Running benchmark suite...\"\nswift test --filter \"Performance\" -c release\n\n# 3. Launch with Instruments for memory profiling\necho \"\\n[3/5] Profiling memory usage (60 seconds)...\"\ninstruments -t \"Allocations\" -D ./performance_results/memory.trace -l 60000 ./.build/release/OptimusClip \u0026\nINSTRUMENTS_PID=$!\nsleep 5  # Let app start\n\n# Simulate usage\necho \"Simulating clipboard activity...\"\nfor i in {1..50}; do\n    echo \"Test $i\" | pbcopy\n    sleep 0.5\ndone\n\nwait $INSTRUMENTS_PID\n\n# 4. Check for memory leaks\necho \"\\n[4/5] Checking for memory leaks...\"\ninstruments -t \"Leaks\" -D ./performance_results/leaks.trace -l 30000 ./.build/release/OptimusClip\n\n# 5. Generate report\necho \"\\n[5/5] Generating performance report...\"\nswift run PerformanceReporter ./performance_results/\n\necho \"\\n✅ Performance verification complete!\"\necho \"Results saved to ./performance_results/\"\n```\n\nARCHITECTURAL CONNECTIONS:\n- Tests TransformationEngine (Phase 4) performance\n- Validates LLMClient (Phase 5) timeout handling\n- Measures ClipboardMonitor (Phase 2) polling overhead\n- Checks SwiftData (Phase 6) database performance\n- Verifies MenuBarExtra UI responsiveness\n- Integrates with CI/CD for regression detection (Phase 7)\n- Feeds into release notes with actual measurements\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. RELEASE vs DEBUG BUILDS:\n   - DEBUG builds 10-50x slower due to no optimization\n   - ALWAYS benchmark release builds: `swift build -c release`\n   - Debug builds may pass memory checks but release builds fail (vice versa)\n\n2. COLD START vs WARM CYCLES:\n   - First transformation may be slower (cache warming)\n   - Measure both cold start AND average of 10 warm cycles\n   - Report both numbers\n\n3. BACKGROUND PROCESSES:\n   - Spotlight indexing can skew results\n   - Close all apps during benchmarking\n   - Run multiple times, take median result\n\n4. MEMORY MEASUREMENT TIMING:\n   - Memory usage spikes during transformation, then drops\n   - Measure sustained memory (5 minutes after activity)\n   - Check peak memory vs steady-state memory\n\n5. NETWORK VARIABILITY:\n   - LLM timeout tests affected by actual network conditions\n   - Use mock providers for deterministic timeout testing\n   - Separate real network integration tests\n\n6. XCODE INSTRUMENTS OVERHEAD:\n   - Instruments itself adds memory/CPU overhead\n   - Baseline measurements without Instruments first\n   - Instruments data is relative, not absolute\n\n7. SWIFT TESTING FRAMEWORK TIMING:\n   - Test framework adds overhead to measurements\n   - Use CFAbsoluteTimeGetCurrent() for precise timing\n   - Warm up JIT before measuring (run once, then measure)\n\n8. ASYNC/AWAIT CONTEXT SWITCHING:\n   - Context switches add 1-5ms overhead\n   - Acceptable for network calls, not for pure computation\n   - Keep algorithmic transforms synchronous where possible\n\nTESTING REQUIREMENTS:\n- Algorithmic transformations: All \u003c 100ms (test each type)\n- Large payload (100KB): \u003c 500ms\n- Memory baseline: Record at app launch\n- Memory sustained: \u003c 200MB after 100 transformations\n- Memory peak: \u003c 300MB during active transformation\n- LLM timeout: Fires within ±1s of configured value\n- UI responsiveness: No operations on main thread except UI updates\n- Clipboard polling: \u003c 5% CPU usage\n- SwiftData writes: \u003c 50ms per entry\n- Cold start time: \u003c 2 seconds to menu bar appearance\n- Settings window: Opens in \u003c 500ms\n- No memory leaks: Instruments \"Leaks\" reports zero\n- Battery impact: Minimal (\u003c 1% per hour background)\n\nSUCCESS CRITERIA:\n- All NFR benchmarks pass with margin (not on the edge)\n- Baseline measurements documented for future regression testing\n- No memory leaks detected\n- No main thread violations\n- Performance report generated with actual numbers\n- CI/CD integration ready (benchmarks run on every PR)\n- Results committed to repo: performance_results/latest.json\n\nBENCHMARK REPORT FORMAT:\n```json\n{\n  \"version\": \"1.0.0\",\n  \"build\": \"42\",\n  \"date\": \"2025-12-12T10:30:00Z\",\n  \"system\": {\n    \"os\": \"macOS 15.1\",\n    \"machine\": \"Mac15,12\",\n    \"memory_gb\": 16\n  },\n  \"results\": {\n    \"algorithmic\": {\n      \"uppercase_ms\": 12.3,\n      \"lowercase_ms\": 11.8,\n      \"trim_ms\": 8.4,\n      \"unwrap_ms\": 45.2,\n      \"large_payload_ms\": 234.1\n    },\n    \"memory\": {\n      \"baseline_mb\": 42.3,\n      \"sustained_mb\": 87.6,\n      \"peak_mb\": 156.2,\n      \"growth_after_100_transforms_mb\": 3.2\n    },\n    \"timeout\": {\n      \"configured_seconds\": 30,\n      \"actual_fire_seconds\": 30.4\n    },\n    \"leaks\": {\n      \"detected\": 0\n    }\n  },\n  \"pass\": true\n}\n```\n\nCONFIGURATION OPTIONS:\n- Benchmark duration (default: 60 seconds)\n- Number of stress test iterations (default: 100)\n- Timeout test delay (default: 2 seconds)\n- Instruments trace output directory\n- Report format (JSON, Markdown, HTML)\n\nPERFORMANCE CONSIDERATIONS:\nThis task is about measuring performance, not implementing it:\n- Optimization happens in individual phases\n- This task validates existing optimizations\n- If benchmarks fail, go back to implementation phases\n- Don't optimize prematurely—measure first\n\nSECURITY CONSIDERATIONS:\n- Benchmark data contains no sensitive information\n- Safe to commit performance reports to public repo\n- No API keys or user data in traces\n- Instruments traces stay local (don't upload)\n\nIMPLEMENTATION ORDER:\n1. Create performance benchmark suite (Swift Testing)\n2. Implement MemoryMonitor utility\n3. Add main thread violation detection\n4. Create run_performance_verification.sh script\n5. Run benchmarks, collect initial baseline\n6. Document results in performance_results/latest.json\n7. Integrate with CI/CD (optional for MVP)\n8. Create performance regression detection (compare to baseline)\n9. Generate human-readable report\n10. Update README with performance characteristics\n\nCODE ORGANIZATION:\nTests/OptimusClipTests/Performance/TransformationPerformanceTests.swift\nTests/OptimusClipTests/Performance/MemoryMonitor.swift\nTests/OptimusClipTests/Performance/MainThreadMonitor.swift\nScripts/run_performance_verification.sh\nScripts/generate_performance_report.swift\nperformance_results/baseline.json\nperformance_results/latest.json\n\nPRIORITY: P2 (Required before MVP release)\n\nESTIMATED TIME: 150 minutes\n- Benchmark suite: 40 min\n- Memory monitoring: 30 min\n- Timeout verification: 20 min\n- Script automation: 30 min\n- Running tests and analysis: 30 min\n\nDEPENDENCIES:\n- All previous phases complete (measures integrated system)\n- Xcode Instruments installed\n- Release build working\n\nACCEPTANCE:\n- All NFR performance requirements met\n- Baseline measurements documented\n- No memory leaks\n- No main thread violations\n- Performance report generated\n- CI integration ready (optional)\n- Team confident in performance characteristics","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:04.099757-05:00","updated_at":"2025-12-14T20:52:54.336091-05:00","closed_at":"2025-12-14T20:52:54.336091-05:00","dependencies":[{"issue_id":"oc-l9j.9","depends_on_id":"oc-l9j","type":"parent-child","created_at":"2025-12-13T09:40:00.100569-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-l9j.9","depends_on_id":"oc-tmx","type":"blocks","created_at":"2025-12-13T09:40:32.309419-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-n8c","title":"Remove duplicate updateTransformation method in HotkeyManager","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-16T19:41:13.108771-05:00","updated_at":"2025-12-16T20:35:11.30304-05:00","closed_at":"2025-12-16T20:35:11.30304-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:44:43.920068-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-nbd","title":"UX Polish Epic: Premium Feel \u0026 Usability","description":"# UX Polish Epic: Premium Feel \u0026 Usability\n\n## Overview\nThis epic addresses 15 key UX/UI improvements identified in a comprehensive audit of Optimus Clip.\nThe goal is to elevate the app from MVP quality to \"Stripe-level\" polish - intuitive, delightful,\nand professional.\n\n## Motivation\nOptimus Clip has solid core functionality but rough edges that impact:\n- First-run experience (no onboarding, confusing defaults)\n- Day-to-day usability (sparse menu bar, buried history)\n- Configuration experience (model selection gaps, repetitive provider UI)\n- Developer ergonomics (no test mode, basic prompt editor)\n\n## Success Criteria\n- New users can understand and use the app within 2 minutes\n- Settings window feels organized and scannable\n- Menu bar provides quick access to common actions\n- Transformations can be tested before use\n- Visual polish matches premium macOS apps\n\n## Child Epics\n1. First-Run Experience (onboarding flow)\n2. Menu Bar Enhancement (dropdown, icon states)\n3. Transformation Editor Improvements (model selection, test mode, prompt editor)\n4. Settings UX Polish (providers, history, empty states, window sizing)\n5. Technical Quality (conflict detection, polling optimization)\n\n## Priority Rationale\nP1 because UX issues directly impact user adoption and retention. These aren't bugs,\nbut they're the difference between an app people use once and one they recommend to others.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T16:31:23.783067-05:00","updated_at":"2025-12-16T20:27:43.619154-05:00","closed_at":"2025-12-16T20:27:43.619154-05:00","close_reason":"All child epics and tasks completed"}
{"id":"oc-nbd.1","title":"First-Run Experience \u0026 Onboarding","description":"# First-Run Experience \u0026 Onboarding\n\n## Problem Statement\nNew users currently have no guidance when first launching Optimus Clip. They must:\n1. Discover they need accessibility permission (app doesn't work without it)\n2. Figure out how to configure providers (LLM transforms fail silently)\n3. Understand the hotkey-based workflow (nothing happens if they don't know)\n4. Record keyboard shortcuts (defaults have no shortcuts assigned)\n\nThis leads to high abandonment - users try the app, nothing works, they quit.\n\n## Solution\nImplement a multi-step onboarding flow that:\n1. Explains what the app does (30-second value prop)\n2. Guides through accessibility permission (with live status)\n3. Helps configure at least one LLM provider (optional but encouraged)\n4. Walks through first transformation (learning by doing)\n\n## Design Principles\n- Skippable but not dismissible without acknowledgment\n- Progress saved so users can resume\n- Each step has clear value and completion criteria\n- Don't block app usage entirely\n\n## Technical Approach\n- Detect first run via @AppStorage(\"hasCompletedOnboarding\")\n- Show as sheet modal over Settings window\n- Track step progress in UserDefaults\n- Poll permission status during permission step\n- Validate API key during provider step\n\n## Related Issues\n- Item 4: Default transformation disabled - onboarding should explain LLM setup\n- Item 5: No first-run onboarding (this is the direct fix)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T16:31:53.809176-05:00","updated_at":"2025-12-16T16:45:57.063437-05:00","closed_at":"2025-12-16T16:45:57.063437-05:00"}
{"id":"oc-nbd.2","title":"First-Run Experience \u0026 Onboarding","description":"# First-Run Experience \u0026 Onboarding\n\n## Problem Statement\nNew users currently have no guidance when first launching Optimus Clip. They must:\n1. Discover they need accessibility permission (app doesn't work without it)\n2. Figure out how to configure providers (LLM transforms fail silently)\n3. Understand the hotkey-based workflow (nothing happens if they don't know)\n4. Record keyboard shortcuts (defaults have no shortcuts assigned)\n\nThis leads to high abandonment - users try the app, nothing works, they quit.\n\n## Solution\nImplement a multi-step onboarding flow that:\n1. Explains what the app does (30-second value prop)\n2. Guides through accessibility permission (with live status)\n3. Helps configure at least one LLM provider (optional but encouraged)\n4. Walks through first transformation (learning by doing)\n\n## Design Principles\n- Skippable but not dismissible without acknowledgment\n- Progress saved so users can resume\n- Each step has clear value and completion criteria\n- Don't block app usage entirely\n\n## Technical Approach\n- Detect first run via @AppStorage(\"hasCompletedOnboarding\")\n- Show as sheet modal over Settings window\n- Track step progress in UserDefaults\n- Poll permission status during permission step\n- Validate API key during provider step\n\n## Related Issues\n- Item 4: Default transformation disabled - onboarding should explain LLM setup\n- Item 5: No first-run onboarding (this is the direct fix)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T16:32:03.35459-05:00","updated_at":"2025-12-16T20:27:32.92865-05:00","closed_at":"2025-12-16T20:27:32.92865-05:00","close_reason":"All child tasks completed","dependencies":[{"issue_id":"oc-nbd.2","depends_on_id":"oc-nbd","type":"parent-child","created_at":"2025-12-16T16:32:03.355349-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.2.1","title":"Implement first-run detection and welcome screen","description":"# Implement First-Run Detection Mechanism\n\n## What\nAdd infrastructure to detect whether the app has been launched before and track\nonboarding progress.\n\n## Why\nPrerequisite for showing onboarding flow. Need to know:\n- Is this the first launch ever?\n- Has onboarding been completed?\n- What step was user on if they quit mid-onboarding?\n\n## Implementation\n\n### Storage Keys\n```swift\nenum OnboardingKeys {\n    static let hasLaunchedBefore = \"hasLaunchedBefore\"\n    static let onboardingCompleted = \"onboardingCompleted\"\n    static let onboardingStep = \"onboardingStep\"  // 0-4\n}\n```\n\n### Detection Logic (OptimusClipApp.swift or AppDelegate)\n```swift\n@AppStorage(OnboardingKeys.hasLaunchedBefore) private var hasLaunchedBefore = false\n@AppStorage(OnboardingKeys.onboardingCompleted) private var onboardingCompleted = false\n\nvar shouldShowOnboarding: Bool {\n    !hasLaunchedBefore || !onboardingCompleted\n}\n```\n\n### First Launch Handling\nOn first launch:\n1. Set hasLaunchedBefore = true\n2. Show onboarding sheet\n3. Track step progress as user advances\n4. Set onboardingCompleted = true when finished\n\n## Files to Modify\n- Sources/OptimusClip/Settings/SettingsKey.swift - Add onboarding keys\n- Sources/OptimusClip/OptimusClipApp.swift - Check on launch\n- Create: Sources/OptimusClip/Onboarding/OnboardingState.swift\n\n## Testing\n- Reset UserDefaults to simulate first launch\n- Verify onboarding shows on fresh install\n- Verify onboarding doesn't show after completion\n- Verify interrupted onboarding can resume","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:33:08.751208-05:00","updated_at":"2025-12-16T20:20:06.008286-05:00","closed_at":"2025-12-16T20:20:06.008286-05:00","close_reason":"Wired OnboardingStateManager into OptimusClipApp.swift - shows onboarding sheet on Settings appear when shouldShowOnboarding is true","dependencies":[{"issue_id":"oc-nbd.2.1","depends_on_id":"oc-nbd.2","type":"parent-child","created_at":"2025-12-16T16:33:08.751897-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":3,"issue_id":"oc-nbd.2.1","author":"Chris Edwards","text":"Implemented first-run detection and onboarding state management. Changes: - Added SettingsKey constants for onboarding (hasLaunchedBefore, onboardingCompleted, onboardingStep) - Created OnboardingStateManager class with step navigation, progress tracking, skip/complete/reset functions - OnboardingStep enum defines the 5 onboarding steps. Commit: fc7c131. Tests: 271 passed.","created_at":"2025-12-16T23:16:18Z"},{"id":4,"issue_id":"oc-nbd.2.1","author":"Chris Edwards","text":"Implementation complete and pushed (commit fc7c131). CI blocked by missing ModelResolver changes from oc-nbd.4.2 - messaged BrownStone to push the required changes.","created_at":"2025-12-16T23:20:45Z"}]}
{"id":"oc-nbd.2.2","title":"Build onboarding welcome screen","description":"# Build Onboarding Welcome Screen\n\n## What\nCreate the first screen of the onboarding flow - a welcome screen that explains\nwhat Optimus Clip does and sets expectations.\n\n## Why\nUsers need to understand the value prop before investing time in setup. The welcome\nscreen should answer: \"What is this app and why should I care?\"\n\n## Design Spec\n\n```\n┌──────────────────────────────────────────────────────────────┐\n│                                                              │\n│                    [Optimus Clip Icon]                       │\n│                                                              │\n│             Welcome to Optimus Clip                          │\n│                                                              │\n│        Transform your clipboard with a keystroke.            │\n│                                                              │\n│   ┌─────────────────────────────────────────────────────┐   │\n│   │  [Copy Icon]  →  [Hotkey Icon]  →  [Paste Icon]     │   │\n│   │    Copy          Press ⌃⌥T         Paste            │   │\n│   │                                  transformed         │   │\n│   └─────────────────────────────────────────────────────┘   │\n│                                                              │\n│   • Clean up terminal output and code snippets               │\n│   • Fix grammar and spelling with AI                         │\n│   • Reformat text for different contexts                     │\n│                                                              │\n│                                                              │\n│              [ Get Started ]  (primary button)               │\n│                                                              │\n│               Skip setup (do this later)                     │\n│                                                              │\n└──────────────────────────────────────────────────────────────┘\n```\n\n## Implementation Notes\n- Use SwiftUI sheet presentation\n- App icon from Assets catalog\n- Animated or static workflow diagram\n- \"Skip\" should set flag and close, but mark incomplete\n\n## Files\n- Create: Sources/OptimusClip/Views/Onboarding/WelcomeStepView.swift\n- Create: Sources/OptimusClip/Views/Onboarding/OnboardingContainerView.swift\n\n## Acceptance Criteria\n- Screen displays correctly at onboarding sheet size\n- \"Get Started\" advances to next step\n- \"Skip\" closes onboarding but allows re-entry\n- Accessible with VoiceOver","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:33:34.880567-05:00","updated_at":"2025-12-16T16:47:20.037293-05:00","closed_at":"2025-12-16T16:47:20.037293-05:00","close_reason":"Merged into oc-nbd.2.1 - these were two halves of one task","dependencies":[{"issue_id":"oc-nbd.2.2","depends_on_id":"oc-nbd.2","type":"parent-child","created_at":"2025-12-16T16:33:34.881406-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-nbd.2.2","depends_on_id":"oc-nbd.2.1","type":"blocks","created_at":"2025-12-16T16:34:29.341416-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.2.3","title":"Build permission guide screen with live status","description":"# Build Permission Guide Screen with Live Status\n\n## What\nCreate the accessibility permission step of onboarding that guides users through\ngranting the permission with live status feedback.\n\n## Why\nAccessibility permission is REQUIRED for the app to function. Without it:\n- Hotkeys don't work (CGEvent tap needs permission)\n- Paste simulation doesn't work (CGEvent post needs permission)\n\nUsers often don't know how to grant this permission. We need to hand-hold.\n\n## Design Spec\n\n```\n┌──────────────────────────────────────────────────────────────┐\n│                                                              │\n│               [Shield Icon - Yellow]                         │\n│                                                              │\n│         Accessibility Permission Required                    │\n│                                                              │\n│    Optimus Clip needs permission to:                         │\n│    • Listen for your keyboard shortcuts                      │\n│    • Paste transformed text into other apps                  │\n│                                                              │\n│    ┌────────────────────────────────────────────────────┐   │\n│    │  Current Status:                                    │   │\n│    │  [X Circle Red] Not Granted                        │   │\n│    │        OR                                           │   │\n│    │  [✓ Circle Green] Permission Granted!              │   │\n│    └────────────────────────────────────────────────────┘   │\n│                                                              │\n│         [ Open System Settings ]                             │\n│                                                              │\n│    After clicking, find \"Optimus Clip\" in the list          │\n│    and enable the checkbox.                                  │\n│                                                              │\n│         [Continue] (enabled only when granted)               │\n│                                                              │\n└──────────────────────────────────────────────────────────────┘\n```\n\n## Implementation Notes\n- Reuse AccessibilityPermissionManager for status\n- Poll more frequently during this screen (every 1s)\n- Auto-advance when permission granted (with brief celebration)\n- \"Continue\" button disabled until permission granted\n- Show helpful screenshot or animation of System Settings location\n\n## Files\n- Create: Sources/OptimusClip/Views/Onboarding/PermissionStepView.swift\n- Modify: AccessibilityPermissionManager to support faster polling mode\n\n## Edge Cases\n- User grants permission while screen is open → auto-detect and update\n- User closes System Settings without granting → stay on screen\n- User clicks Continue before granted → button should be disabled\n\n## Acceptance Criteria\n- Live status updates within 1-2 seconds of permission change\n- Clear visual indication of current status\n- Cannot proceed without permission\n- Smooth transition when permission granted","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:33:50.71304-05:00","updated_at":"2025-12-16T18:52:12.120853-05:00","closed_at":"2025-12-16T18:52:12.120853-05:00","close_reason":"Created PermissionStepView.swift for onboarding flow with live status updates","dependencies":[{"issue_id":"oc-nbd.2.3","depends_on_id":"oc-nbd.2","type":"parent-child","created_at":"2025-12-16T16:33:50.713945-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-nbd.2.3","depends_on_id":"oc-nbd.2.2","type":"blocks","created_at":"2025-12-16T16:34:29.718342-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-nbd.2.3","depends_on_id":"oc-nbd.6.2","type":"blocks","created_at":"2025-12-16T16:40:53.612367-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":10,"issue_id":"oc-nbd.2.3","author":"Chris Edwards","text":"Completed: Created PermissionStepView with live status indicator, 1-second polling, auto-advance on grant, and celebration animation. Uses context-aware polling from oc-nbd.6.2. CI passed.","created_at":"2025-12-16T23:52:11Z"}]}
{"id":"oc-nbd.2.4","title":"Build optional provider setup screen","description":"# Build Optional Provider Setup Screen\n\n## What\nCreate an optional step in onboarding where users can configure one LLM provider\nfor smart (AI-powered) transformations.\n\n## Why\nWithout a configured provider, LLM transformations fail. But we don't want to block\nonboarding on this - some users may only want algorithmic transforms at first.\n\n## Design Spec\n\n```\n┌──────────────────────────────────────────────────────────────┐\n│                                                              │\n│               [Cloud Icon]                                   │\n│                                                              │\n│         Enable Smart Transformations (Optional)              │\n│                                                              │\n│    Connect an AI provider for intelligent text processing:   │\n│    • Grammar and spelling fixes                              │\n│    • Summarization and rewriting                             │\n│    • Format conversion                                       │\n│                                                              │\n│    Quick Setup - Pick a Provider:                            │\n│                                                              │\n│    ┌────────────────────────────────────────────────────┐   │\n│    │  ( ) OpenAI         [Recommended, most popular]    │   │\n│    │  ( ) Anthropic      [Excellent for writing]        │   │\n│    │  ( ) Ollama         [Free, runs locally]           │   │\n│    └────────────────────────────────────────────────────┘   │\n│                                                              │\n│    [Selected: OpenAI]                                        │\n│    API Key: [________________________] [Get API Key →]       │\n│                                                              │\n│    [Validate Key]   [✓ Valid! Connected to gpt-4o-mini]     │\n│                                                              │\n│         [Continue]    or    [Skip - I'll do this later]      │\n│                                                              │\n└──────────────────────────────────────────────────────────────┘\n```\n\n## Implementation Notes\n- Only show 3 most common providers (OpenAI, Anthropic, Ollama)\n- Reuse validation logic from ProvidersTabView\n- Link to provider's API key page\n- \"Skip\" is prominent - this step is optional\n- If validated, save credentials same as ProvidersTabView does\n\n## Files\n- Create: Sources/OptimusClip/Views/Onboarding/ProviderSetupStepView.swift\n\n## Edge Cases\n- User enters invalid key → show error, allow retry\n- User selects Ollama → show host/port instead of API key\n- User skips → clearly explain they can set this up later in Settings\n\n## Acceptance Criteria\n- At least one provider can be configured\n- Validation provides clear feedback\n- Skip is easy and guilt-free\n- Credentials are properly persisted","notes":"Provider setup onboarding step: ensured saved credentials preload and lint now enforces file length; tests: make check, make test.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T16:34:06.120496-05:00","updated_at":"2025-12-16T20:15:12.066925-05:00","closed_at":"2025-12-16T20:15:12.06693-05:00","dependencies":[{"issue_id":"oc-nbd.2.4","depends_on_id":"oc-nbd.2","type":"parent-child","created_at":"2025-12-16T16:34:06.121455-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-nbd.2.4","depends_on_id":"oc-nbd.2.3","type":"blocks","created_at":"2025-12-16T16:34:30.101118-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.2.5","title":"Build first transformation guided walkthrough","description":"# Build First Transformation Guided Walkthrough\n\n## What\nFinal onboarding step that walks users through using their first transformation\nwith a guided, interactive experience.\n\n## Why\nLearning by doing is more effective than reading instructions. Users should\nexperience the \"aha moment\" of transformation during onboarding.\n\n## Design Spec\n\n```\n┌──────────────────────────────────────────────────────────────┐\n│                                                              │\n│               [Wand Icon - Sparkles]                         │\n│                                                              │\n│              Try Your First Transformation!                  │\n│                                                              │\n│    Let's clean up some messy terminal text.                  │\n│                                                              │\n│    Step 1: Copy this sample text                             │\n│    ┌────────────────────────────────────────────────────┐   │\n│    │ user@host:~$ ls -la                                │   │\n│    │ total 24                                            │   │\n│    │ drwxr-xr-x  2 user user 4096 Dec 15 10:30 .        │   │\n│    │                           [Copy to Clipboard]       │   │\n│    └────────────────────────────────────────────────────┘   │\n│    [✓ Copied!]                                               │\n│                                                              │\n│    Step 2: Press the hotkey                                  │\n│    Press ⌃⌥T (Control + Option + T)                         │\n│    [Waiting for hotkey...]  OR  [✓ Transformation ran!]     │\n│                                                              │\n│    Step 3: See the result                                    │\n│    ┌────────────────────────────────────────────────────┐   │\n│    │ ls -la                                              │   │\n│    │ total 24                                            │   │\n│    │ drwxr-xr-x  2 user user 4096 Dec 15 10:30 .        │   │\n│    └────────────────────────────────────────────────────┘   │\n│    The prompt was removed! Paste this anywhere.             │\n│                                                              │\n│              [ Finish Setup ]                                │\n│                                                              │\n└──────────────────────────────────────────────────────────────┘\n```\n\n## Implementation Notes\n- Use \"Clean Terminal Text\" transformation (always available, no API key needed)\n- Pre-populate sample text that demonstrates the transformation well\n- Monitor clipboard to detect when user copies sample\n- Listen for transformation completion to show result\n- Celebration animation when successful!\n\n## Files\n- Create: Sources/OptimusClip/Views/Onboarding/TryTransformationStepView.swift\n\n## Edge Cases\n- User doesn't have permission → shouldn't reach this step (blocked at step 2)\n- Transformation fails → show error and offer retry\n- User presses wrong hotkey → show hint about correct hotkey\n- User already has custom transformations → still use default for demo\n\n## Acceptance Criteria\n- Interactive walkthrough completes successfully\n- Users understand the copy → hotkey → paste workflow\n- Finishing setup marks onboarding complete\n- Users feel confident to use the app","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T16:34:22.872676-05:00","updated_at":"2025-12-16T20:05:37.384677-05:00","closed_at":"2025-12-16T20:05:37.384677-05:00","close_reason":"Completed: Created TryTransformationStepView.swift and integrated into OnboardingFlowView. Interactive walkthrough guides users through copy → hotkey → paste workflow.","dependencies":[{"issue_id":"oc-nbd.2.5","depends_on_id":"oc-nbd.2","type":"parent-child","created_at":"2025-12-16T16:34:22.873465-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-nbd.2.5","depends_on_id":"oc-nbd.2.3","type":"blocks","created_at":"2025-12-16T16:34:30.506101-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":16,"issue_id":"oc-nbd.2.5","author":"Chris Edwards","text":"WhiteCat: Created TryTransformationStepView.swift - implements the first transformation guided walkthrough. File is complete and builds/tests pass. Still needs integration into OnboardingFlowView.swift (replace FirstTransformationPlaceholderView with TryTransformationStepView). Waiting for BrownSnow to release reservations on OnboardingFlowView.swift.","created_at":"2025-12-17T01:00:43Z"}]}
{"id":"oc-nbd.2.6","title":"Add default keyboard shortcut to Format As Markdown transformation","description":"# Add Default Keyboard Shortcut to Format As Markdown\n\n## Problem\nThe default 'Format As Markdown' transformation ships with no keyboard shortcut assigned.\nThis means users can't actually USE the app until they manually configure one.\nThis is a first-run blocker - the app appears broken.\n\n## Solution\nAssign a sensible default shortcut like ⌃⌥M (Ctrl+Opt+M for 'Markdown').\n\n## Why P1\nWithout this, new users:\n1. Install app\n2. Try to use it\n3. Nothing happens (no shortcut)\n4. Think it's broken\n5. Uninstall\n\nThis one-line change has outsized impact on first-run experience.\n\n## Files to Modify\n- Sources/OptimusClip/Models/TransformationConfig.swift - update default transformation\n\n## Consideration\n- Ensure the shortcut doesn't conflict with common system shortcuts\n- ⌃⌥M is safe (not used by macOS)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:46:05.705002-05:00","updated_at":"2025-12-16T16:49:29.151265-05:00","closed_at":"2025-12-16T16:49:29.151265-05:00","close_reason":"Moved to oc-nbd.7 as standalone P0 task","dependencies":[{"issue_id":"oc-nbd.2.6","depends_on_id":"oc-nbd.2","type":"parent-child","created_at":"2025-12-16T16:46:05.705652-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.3","title":"Menu Bar Enhancement","description":"# Menu Bar Enhancement\n\n## Problem Statement\nThe menu bar dropdown is the primary interaction surface for a menu bar app, yet it only shows\n\"Settings...\" and \"Quit\". This is a massive missed opportunity for:\n- Quick access to transformations\n- Status visibility\n- Common toggles\n\nUsers expect menu bar apps to surface key functionality in the dropdown (see Bartender, CleanShot X, Paste).\n\n## Current State (MenuBarMenuContent in OptimusClipApp.swift)\n```swift\nButton(\"Settings...\")\nDivider()\nButton(\"Quit Optimus Clip\")\n```\n\n## Target State\n```\n┌─────────────────────────────────────────┐\n│ ● Optimus Clip Ready                    │\n├─────────────────────────────────────────┤\n│ Transformations                       ▶ │\n│   Clean Terminal Text         ⌃⌥T       │\n│   Format As Markdown          ⌃⌥M       │\n├─────────────────────────────────────────┤\n│ Recent                                ▶ │\n│   \"Fixed grammar...\" - 2m ago           │\n│   \"Cleaned code...\" - 15m ago           │\n├─────────────────────────────────────────┤\n│ ✓ Hotkeys Enabled                       │\n│   View History...                       │\n│   Settings...                    ⌘,     │\n├─────────────────────────────────────────┤\n│ Quit Optimus Clip                ⌘Q     │\n└─────────────────────────────────────────┘\n```\n\n## Icon State Enhancements\nCurrent states: idle, disabled, processing\nMissing indicators:\n- Permission not granted (app broken)\n- No providers configured (LLM transforms broken)\n- \"Needs attention\" badge for actionable issues\n\n## Related Items\n- Item 1: Menu bar dropdown sparse\n- Item 19: Menu bar icon could show more state","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T16:32:19.746432-05:00","updated_at":"2025-12-16T19:36:28.313101-05:00","closed_at":"2025-12-16T19:36:28.313101-05:00","close_reason":"All child tasks completed: transformations submenu, hotkeys toggle, recent submenu, and status badge implemented","dependencies":[{"issue_id":"oc-nbd.3","depends_on_id":"oc-nbd","type":"parent-child","created_at":"2025-12-16T16:32:19.74726-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.3.1","title":"Add transformations submenu to menu bar dropdown","description":"# Add Transformations Submenu to Menu Bar Dropdown\n\n## What\nAdd a submenu showing all enabled transformations with their keyboard shortcuts,\nallowing users to trigger transformations directly from the menu.\n\n## Why\nUsers currently must memorize hotkeys to use transformations. A menu submenu:\n- Shows available transformations at a glance\n- Displays keyboard shortcuts for learning\n- Provides fallback when hotkey is forgotten\n- Shows which transformations are actually enabled\n\n## Design\n\n```\nTransformations                              ▶\n├── Clean Terminal Text              ⌃⌥T\n├── Fix Grammar                      ⌃⌥G\n├── Format As Markdown               (disabled)\n├── ─────────────────────────────────────\n└── Configure in Settings...\n```\n\n## Implementation\n\n### In MenuBarMenuContent (OptimusClipApp.swift)\n```swift\nMenu(\"Transformations\") {\n    ForEach(enabledTransformations) { transform in\n        Button {\n            triggerTransformation(transform)\n        } label: {\n            Text(transform.name)\n        }\n        .keyboardShortcut(transform.shortcutKey, modifiers: transform.shortcutModifiers)\n        .disabled(!transform.isEnabled)\n    }\n    \n    Divider()\n    \n    Button(\"Configure in Settings...\") {\n        openSettings()\n        // Navigate to Transformations tab\n    }\n}\n```\n\n### Data Flow\n- Load transformations from same source as TransformationsTabView\n- Filter to enabled only for submenu\n- Include shortcut display from KeyboardShortcuts storage\n\n## Files to Modify\n- Sources/OptimusClip/OptimusClipApp.swift - Add submenu to MenuBarMenuContent\n\n## Edge Cases\n- No transformations configured → Show \"No transformations - Configure in Settings...\"\n- All transformations disabled → Show message about enabling\n- Transformation with no hotkey assigned → Show \"No shortcut\" instead of key combo\n\n## Acceptance Criteria\n- Submenu shows all enabled transformations\n- Keyboard shortcuts displayed next to items\n- Clicking item triggers transformation\n- \"Configure\" link opens Settings to Transformations tab","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:34:44.492977-05:00","updated_at":"2025-12-16T17:12:21.812595-05:00","closed_at":"2025-12-16T17:12:21.812595-05:00","close_reason":"Implemented transformations submenu. CI passed (run 20284290816). Commit 7739174 merged to main.","dependencies":[{"issue_id":"oc-nbd.3.1","depends_on_id":"oc-nbd.3","type":"parent-child","created_at":"2025-12-16T16:34:44.493631-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":1,"issue_id":"oc-nbd.3.1","author":"Chris Edwards","text":"Implemented transformations submenu in menu bar dropdown. Changes: - Added TransformationsSubmenu component showing enabled transformations - Each transformation displays name and keyboard shortcut - Clicking triggers the transformation directly - Empty state shows 'No enabled transformations' - 'Configure in Settings...' link at bottom. Commit: 7739174. Tests: 265 passed.","created_at":"2025-12-16T22:08:57Z"}]}
{"id":"oc-nbd.3.2","title":"Add recent transformations submenu","description":"# Add Recent Transformations Submenu\n\n## What\nAdd a \"Recent\" submenu showing the last 5 transformation executions with\ntimestamps and brief preview.\n\n## Why\nUsers want to see:\n- What transformations have run recently\n- When they ran\n- Quick access to history\n- Confirmation that the app is working\n\n## Design\n\n```\nRecent                                       ▶\n├── \"Fixed grammar in email...\"      2m ago\n├── \"Cleaned terminal output...\"    15m ago  \n├── \"Formatted as markdown...\"       1h ago\n├── ─────────────────────────────────────\n└── View Full History...\n```\n\n## Implementation\n\n### Data Source\n- Query HistoryStore for last 5 entries\n- Format timestamp as relative time (\"2m ago\", \"1h ago\", \"Yesterday\")\n- Truncate output text to ~30 chars with \"...\"\n\n### Menu Structure\n```swift\nMenu(\"Recent\") {\n    if recentTransformations.isEmpty {\n        Text(\"No recent transformations\")\n            .foregroundColor(.secondary)\n    } else {\n        ForEach(recentTransformations.prefix(5)) { entry in\n            Button {\n                // Show in history detail? Or just informational\n            } label: {\n                VStack(alignment: .leading) {\n                    Text(entry.truncatedPreview)\n                    Text(entry.relativeTimestamp)\n                        .foregroundColor(.secondary)\n                }\n            }\n        }\n    }\n    \n    Divider()\n    \n    Button(\"View Full History...\") {\n        openHistory()\n    }\n}\n```\n\n## Files to Modify\n- Sources/OptimusClip/OptimusClipApp.swift - Add Recent submenu\n- May need to expose HistoryStore to MenuBarMenuContent\n\n## Dependencies\n- Needs History tab or panel to link to (oc-nbd.5 - Settings UX Polish)\n\n## Acceptance Criteria\n- Shows last 5 transformations\n- Displays relative timestamps\n- \"View Full History\" opens history view\n- Empty state when no history","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T16:34:57.566554-05:00","updated_at":"2025-12-16T19:35:07.534141-05:00","closed_at":"2025-12-16T19:35:07.534141-05:00","close_reason":"Implemented RecentTransformationsSubmenu in OptimusClipApp.swift with relative timestamps and View Full History link","dependencies":[{"issue_id":"oc-nbd.3.2","depends_on_id":"oc-nbd.3","type":"parent-child","created_at":"2025-12-16T16:34:57.56734-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-nbd.3.2","depends_on_id":"oc-nbd.5.2","type":"blocks","created_at":"2025-12-16T16:40:53.225208-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.3.3","title":"Add enable/disable hotkeys toggle to menu","description":"# Add Enable/Disable Hotkeys Toggle to Menu\n\n## What\nAdd a toggle item in the menu bar dropdown that allows users to quickly\nenable or disable all hotkey listening.\n\n## Why\nUsers need a quick way to pause the app without quitting when:\n- They need to use a conflicting keyboard shortcut temporarily\n- They're doing something sensitive and don't want accidental triggers\n- They want to \"turn off\" the app without quitting\n\n## Design\n\n```\n┌─────────────────────────────────────────┐\n│ ✓ Hotkeys Enabled                       │  ← Toggle item\n│                                         │\n│   When disabled:                        │\n│ ○ Hotkeys Paused                        │  ← Shows paused state\n└─────────────────────────────────────────┘\n```\n\n## Implementation\n\n### State Management\n```swift\n// In HotkeyManager or new GlobalState\n@Published var hotkeyListeningEnabled: Bool = true\n\nfunc setHotkeyListening(_ enabled: Bool) {\n    hotkeyListeningEnabled = enabled\n    if enabled {\n        // Re-register all hotkeys\n    } else {\n        // Unregister all hotkeys (but keep configurations)\n    }\n}\n```\n\n### Menu Item\n```swift\nToggle(hotkeyManager.hotkeyListeningEnabled ? \"Hotkeys Enabled\" : \"Hotkeys Paused\",\n       isOn: $hotkeyManager.hotkeyListeningEnabled)\n```\n\n### Visual Feedback\n- When paused, menu bar icon should reflect this (dimmed or different icon)\n- Ties into MenuBarStateManager.setDisabled()\n\n## Files to Modify\n- Sources/OptimusClip/OptimusClipApp.swift - Add toggle to menu\n- Sources/OptimusClip/Managers/HotkeyManager.swift - Add enable/disable all\n- Sources/OptimusClip/MenuBarStateManager.swift - Reflect paused state in icon\n\n## Acceptance Criteria\n- Toggle appears in menu\n- Clicking toggles hotkey listening on/off\n- State persists across app restarts (optional)\n- Menu bar icon reflects paused state\n- Hotkeys stop/resume working immediately","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:35:10.547445-05:00","updated_at":"2025-12-16T18:45:43.274895-05:00","closed_at":"2025-12-16T18:45:43.274895-05:00","close_reason":"Completed","dependencies":[{"issue_id":"oc-nbd.3.3","depends_on_id":"oc-nbd.3","type":"parent-child","created_at":"2025-12-16T16:35:10.548203-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":9,"issue_id":"oc-nbd.3.3","author":"Chris Edwards","text":"Hotkey toggle now drives MenuBarStateManager via a published state, so the icon dimming stays in sync and tests assert the new behavior.","created_at":"2025-12-16T23:46:05Z"}]}
{"id":"oc-nbd.3.4","title":"Add status badge to menu bar icon","description":"# Add Status Badge to Menu Bar Icon\n\n## What\nAdd a small badge indicator to the menu bar icon that shows when the app\nneeds user attention (e.g., missing permissions, no providers configured).\n\n## Why\nUsers should know at a glance if the app is ready to work or needs configuration.\nWithout a visual indicator:\n- Users might not realize permissions aren't granted\n- LLM transforms silently fail if no provider is configured\n- App appears \"broken\" when it's just misconfigured\n\n## Design\n\n### Badge States\n```\n┌─────────────────────────────────────────────────────────────┐\n│ State              │ Badge      │ Trigger                   │\n├────────────────────┼────────────┼───────────────────────────┤\n│ Ready              │ None       │ Permission + provider OK  │\n│ Needs Attention    │ 🔴 (red)   │ Permission missing        │\n│ Setup Incomplete   │ 🟡 (yellow)│ No providers + has LLM tx │\n│ Paused             │ (dimmed)   │ Hotkeys disabled          │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Visual Implementation\nSmall colored dot overlay in bottom-right corner of menu bar icon.\n\n## Implementation\n\n### State Calculation\n```swift\nenum MenuBarBadge {\n    case none\n    case needsAttention  // Red - critical\n    case setupIncomplete // Yellow - warning\n}\n\nvar badge: MenuBarBadge {\n    if !AccessibilityPermissionManager.shared.isGranted {\n        return .needsAttention\n    }\n    if hasLLMTransformations \u0026\u0026 !hasConfiguredProvider {\n        return .setupIncomplete\n    }\n    return .none\n}\n```\n\n### Badge Rendering\nOptions:\n1. Overlay Image on icon (NSImage compositing)\n2. SF Symbol with badge (if available)\n3. Canvas drawing\n\n### Menu Header\nWhen badge is present, show explanation at top of menu:\n```\n┌─────────────────────────────────────────┐\n│ ⚠️ Permission Required                  │\n│    Open System Settings to enable       │\n├─────────────────────────────────────────┤\n│ ...rest of menu...                      │\n```\n\n## Files to Modify\n- Sources/OptimusClip/MenuBarStateManager.swift - Add badge state\n- Sources/OptimusClip/OptimusClipApp.swift - Render badge on icon\n\n## Design Considerations\n- Badge should be subtle - menu bar is crowded\n- Don't badge for minor issues (only actionable problems)\n- Badge should disappear immediately when issue resolved\n- Consider user preference to disable badges\n\n## Acceptance Criteria\n- Badge shows when permission missing\n- Badge shows when LLM setup incomplete\n- Badge disappears when issues resolved\n- Menu header explains badge\n- Not overly intrusive","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T16:35:27.350984-05:00","updated_at":"2025-12-16T18:55:29.435334-05:00","closed_at":"2025-12-16T18:55:29.435334-05:00","close_reason":"Implemented and merged. CI passed.","dependencies":[{"issue_id":"oc-nbd.3.4","depends_on_id":"oc-nbd.3","type":"parent-child","created_at":"2025-12-16T16:35:27.35172-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":11,"issue_id":"oc-nbd.3.4","author":"Chris Edwards","text":"Implemented status badge feature:\n\n**Changes:**\n- Added `MenuBarBadge` enum for badge states (none, needsAttention, setupIncomplete)\n- Added badge state tracking in `MenuBarStateManager`\n- Added badge overlay on menu bar icon\n- Added `StatusHeaderView` in menu dropdown explaining the issue\n\n**Badge Triggers:**\n- Red badge: Accessibility permission not granted\n- Yellow badge: LLM transformations enabled but no provider configured\n\n**Reactive Updates:**\n- Badge state automatically updates when permission is granted\n- Badge state updates when UserDefaults changes (provider config, transformations)\n\nCommit: 5931d3f","created_at":"2025-12-16T23:53:46Z"}]}
{"id":"oc-nbd.4","title":"Transformation Editor Improvements","description":"# Transformation Editor Improvements\n\n## Problem Statement\nThe TransformationEditorView has several gaps that impact usability:\n\n### Missing Model Selection (Items 2 \u0026 3)\n- TransformationConfig has a `model` field that's NEVER exposed in UI\n- Users select a Provider but can't choose which model\n- Architectural confusion: provider defaults vs transformation-specific models\n\n### No Test Mode (Item 16)\n- Users can't test transformations without affecting clipboard\n- Iteration loop is painful: edit prompt → save → copy text → trigger → check result → repeat\n- Should be: edit prompt → test → see result → iterate → save when happy\n\n### Basic System Prompt Editor (Item 17)\n- Plain TextEditor with minimal styling\n- No placeholder/example text\n- No character count\n- No templates/suggestions\n- The prompt IS the product for LLM transforms - deserves better UX\n\n### Outdated Default Model (Item 18)\n- Default \"Format As Markdown\" uses claude-3-haiku-20240307\n- Should use latest: claude-3-5-haiku-20241022\n\n## Success Criteria\n- Users can select specific models per transformation\n- Users can test transformations without clipboard side effects\n- System prompt editor provides guidance and feedback\n- Defaults use current model versions","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T16:32:31.024784-05:00","updated_at":"2025-12-16T20:27:32.957918-05:00","closed_at":"2025-12-16T20:27:32.957918-05:00","close_reason":"All child tasks completed","dependencies":[{"issue_id":"oc-nbd.4","depends_on_id":"oc-nbd","type":"parent-child","created_at":"2025-12-16T16:32:31.025601-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.4.1","title":"Add model selection picker to transformation editor","description":"# Add Model Selection Picker to Transformation Editor\n\n## What\nAdd a model picker in TransformationEditorView that appears after selecting\nan LLM provider, allowing users to choose which model to use for that\nspecific transformation.\n\n## Why\nTransformationConfig has a `model` field that is NEVER exposed in the UI.\nThis means:\n- Users can't choose models per-transformation\n- Different tasks need different models (fast vs smart)\n- The field exists but is always nil\n\n## Current State (TransformationEditorView.swift:43-61)\n```swift\n// Only shows Provider picker, no Model picker!\nPicker(\"Provider\", selection: self.providerBinding) {\n    Text(\"Select Provider\").tag(\"\")\n    ForEach(LLMProvider.allCases) { provider in\n        Text(provider.displayName).tag(provider.rawValue)\n    }\n}\n```\n\n## Target State\n```swift\nPicker(\"Provider\", selection: self.providerBinding) { ... }\n\n// NEW: Model picker (only shown when provider is selected)\nif !transformation.provider.isEmpty {\n    ModelPicker(\n        provider: transformation.provider,\n        selectedModel: $transformation.model,\n        defaultModel: providerDefaultModel\n    )\n}\n```\n\n## Design\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│ LLM Configuration                                           │\n├─────────────────────────────────────────────────────────────┤\n│ Provider:  [Anthropic              ▾]                       │\n│                                                             │\n│ Model:     [claude-3-5-sonnet-20241022     ▾]              │\n│            Using provider default. Override below.          │\n│            [ ] Use specific model: [____________▾]          │\n│                                                             │\n│            Available: claude-3-opus, claude-3-sonnet,       │\n│                       claude-3-5-sonnet, claude-3-haiku     │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n### Model Picker Component\n- Reuse model fetching from ProviderSections (Anthropic has static list, others fetch)\n- Show \"Use provider default (claude-3-5-sonnet)\" option\n- Show override picker below\n- When nil, use provider default; when set, use specific model\n\n### Binding Logic\n```swift\nprivate var modelBinding: Binding\u003cString?\u003e {\n    Binding(\n        get: { transformation.model },\n        set: { transformation.model = $0 }\n    )\n}\n```\n\n### Provider Default Lookup\nNeed to read from AppStorage for each provider:\n- `openai_model_id`, `anthropic_model_id`, etc.\n\n## Files to Modify\n- Sources/OptimusClip/Views/Settings/Transformations/TransformationEditorView.swift\n\n## Dependencies\n- Model config strategy task (oc-nbd.4.2) should be done first to clarify architecture\n\n## Acceptance Criteria\n- Model picker appears after provider selection\n- Shows provider's default model clearly\n- Allows override with specific model\n- Clearing override returns to default\n- Selected model saved to TransformationConfig.model","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:36:01.735663-05:00","updated_at":"2025-12-16T18:39:29.768839-05:00","closed_at":"2025-12-16T18:39:29.768839-05:00","close_reason":"Implemented model selection picker in transformation editor. Users can now override the default model per-transformation.","dependencies":[{"issue_id":"oc-nbd.4.1","depends_on_id":"oc-nbd.4","type":"parent-child","created_at":"2025-12-16T16:36:01.736479-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-nbd.4.1","depends_on_id":"oc-nbd.4.2","type":"blocks","created_at":"2025-12-16T16:37:22.996774-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":6,"issue_id":"oc-nbd.4.1","author":"Chris Edwards","text":"Added model selection picker to TransformationEditorView. Implementation:\n- Added modelResolver to determine effective model from hierarchy\n- Added modelPickerSection with text field for model ID override\n- Shows default model and allows clearing override with X button\n- Uses ModelResolver to display effective model\n\nCommit: 8ee6f9d (included with oc-nbd.4.5 changes)","created_at":"2025-12-16T23:39:22Z"}]}
{"id":"oc-nbd.4.2","title":"Document and implement model configuration hierarchy","description":"# Document and Implement Model Configuration Hierarchy\n\n## What\nClarify and implement the model configuration architecture:\n- Document the priority: transformation.model \u003e provider default\n- Update LLM client factory to respect this hierarchy\n- Add helper to resolve effective model\n\n## Why\nCurrently there are two model configuration systems:\n1. Provider defaults in ProvidersTabView (@AppStorage)\n2. Per-transformation model in TransformationConfig (never used)\n\nThis creates confusion about which model is actually used.\n\n## Architecture Decision\n\n### Hierarchy (highest to lowest priority)\n1. `TransformationConfig.model` - Per-transformation override\n2. Provider default from AppStorage - Global per-provider setting\n\n### Resolution Logic\n```swift\nfunc resolveModel(for transformation: TransformationConfig) -\u003e String {\n    // 1. Check transformation-specific model\n    if let model = transformation.model, !model.isEmpty {\n        return model\n    }\n    \n    // 2. Fall back to provider default\n    guard let provider = transformation.provider else {\n        fatalError(\"No provider configured\")\n    }\n    \n    return providerDefaultModel(for: provider)\n}\n\nfunc providerDefaultModel(for provider: String) -\u003e String {\n    switch provider {\n    case \"openai\": UserDefaults.standard.string(forKey: \"openai_model_id\") ?? \"gpt-4o-mini\"\n    case \"anthropic\": UserDefaults.standard.string(forKey: \"anthropic_model_id\") ?? \"claude-3-5-sonnet-20241022\"\n    // ... etc\n    }\n}\n```\n\n## Implementation Steps\n\n1. Create `ModelResolver` service class\n2. Update `LLMProviderClientFactory` to use ModelResolver\n3. Update `TransformationFlowCoordinator` to pass resolved model\n4. Add documentation comments explaining hierarchy\n5. Add unit tests for resolution logic\n\n## Files to Modify\n- Create: Sources/OptimusClip/Services/ModelResolver.swift\n- Modify: Sources/OptimusClip/Services/LLMProviderClients/LLMProviderClientFactory.swift\n- Modify: Sources/OptimusClip/Services/TransformationFlowCoordinator.swift\n\n## Testing\n- Transformation with model set → uses transformation model\n- Transformation with nil model → uses provider default\n- Provider default not set → uses hardcoded fallback\n- Model changed mid-session → picks up new value\n\n## Documentation\nAdd code comments and/or ARCHITECTURE.md section explaining:\n- Why two-level configuration exists\n- How to override defaults\n- What happens when neither is set\n\n## Acceptance Criteria\n- Model resolution is consistent across app\n- Unit tests verify hierarchy\n- Code is documented\n- LLM calls use correct resolved model","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:36:17.262914-05:00","updated_at":"2025-12-16T18:25:56.324174-05:00","closed_at":"2025-12-16T18:25:56.324174-05:00","close_reason":"Implemented ModelResolver hierarchy, wired pipelines, added tests; make check \u0026\u0026 make test passing","dependencies":[{"issue_id":"oc-nbd.4.2","depends_on_id":"oc-nbd.4","type":"parent-child","created_at":"2025-12-16T16:36:17.263773-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.4.3","title":"Add transformation test mode with preview","description":"# Add Transformation Test Mode with Preview\n\n## What\nAdd a \"Test\" section in TransformationEditorView that allows users to:\n1. Enter sample input text\n2. Run the transformation\n3. See the output preview\nWITHOUT modifying the clipboard or triggering actual paste.\n\n## Why\nCurrent workflow for testing a transformation:\n1. Write/edit prompt\n2. Save transformation\n3. Copy some text to clipboard\n4. Press hotkey\n5. Check if output is correct\n6. If not, go back to step 1\n\nThis is painful for iteration. Test mode enables:\n1. Write/edit prompt\n2. Enter test input\n3. Click \"Test\"\n4. See output immediately\n5. Iterate until happy\n6. Save\n\n## Design\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│ Test Transformation                                         │\n├─────────────────────────────────────────────────────────────┤\n│ Input:                                                      │\n│ ┌─────────────────────────────────────────────────────────┐ │\n│ │ user@host:~$ ls -la                                     │ │\n│ │ total 24                                                │ │\n│ │ drwxr-xr-x  2 user user 4096 Dec 15 10:30 .            │ │\n│ └─────────────────────────────────────────────────────────┘ │\n│                                                             │\n│ [Run Test]  ○ Running... (2.3s)                            │\n│                                                             │\n│ Output:                                                     │\n│ ┌─────────────────────────────────────────────────────────┐ │\n│ │ ls -la                                                  │ │\n│ │ total 24                                                │ │\n│ │ drwxr-xr-x  2 user user 4096 Dec 15 10:30 .            │ │\n│ └─────────────────────────────────────────────────────────┘ │\n│ ✓ Success (1.2s, 45 tokens)                                │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n### State\n```swift\n@State private var testInput: String = \"\"\n@State private var testOutput: String = \"\"\n@State private var testState: TestState = .idle\n\nenum TestState {\n    case idle\n    case running(startTime: Date)\n    case success(duration: TimeInterval, tokens: Int?)\n    case error(message: String)\n}\n```\n\n### Test Execution\n```swift\nfunc runTest() async {\n    testState = .running(startTime: Date())\n    \n    do {\n        // Build transformation from current config\n        let transformation = buildTransformation(from: transformation)\n        \n        // Run WITHOUT clipboard/paste\n        let output = try await transformation.transform(testInput)\n        \n        testOutput = output\n        testState = .success(duration: elapsed, tokens: nil)\n    } catch {\n        testState = .error(message: error.localizedDescription)\n    }\n}\n```\n\n### Transformation Building\nNeed to instantiate transformation from TransformationConfig:\n- Algorithmic → use built-in transformations\n- LLM → create LLMTransformation with provider/model/prompt\n\n## Files to Modify\n- Sources/OptimusClip/Views/Settings/Transformations/TransformationEditorView.swift\n- May need to extract transformation factory logic\n\n## Edge Cases\n- LLM transformation with no provider configured → show error\n- Very long input → warn or truncate\n- Test while another test running → disable button\n- Network error → show retry option\n\n## Acceptance Criteria\n- Test section appears in transformation editor\n- Can enter sample text\n- \"Run Test\" executes transformation\n- Output shown without clipboard modification\n- Shows success/error state clearly\n- Works for both algorithmic and LLM transformations","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:36:35.998824-05:00","updated_at":"2025-12-16T18:29:29.19394-05:00","closed_at":"2025-12-16T18:29:29.19394-05:00","close_reason":"Implemented transformation test mode with preview. Added test section UI with input/output editors, test state management (idle/running/success/error), and support for both algorithmic and LLM transformations.","dependencies":[{"issue_id":"oc-nbd.4.3","depends_on_id":"oc-nbd.4","type":"parent-child","created_at":"2025-12-16T16:36:35.999637-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.4.4","title":"Improve system prompt editor UX","description":"# Improve System Prompt Editor UX\n\n## What\nEnhance the system prompt TextEditor in TransformationEditorView with:\n- Placeholder text showing example prompt\n- Character count\n- Better visual styling\n- Prompt templates/suggestions (optional)\n\n## Why\nThe system prompt is the CORE of LLM transformations - it deserves premium UX.\nCurrently it's a plain TextEditor with basic border styling:\n\n```swift\nTextEditor(text: self.$transformation.systemPrompt)\n    .font(.system(.body, design: .monospaced))\n    .frame(minHeight: 100)\n    .border(Color.secondary.opacity(0.3))  // Basic!\n```\n\n## Design\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│ System Prompt                                               │\n├─────────────────────────────────────────────────────────────┤\n│ [Insert Template ▾]                                         │\n│                                                             │\n│ ┌─────────────────────────────────────────────────────────┐ │\n│ │ Clean up the following text. Remove any terminal        │ │\n│ │ prompts, line numbers, or formatting artifacts.         │ │\n│ │ Preserve the actual content.                            │ │\n│ │                                                         │ │\n│ │                                                         │ │\n│ │                                                         │ │\n│ └─────────────────────────────────────────────────────────┘ │\n│ 127 characters                                              │\n│                                                             │\n│ 💡 Tips: Be specific about what to preserve and remove.    │\n│    Use \"You are...\" to set the LLM's persona.              │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n### 1. Placeholder Text\nShow when empty:\n```\nWrite instructions for the AI. Example:\n\"Clean up the following text. Fix grammar and spelling\nerrors while preserving the original meaning and tone.\"\n```\n\n### 2. Character Count\n```swift\nHStack {\n    Spacer()\n    Text(\"\\(transformation.systemPrompt.count) characters\")\n        .font(.caption)\n        .foregroundColor(.secondary)\n}\n```\n\n### 3. Better Styling\n```swift\nTextEditor(text: $transformation.systemPrompt)\n    .font(.system(.body, design: .monospaced))\n    .padding(8)\n    .background(Color(nsColor: .textBackgroundColor))\n    .cornerRadius(8)\n    .overlay(\n        RoundedRectangle(cornerRadius: 8)\n            .stroke(Color.secondary.opacity(0.2), lineWidth: 1)\n    )\n```\n\n### 4. Template Dropdown (Optional/Future)\n```swift\nMenu(\"Insert Template\") {\n    Button(\"Fix Grammar\") {\n        systemPrompt = Templates.fixGrammar\n    }\n    Button(\"Clean Code\") {\n        systemPrompt = Templates.cleanCode\n    }\n    // etc.\n}\n```\n\n## Files to Modify\n- Sources/OptimusClip/Views/Settings/Transformations/TransformationEditorView.swift\n- May create: Sources/OptimusClip/Views/Settings/Transformations/SystemPromptEditor.swift\n\n## Acceptance Criteria\n- Placeholder text visible when empty\n- Character count shown\n- Improved visual styling (rounded corners, proper padding)\n- (Optional) Template dropdown for common prompts\n- (Optional) Tips section with prompt writing guidance","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T16:37:06.305495-05:00","updated_at":"2025-12-16T18:45:54.948781-05:00","closed_at":"2025-12-16T18:45:54.948781-05:00","close_reason":"Implemented system prompt editor improvements","dependencies":[{"issue_id":"oc-nbd.4.4","depends_on_id":"oc-nbd.4","type":"parent-child","created_at":"2025-12-16T16:37:06.30629-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":7,"issue_id":"oc-nbd.4.4","author":"Chris Edwards","text":"Improved system prompt editor UX:\n- Added placeholder text when empty\n- Added character count display  \n- Better visual styling with rounded corners and padding\n\nCommit: e44a502","created_at":"2025-12-16T23:45:54Z"}]}
{"id":"oc-nbd.4.5","title":"Update default transformation to use current model","description":"# Update Default Transformation to Use Current Model\n\n## What\nUpdate the default \"Format As Markdown\" transformation to use a current\nmodel version instead of the outdated one.\n\n## Why\nThe default uses `claude-3-haiku-20240307` which is outdated:\n\n```swift\n// In TransformationConfig.swift:147\nmodel: \"claude-3-haiku-20240307\",  // OLD!\n```\n\nShould be:\n```swift\nmodel: \"claude-3-5-haiku-20241022\",  // Current\n```\n\nOr even better, use nil to inherit from provider default.\n\n## Implementation Options\n\n### Option A: Update to specific current model\n```swift\nmodel: \"claude-3-5-haiku-20241022\"\n```\nPro: Explicit, predictable\nCon: Will become outdated again\n\n### Option B: Use nil to inherit provider default\n```swift\nmodel: nil  // Uses provider default from ProvidersTabView\n```\nPro: Always uses user's configured default\nCon: Depends on model hierarchy being implemented (oc-nbd.4.2)\n\n### Option C: Remove model field from defaults entirely\nSince it's supposed to use provider default anyway.\n\n## Recommendation\nUse Option B (nil) - this respects user's provider configuration\nand won't become outdated. Requires model hierarchy task (oc-nbd.4.2).\n\n## Files to Modify\n- Sources/OptimusClip/Models/TransformationConfig.swift (line ~147)\n\n## Dependencies\n- Should be done after model hierarchy is implemented (oc-nbd.4.2)\n\n## Acceptance Criteria\n- Default transformation uses appropriate model\n- Doesn't break existing user configurations\n- Works with model resolution hierarchy","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T16:37:22.611175-05:00","updated_at":"2025-12-16T18:39:22.671245-05:00","closed_at":"2025-12-16T18:39:22.671245-05:00","close_reason":"Implemented Option B: model set to nil to use provider default via ModelResolver hierarchy","dependencies":[{"issue_id":"oc-nbd.4.5","depends_on_id":"oc-nbd.4","type":"parent-child","created_at":"2025-12-16T16:37:22.611962-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-nbd.4.5","depends_on_id":"oc-nbd.4.2","type":"blocks","created_at":"2025-12-16T16:37:23.378106-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":5,"issue_id":"oc-nbd.4.5","author":"Chris Edwards","text":"Completed: Changed default 'Format As Markdown' transformation model from hardcoded 'claude-3-haiku-20240307' to nil, allowing it to inherit from provider default via ModelResolver. Build and tests pass. CI succeeded.","created_at":"2025-12-16T23:39:22Z"}]}
{"id":"oc-nbd.5","title":"Settings UX Polish","description":"# Settings UX Polish\n\n## Problem Statement\nThe Settings window has several UX issues that make it feel unpolished:\n\n### Provider Sections Repetitive (Item 9)\n- 5 nearly identical sections (~800 lines of repetitive code)\n- No visual hierarchy - can't tell configured vs unconfigured at a glance\n- All sections expanded = overwhelming\n- User must scroll and inspect each\n\n### History Buried (Item 11)\n- History is a KEY feature for clipboard utilities\n- Currently hidden in General tab, shows only 5 entries\n- Users want: recent activity, ability to redo, debugging info\n\n### Empty State Missing CTA (Item 13)\n- Transformation empty state says \"click +\" but has no button\n- Users must hunt for small toolbar icon\n- Missed opportunity to educate and guide\n\n### Fixed Window Size (Item 20)\n- Hardcoded 650x500 with .fixedSize()\n- Providers tab needs more space\n- Large displays waste potential\n- No memory of user preference\n\n## Success Criteria\n- Provider configuration status visible at a glance\n- History easily accessible with rich functionality\n- Empty states drive action\n- Settings window adapts to user needs","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-16T16:32:42.189342-05:00","updated_at":"2025-12-16T20:27:32.989729-05:00","closed_at":"2025-12-16T20:27:32.989729-05:00","close_reason":"All child tasks completed","dependencies":[{"issue_id":"oc-nbd.5","depends_on_id":"oc-nbd","type":"parent-child","created_at":"2025-12-16T16:32:42.190058-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.5.1","title":"Refactor provider sections with visual hierarchy","description":"# Refactor Provider Sections with Visual Hierarchy\n\n## What\nImprove the Providers tab by:\n1. Adding visual indicators for configured vs unconfigured providers\n2. Collapsing unconfigured providers by default\n3. Adding a summary header showing configuration status\n\n## Why\nCurrently all 5 provider sections look identical with no visual hierarchy:\n- Can't tell at a glance which providers are configured\n- User must scroll and inspect each section\n- ~800 lines of repetitive code with no distinction\n\n## Design\n\n### Summary Header\n```\n┌─────────────────────────────────────────────────────────────┐\n│ LLM Providers                                               │\n│ 2 of 5 configured                                           │\n│ ✓ OpenAI  ✓ Anthropic  ○ OpenRouter  ○ Ollama  ○ Bedrock   │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Provider Sections with Status\n```\n▼ OpenAI ✓ Configured\n  [Expanded content...]\n\n▼ Anthropic ✓ Configured  \n  [Expanded content...]\n\n▶ OpenRouter (Click to configure)\n  [Collapsed]\n\n▶ Ollama (Click to configure)\n  [Collapsed]\n\n▶ AWS Bedrock (Click to configure)\n  [Collapsed]\n```\n\n## Implementation\n\n### 1. Configuration Status Detection\n```swift\nfunc isProviderConfigured(_ provider: LLMProvider) -\u003e Bool {\n    switch provider {\n    case .openai: !openAIKey.isEmpty\n    case .anthropic: !anthropicKey.isEmpty\n    case .openRouter: !openRouterKey.isEmpty\n    case .ollama: !ollamaHost.isEmpty\n    case .awsBedrock: hasAWSCredentials\n    }\n}\n```\n\n### 2. Disclosure Group Pattern\n```swift\nDisclosureGroup(isExpanded: $isOpenAIExpanded) {\n    OpenAIProviderSection(...)\n} label: {\n    ProviderHeaderRow(\n        provider: .openai,\n        isConfigured: isProviderConfigured(.openai)\n    )\n}\n```\n\n### 3. Auto-expand Configured\nOn load, expand configured providers, collapse unconfigured.\n\n## Files to Modify\n- Sources/OptimusClip/Views/Settings/Providers/ProvidersTabView.swift\n- Sources/OptimusClip/Views/Settings/Providers/ProviderSections.swift\n\n## Code Deduplication Opportunity\nExtract common patterns from the 5 provider sections into:\n- Generic ProviderSection\u003cT: ProviderConfig\u003e\n- Reusable validation components\n- Shared model fetching logic\n\n## Acceptance Criteria\n- Summary shows configuration status\n- Configured providers visually distinct\n- Unconfigured providers collapsed by default\n- Expanding/collapsing works smoothly\n- Visual badges indicate status","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T16:37:39.606604-05:00","updated_at":"2025-12-16T19:06:15.883424-05:00","closed_at":"2025-12-16T19:06:15.883424-05:00","close_reason":"Implemented provider sections with visual hierarchy: summary header, disclosure groups, configuration status indicators. Commit 4bf0d18. CI passed.","dependencies":[{"issue_id":"oc-nbd.5.1","depends_on_id":"oc-nbd.5","type":"parent-child","created_at":"2025-12-16T16:37:39.60741-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.5.2","title":"Create dedicated History tab or panel","description":"# Create Dedicated History Tab or Panel\n\n## What\nElevate the transformation history from a small section in General tab to\neither a dedicated Settings tab or a floating panel accessible from menu bar.\n\n## Why\nHistory is a PRIMARY feature for clipboard utilities. Current state:\n- Buried in General tab under \"History\" section\n- Shows only 5 entries\n- No search or filtering\n- Can't copy from history\n- Can't redo from history\n\nUsers want to:\n- See what transformations ran\n- Debug when something looks wrong\n- Redo a transformation\n- Review input/output pairs\n\n## Design Options\n\n### Option A: Dedicated Tab\nAdd \"History\" as a 5th tab in Settings:\n```\n[Transformations] [Providers] [General] [History] [Permissions]\n```\n\n### Option B: Floating Panel (like Paste app)\nAccessible from menu bar \"View History...\" item.\nCan be opened while other apps have focus.\n\n### Recommendation: Both\n- Full History tab in Settings for detailed browsing\n- \"Recent\" submenu in menu bar for quick access\n\n## Tab Design\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│ Search: [________________________] [Filter: All Types ▾]    │\n├─────────────────────────────────────────────────────────────┤\n│ Today                                                       │\n│ ┌─────────────────────────────────────────────────────────┐ │\n│ │ Clean Terminal Text                          2:30 PM    │ │\n│ │ \"ls -la total 24...\" → \"ls -la total 24...\"             │ │\n│ │ [Copy Input] [Copy Output] [Redo]                       │ │\n│ └─────────────────────────────────────────────────────────┘ │\n│ ┌─────────────────────────────────────────────────────────┐ │\n│ │ Fix Grammar (Anthropic)                      1:15 PM    │ │\n│ │ \"Their going to the...\" → \"They're going to the...\"     │ │\n│ │ [Copy Input] [Copy Output] [Redo]                       │ │\n│ └─────────────────────────────────────────────────────────┘ │\n│                                                             │\n│ Yesterday                                                   │\n│ ...                                                         │\n├─────────────────────────────────────────────────────────────┤\n│ Showing 25 of 142 entries               [Clear History]     │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n### Data Display\n- Group by date (Today, Yesterday, This Week, etc.)\n- Show transformation name, provider, timestamp\n- Show truncated input/output preview\n- Expand for full text\n\n### Actions\n- Copy Input: Copy original text to clipboard\n- Copy Output: Copy transformed text to clipboard  \n- Redo: Run same transformation on current clipboard\n\n### Filtering\n- By transformation type (algorithmic/LLM)\n- By transformation name\n- By date range\n- Full-text search\n\n## Files\n- Create: Sources/OptimusClip/Views/Settings/History/HistoryTabView.swift\n- Create: Sources/OptimusClip/Views/Settings/History/HistoryEntryDetailView.swift\n- Modify: Sources/OptimusClip/Views/Settings/SettingsView.swift (add tab)\n- Modify: HistoryStore for search/filter support\n\n## Acceptance Criteria\n- History is easily accessible (not buried)\n- Shows more than 5 entries\n- Can search and filter\n- Can copy input/output\n- Can redo transformations\n- Grouped by date for scanning","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-16T16:38:00.873851-05:00","updated_at":"2025-12-16T19:27:00.480957-05:00","closed_at":"2025-12-16T19:27:00.480957-05:00","close_reason":"Created dedicated History tab with search, date grouping, copy actions. Commit d730ae8. CI passed after displayName fix (d8ec9ab).","dependencies":[{"issue_id":"oc-nbd.5.2","depends_on_id":"oc-nbd.5","type":"parent-child","created_at":"2025-12-16T16:38:00.874844-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.5.3","title":"Add CTA button to transformation empty state","description":"# Add CTA Button to Transformation Empty State\n\n## What\nAdd an actionable button to TransformationEmptyStateView instead of just\ntelling users to \"click +\".\n\n## Why\nCurrent empty state says:\n```\n\"Select a transformation from the sidebar\nor click + to create a new one.\"\n```\n\nBut there's no actual button - users must hunt for the small + icon\nin the sidebar toolbar. This is a missed opportunity to guide action.\n\n## Current State (TransformationEmptyStateView.swift)\n```swift\nText(\"Select a transformation from the sidebar\\nor click + to create a new one.\")\n    .font(.body)\n    .foregroundColor(.secondary)\n    .multilineTextAlignment(.center)\n```\n\n## Target State\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                                                             │\n│                    [wand.and.stars Icon]                    │\n│                                                             │\n│              Create Your First Transformation               │\n│                                                             │\n│     Transformations modify clipboard content when you       │\n│     press a keyboard shortcut. Clean up code, fix           │\n│     grammar, or reformat text instantly.                    │\n│                                                             │\n│     ┌─────────────────────────────────────────────────┐    │\n│     │    [+ Create Transformation]                     │    │\n│     └─────────────────────────────────────────────────┘    │\n│                                                             │\n│     Or select an existing one from the sidebar.            │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n```swift\nstruct TransformationEmptyStateView: View {\n    let onCreateTransformation: () -\u003e Void\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            Image(systemName: \"wand.and.stars\")\n                .font(.system(size: 56))\n                .foregroundStyle(.secondary)\n            \n            Text(\"Create Your First Transformation\")\n                .font(.title2)\n                .fontWeight(.semibold)\n            \n            Text(\"Transformations modify clipboard content...\")\n                .font(.body)\n                .foregroundStyle(.secondary)\n                .multilineTextAlignment(.center)\n                .padding(.horizontal, 32)\n            \n            Button {\n                onCreateTransformation()\n            } label: {\n                Label(\"Create Transformation\", systemImage: \"plus\")\n            }\n            .buttonStyle(.borderedProminent)\n            .controlSize(.large)\n            \n            Text(\"Or select an existing one from the sidebar.\")\n                .font(.caption)\n                .foregroundStyle(.tertiary)\n        }\n        .frame(maxWidth: .infinity, maxHeight: .infinity)\n    }\n}\n```\n\n## Files to Modify\n- Sources/OptimusClip/Views/Settings/Transformations/TransformationEmptyStateView.swift\n- Sources/OptimusClip/Views/Settings/Transformations/TransformationsTabView.swift (pass callback)\n\n## Acceptance Criteria\n- Prominent CTA button in empty state\n- Button triggers same action as + button in sidebar\n- Improved copy explaining what transformations are\n- Works when transformations list is empty\n- Works when no transformation is selected","notes":"CTA button wired to add action in empty state; tests: make check, make test; commit 4e7ef2a pushed.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-16T16:39:36.622658-05:00","updated_at":"2025-12-16T19:21:26.941895-05:00","closed_at":"2025-12-16T19:21:26.941899-05:00","dependencies":[{"issue_id":"oc-nbd.5.3","depends_on_id":"oc-nbd.5","type":"parent-child","created_at":"2025-12-16T16:39:36.623902-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.5.4","title":"Make settings window resizable with persistence","description":"# Make Settings Window Resizable with Persistence\n\n## What\nAllow the Settings window to be resized by users, and persist their\npreferred size across app restarts.\n\n## Why\nCurrent state in SettingsView.swift:\n```swift\n.frame(width: 650, height: 500)\n.fixedSize()\n```\n\nProblems:\n- Providers tab is cramped with 5 sections\n- Large displays could use more space\n- No way to make it smaller on constrained displays\n- User preference not respected\n\n## Implementation\n\n### 1. Remove Fixed Size\n```swift\n// Before\n.frame(width: 650, height: 500)\n.fixedSize()\n\n// After\n.frame(\n    minWidth: 550, idealWidth: 700, maxWidth: 1000,\n    minHeight: 400, idealHeight: 550, maxHeight: 800\n)\n```\n\n### 2. Persist Window Frame\nUse `@SceneStorage` for automatic persistence per-scene:\n```swift\n// Note: SceneStorage may not work well with Settings scene\n// Alternative: Manual UserDefaults persistence via windowDidResize delegate\n```\n\n### 3. Alternative: Window Frame Storage\n```swift\n// In AppDelegate or window delegate\nfunc windowDidEndLiveResize(_ notification: Notification) {\n    if let window = notification.object as? NSWindow,\n       window.identifier?.rawValue == \"settings\" {\n        let frame = window.frame\n        UserDefaults.standard.set(NSCoder.string(for: frame), forKey: \"settingsWindowFrame\")\n    }\n}\n```\n\n### 4. Restore on Launch\n```swift\nfunc applicationDidFinishLaunching(_ notification: Notification) {\n    if let frameString = UserDefaults.standard.string(forKey: \"settingsWindowFrame\"),\n       let frame = NSRectFromString(frameString) as? NSRect {\n        settingsWindow?.setFrame(frame, display: true)\n    }\n}\n```\n\n## Design Considerations\n\n### Per-Tab Ideal Sizes\nDifferent tabs have different content heights:\n- Transformations: Master-detail, benefits from width\n- Providers: Long form, benefits from height\n- General: Fixed content\n- Permissions: Fixed content\n- History: List, benefits from both\n\nConsider per-tab minimum sizes or adaptive layout.\n\n### Respecting Safe Bounds\n- Don't allow resizing larger than screen\n- Don't allow resizing smaller than usable\n- Remember size per display (for multi-monitor)\n\n## Files to Modify\n- Sources/OptimusClip/Views/Settings/SettingsView.swift\n- Sources/OptimusClip/AppDelegate.swift (for persistence)\n\n## Acceptance Criteria\n- Window can be resized by dragging edges/corners\n- Size persists across app restarts\n- Reasonable min/max bounds enforced\n- Different tabs don't break at various sizes","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-16T16:39:54.181008-05:00","updated_at":"2025-12-16T19:10:21.518897-05:00","closed_at":"2025-12-16T19:10:21.518897-05:00","close_reason":"Implemented resizable settings window with min/max bounds. Commit fefec07. CI passed.","dependencies":[{"issue_id":"oc-nbd.5.4","depends_on_id":"oc-nbd.5","type":"parent-child","created_at":"2025-12-16T16:39:54.181792-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.6","title":"Technical Quality \u0026 Performance","description":"# Technical Quality \u0026 Performance\n\n## Problem Statement\nTwo technical issues that affect app quality without being user-visible bugs:\n\n### Hotkey Conflict Detection (Item 10)\n- Users can assign dangerous shortcuts (⌘C, ⌘V, ⌘Q) to transformations\n- Users can assign same shortcut to multiple transformations\n- No warning, no prevention - foot-gun waiting to happen\n- Could break system clipboard operations entirely\n\n### Accessibility Permission Polling (Item 15)\n- Currently polls every 2 seconds for permission status\n- Permission changes are rare (once per app lifetime typically)\n- Menu bar apps should be \"invisible\" in resource usage\n- Wasteful CPU wakes for a setting that rarely changes\n\n## Design Considerations\n\n### Conflict Detection Levels\n1. **Critical (block)**: ⌘C, ⌘V, ⌘X, ⌘Z, ⌘Q, ⌘W\n2. **System (warn)**: ⌘Space, ⌘Tab, etc.\n3. **Internal (warn)**: Same shortcut used twice in app\n4. **Common (inform)**: ⌘S, ⌘P - might interfere with other apps\n\n### Polling Optimization\n- 30s interval when app is backgrounded\n- 2s interval only when Permissions tab is visible\n- Stop polling entirely once permission is granted (check on launch only)\n\n## Success Criteria\n- Users cannot accidentally break clipboard operations\n- Users are warned about potential conflicts\n- App resource usage is minimal when idle\n- Permission polling doesn't waste CPU cycles","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-16T16:32:55.590032-05:00","updated_at":"2025-12-16T20:27:33.050065-05:00","closed_at":"2025-12-16T20:27:33.050065-05:00","close_reason":"All child tasks completed","dependencies":[{"issue_id":"oc-nbd.6","depends_on_id":"oc-nbd","type":"parent-child","created_at":"2025-12-16T16:32:55.590775-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-nbd.6.1","title":"Add keyboard shortcut conflict detection","description":"# Add Keyboard Shortcut Conflict Detection\n\n## What\nImplement detection and warnings for keyboard shortcut conflicts when users\nrecord hotkeys in TransformationEditorView.\n\n## Why\nUsers can accidentally assign dangerous shortcuts that break system functionality:\n- ⌘C (copy) - breaks copy\n- ⌘V (paste) - breaks paste, ironic for a clipboard app\n- ⌘Q (quit) - accidental quits\n- Same shortcut for two transformations - undefined behavior\n\n## Conflict Categories\n\n### 1. Critical (Block Assignment)\nThese shortcuts should be blocked entirely:\n```swift\nlet criticalShortcuts: Set\u003cKeyCombo\u003e = [\n    KeyCombo(.c, modifiers: .command),  // Copy\n    KeyCombo(.v, modifiers: .command),  // Paste\n    KeyCombo(.x, modifiers: .command),  // Cut\n    KeyCombo(.z, modifiers: .command),  // Undo\n    KeyCombo(.q, modifiers: .command),  // Quit\n    KeyCombo(.w, modifiers: .command),  // Close window\n]\n```\n\n### 2. System (Warn)\nSystem shortcuts that might conflict:\n```swift\nlet systemShortcuts: Set\u003cKeyCombo\u003e = [\n    KeyCombo(.space, modifiers: .command),   // Spotlight\n    KeyCombo(.tab, modifiers: .command),     // App switcher\n    KeyCombo(.space, modifiers: [.command, .shift]), // Screenshot menu\n    // etc.\n]\n```\n\n### 3. Internal (Warn)\nSame shortcut used by another transformation in the app.\n\n### 4. Common App (Inform)\nShortcuts commonly used by other apps:\n```swift\nlet commonAppShortcuts = [\n    KeyCombo(.s, modifiers: .command),  // Save\n    KeyCombo(.p, modifiers: .command),  // Print\n    KeyCombo(.f, modifiers: .command),  // Find\n]\n```\n\n## Implementation\n\n### Hook into KeyboardShortcuts.Recorder\n```swift\nKeyboardShortcuts.Recorder(for: transformation.shortcutName)\n    .onChange { newShortcut in\n        if let shortcut = newShortcut {\n            validateShortcut(shortcut)\n        }\n    }\n\nfunc validateShortcut(_ shortcut: KeyboardShortcuts.Shortcut) {\n    if isCritical(shortcut) {\n        // Show error, revert assignment\n        showAlert(.critical, shortcut)\n        KeyboardShortcuts.reset(transformation.shortcutName)\n    } else if isSystemShortcut(shortcut) {\n        showWarning(.system, shortcut)\n    } else if conflictsWithOtherTransformation(shortcut) {\n        showWarning(.internal, shortcut)\n    } else if isCommonAppShortcut(shortcut) {\n        showInfo(.common, shortcut)\n    }\n}\n```\n\n### Warning UI\nInline warning below recorder:\n```\nKeyboard Shortcut: [⌘V        ] [Clear]\n⚠️ This shortcut is used by the system for Paste.\n   Using it may break clipboard operations.\n   [Use Anyway] [Choose Different]\n```\n\n## Files to Modify\n- Sources/OptimusClip/Views/Settings/Transformations/TransformationEditorView.swift\n- Create: Sources/OptimusClip/Services/ShortcutConflictDetector.swift\n\n## Edge Cases\n- User knowingly wants to override (advanced use) - allow with confirmation\n- Shortcut conflicts with existing transformation - show which one\n- Platform-specific shortcuts (some only on newer macOS)\n\n## Acceptance Criteria\n- Critical shortcuts are blocked\n- System shortcuts show warning\n- Internal conflicts detected\n- Common app shortcuts noted\n- User can override with confirmation\n- No false positives for safe shortcuts","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-16T16:40:14.5979-05:00","updated_at":"2025-12-16T17:14:25.405021-05:00","closed_at":"2025-12-16T17:14:25.405021-05:00","close_reason":"Completed - all tests pass, CI green","dependencies":[{"issue_id":"oc-nbd.6.1","depends_on_id":"oc-nbd.6","type":"parent-child","created_at":"2025-12-16T16:40:14.598672-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":2,"issue_id":"oc-nbd.6.1","author":"Chris Edwards","text":"Implemented keyboard shortcut conflict detection with 4 severity levels: critical (blocked), system (warn), internal (warn), and common (info). Created ShortcutConflictDetector service and integrated with TransformationEditorView to show inline warnings. Commit: d27efae","created_at":"2025-12-16T22:14:24Z"}]}
{"id":"oc-nbd.6.2","title":"Optimize accessibility permission polling","description":"# Optimize Accessibility Permission Polling\n\n## What\nReduce resource usage of accessibility permission polling by:\n1. Polling less frequently when not needed\n2. Stopping polling once permission is granted\n3. Context-aware polling rates\n\n## Why\nCurrent behavior (from PermissionsTabView comments):\n- Polls every 2 seconds for permission status\n- macOS doesn't provide notifications when permission changes\n- Permission rarely changes (once per app lifetime typically)\n\nFor a menu bar app that should be \"invisible\" in resource usage,\npolling every 2 seconds is wasteful.\n\n## Current Implementation\nAccessibilityPermissionManager polls continuously:\n- Every 2 seconds\n- Even when permission is already granted\n- Even when app is in background\n\n## Optimized Approach\n\n### 1. Stop Polling When Granted\n```swift\nclass AccessibilityPermissionManager {\n    private var pollTimer: Timer?\n    \n    func startPolling() {\n        // If already granted, no need to poll\n        if isGranted {\n            stopPolling()\n            return\n        }\n        \n        pollTimer = Timer.scheduledTimer(\n            withTimeInterval: pollInterval,\n            repeats: true\n        ) { [weak self] _ in\n            self?.checkPermission()\n        }\n    }\n    \n    private func checkPermission() {\n        let granted = AXIsProcessTrusted()\n        if granted {\n            isGranted = true\n            stopPolling()  // Stop once granted\n        }\n    }\n}\n```\n\n### 2. Context-Aware Poll Rates\n```swift\nenum PollingContext {\n    case permissionsTabVisible  // Fast: 1 second (user is waiting)\n    case settingsOpen           // Medium: 5 seconds\n    case background             // Slow: 30 seconds or stopped\n}\n\nfunc updatePollingInterval(for context: PollingContext) {\n    switch context {\n    case .permissionsTabVisible:\n        pollInterval = 1.0\n    case .settingsOpen:\n        pollInterval = 5.0\n    case .background:\n        pollInterval = 30.0  // Or stop entirely\n    }\n    restartPolling()\n}\n```\n\n### 3. On-Demand Check at Launch\n```swift\nfunc applicationDidFinishLaunching() {\n    // Check once at launch\n    if AccessibilityPermissionManager.shared.isGranted {\n        // No polling needed\n    } else {\n        // Start slow background polling\n        AccessibilityPermissionManager.shared.startSlowPolling()\n    }\n}\n```\n\n## Files to Modify\n- Sources/OptimusClip/Managers/AccessibilityPermissionManager.swift\n- Sources/OptimusClip/Views/Settings/Permissions/PermissionsTabView.swift (notify of visibility)\n\n## Resource Savings\nBefore: 2-second polls × 30 per minute × always = ~43,200 polls/day\nAfter: Check on launch + user-triggered = ~1-10 polls/day\n\n## Testing\n- Verify permission detection still works\n- Measure CPU usage before/after\n- Test edge case: permission revoked while app running\n\n## Acceptance Criteria\n- Polling stops when permission granted\n- Faster polling when Permissions tab visible\n- Slow/no polling when in background\n- Permission changes still detected\n- Measurably reduced CPU usage","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-16T16:40:31.933318-05:00","updated_at":"2025-12-16T18:45:57.856238-05:00","closed_at":"2025-12-16T18:45:57.856238-05:00","close_reason":"Implemented context-aware polling optimization. Unblocks oc-nbd.2.3.","dependencies":[{"issue_id":"oc-nbd.6.2","depends_on_id":"oc-nbd.6","type":"parent-child","created_at":"2025-12-16T16:40:31.934112-05:00","created_by":"daemon","metadata":"{}"}],"comments":[{"id":8,"issue_id":"oc-nbd.6.2","author":"Chris Edwards","text":"Completed: Implemented context-aware polling rates and auto-stop when permission granted. Reduces ~43,200 polls/day to ~1-10 for most users. CI passed.","created_at":"2025-12-16T23:45:57Z"}]}
{"id":"oc-nbd.7","title":"Add default keyboard shortcut to Format As Markdown transformation","description":"# Add Default Keyboard Shortcut to Format As Markdown\n\n## Problem\nThe default 'Format As Markdown' transformation ships with no keyboard shortcut assigned.\nThis means users can't actually USE the app until they manually configure one.\nThis is a first-run blocker - the app appears broken.\n\n## Solution\nAssign a sensible default shortcut like ⌃⌥M (Ctrl+Opt+M for 'Markdown').\n\n## Why P0 (Critical)\nWithout this, new users:\n1. Install app\n2. Try to use it\n3. Nothing happens (no shortcut)\n4. Think it's broken\n5. Uninstall\n\nThis one-line change has outsized impact on first-run experience.\nIt should be done BEFORE any other UX work since it makes the app functional.\n\n## Files to Modify\n- Sources/OptimusClip/Models/TransformationConfig.swift - update default transformation\n\n## Consideration\n- Ensure the shortcut doesn't conflict with common system shortcuts\n- ⌃⌥M is safe (not used by macOS)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T16:49:14.77894-05:00","updated_at":"2025-12-16T17:03:39.999974-05:00","closed_at":"2025-12-16T17:03:39.999974-05:00","close_reason":"Added default shortcuts ⌃⌥T and ⌃⌥M to built-in transformations","dependencies":[{"issue_id":"oc-nbd.7","depends_on_id":"oc-nbd","type":"parent-child","created_at":"2025-12-16T16:49:14.779538-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-q99","title":"(deleted)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-16T10:40:49.259028-05:00","updated_at":"2025-12-16T20:35:11.301256-05:00","closed_at":"2025-12-16T20:35:11.301256-05:00","close_reason":"Closing tombstone issues - already resolved"}
{"id":"oc-qgm","title":"Remove unnecessary nonisolated(unsafe) in ClipboardSafety","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-16T19:42:03.393445-05:00","updated_at":"2025-12-16T20:35:11.310043-05:00","closed_at":"2025-12-16T20:35:11.310043-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:44:43.938818-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-qsv","title":"Duplicate transformation trigger code in OptimusClipApp and HotkeyManager","status":"closed","priority":3,"issue_type":"chore","created_at":"2025-12-16T19:31:32.190504-05:00","updated_at":"2025-12-16T20:35:11.310695-05:00","closed_at":"2025-12-16T20:35:11.310695-05:00","close_reason":"Closing tombstone issues - already resolved","comments":[{"id":15,"issue_id":"oc-qsv","author":"Chris Edwards","text":"## Root Cause Analysis\n\nTransformationMenuItem in OptimusClipApp.swift has triggerTransformation() (lines 315-340)\nHotkeyManager.swift has handleUserTransformationHotkey() (lines 339-369)\n\nBoth methods:\n1. Check if already processing\n2. Configure pipeline based on transformation type\n3. Create LLM pipeline for LLM transformations\n4. Call flowCoordinator.handleHotkeyTrigger()\n\nBoth even have their own createLLMPipeline() methods (OptimusClipApp.swift:345, HotkeyManager.swift:377).\n\n## Impact\n- Bug fixes to one won't apply to the other\n- Behavioral inconsistencies between hotkey triggers and menu triggers\n- Maintenance burden\n\n## Recommended Fix\nExtract shared method in HotkeyManager:\n```swift\nfunc triggerTransformation(_ transformation: TransformationConfig) async\n```\nHave both call sites use this single implementation.","created_at":"2025-12-17T00:31:59Z"}],"deleted_at":"2025-12-16T19:36:00.770098-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"chore"}
{"id":"oc-t6u","title":"Cannot change hotkey in Transformations tab - recorder does nothing","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-13T17:16:57.200708-05:00","updated_at":"2025-12-13T18:26:32.226659-05:00","closed_at":"2025-12-13T18:26:32.226659-05:00"}
{"id":"oc-tmx","title":"Phase 5 - LLM Integration","description":"Phase 5: LLM Integration Epic\n\nThis epic encompasses the complete integration of LLM (Large Language Model) providers into Optimus Clip, enabling intelligent clipboard transformations beyond simple algorithmic rules.\n\n## Background \u0026 Context\nOptimus Clip is a macOS menu bar application that serves as clipboard middleware, transforming clipboard content via algorithmic rules OR LLMs. While algorithmic transformations (Phase 4) handle deterministic operations like case conversion, formatting, and text processing, LLM integration unlocks a new class of intelligent transformations:\n\n- Grammar and style corrections\n- Language translation\n- Content summarization\n- Code refactoring and explanation\n- Creative rewriting\n- Context-aware improvements\n\n## Strategic Provider Selection\nWe're integrating 5 LLM providers to serve different use cases:\n\n1. **OpenAI** (GPT-4, GPT-4o): Industry standard, highest quality general-purpose models\n2. **Anthropic** (Claude Sonnet, Opus, Haiku): Strong reasoning, long context windows, safety-focused\n3. **OpenRouter**: Unified API for 100+ models from multiple providers - flexibility and experimentation\n4. **Ollama**: Local/offline processing - privacy-first, no API costs, works offline\n5. **AWS Bedrock**: Enterprise integration - leverage existing AWS infrastructure, compliance-friendly\n\n## Technical Architecture\n- Unified abstraction layer for all providers\n- Async/await for non-blocking UI\n- Dynamic model fetching and caching\n- Comprehensive error handling and timeout management\n- Visual feedback during processing (pulse animation)\n- Secure credential storage in macOS Keychain\n\n## Success Criteria\n- All 5 providers fully functional\n- Seamless user experience with clear feedback\n- Robust error handling for network issues, rate limits, timeouts\n- Model selection and configuration working for each provider\n- Processing animation provides clear visual feedback\n- No UI blocking during LLM calls\n\nThis epic represents a major milestone in Optimus Clip's evolution from a simple clipboard utility to an intelligent content transformation tool.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-12T22:04:39.64964-05:00","updated_at":"2025-12-13T22:57:46.54027-05:00","closed_at":"2025-12-13T22:57:46.540273-05:00","dependencies":[{"issue_id":"oc-tmx","depends_on_id":"oc-j0g","type":"blocks","created_at":"2025-12-13T09:40:12.310111-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.1","title":"OpenAI Provider Integration","description":"Integrate OpenAI as an LLM provider for intelligent clipboard transformations.\n\n## Background \u0026 Importance\nOpenAI is the industry-leading LLM provider, creators of GPT (Generative Pre-trained Transformer) models. OpenAI models are widely regarded as the gold standard for general-purpose language tasks:\n- GPT-4o: Latest multimodal model, excellent reasoning and instruction following\n- GPT-4o-mini: Cost-effective, fast, good for simpler transformations\n- Strong performance on grammar correction, summarization, translation, and creative tasks\n- Widely adopted in production applications with proven reliability\n\n## Technical Implementation\n\n### Package \u0026 Dependencies\n- Use **LLMChatOpenAI** Swift package by kevinhermawan\n- Add to Package.swift dependencies\n- Supports OpenAI's Chat Completions API (v1)\n\n### Authentication \u0026 Security\n- Store API key in **macOS Keychain** (NOT in UserDefaults or plain text)\n- Keychain service name: 'com.optimusclip.openai'\n- Allow users to input/update API key in Settings UI\n- Validate key format before storing (starts with 'sk-')\n- Show masked key in UI (e.g., 'sk-...abc123')\n\n### API Specifics\n- Endpoint: https://api.openai.com/v1/chat/completions\n- Authentication: Bearer token (API key in Authorization header)\n- Request format: JSON with model, messages array, temperature, max_tokens\n- Response format: JSON with choices array containing generated text\n\n### Model Selection\nProvide dropdown in Settings with models:\n- gpt-4o (latest, most capable)\n- gpt-4o-mini (fast, cost-effective)\n- gpt-4-turbo (previous generation, still excellent)\n- gpt-3.5-turbo (fast, economical for simple tasks)\n\nModel capabilities:\n- Context window: 128k tokens (gpt-4o), 16k (gpt-3.5-turbo)\n- Support for system prompts and multi-turn conversations\n- Temperature control (0.0-2.0, default 0.7)\n\n### Error Handling\n- **Rate limits**: OpenAI enforces RPM (requests per minute) and TPM (tokens per minute) limits\n  - Catch 429 status code\n  - Show user-friendly message: 'OpenAI rate limit reached. Please wait a moment and try again.'\n- **Invalid API key**: 401 status code\n  - Message: 'Invalid OpenAI API key. Please check your API key in Settings.'\n- **Network errors**: Connection timeouts, DNS failures\n  - Message: 'Unable to connect to OpenAI. Check your internet connection.'\n- **Server errors**: 500, 502, 503 from OpenAI\n  - Message: 'OpenAI service temporarily unavailable. Try again shortly.'\n\n### Timeout Configuration\n- Default timeout: 30 seconds\n- Configurable in Settings (15s / 30s / 60s / 120s options)\n- Cancel request if timeout exceeded\n- Message: 'OpenAI request timed out. Try a shorter text or increase timeout in Settings.'\n\n### Prompt Construction\nSystem prompt + user content format:\n- system: user's configured system prompt from Settings\n- user: clipboard text content\n\n## Testing Considerations\n- Test with valid/invalid API keys\n- Test rate limit handling (make rapid requests)\n- Test with various text lengths (short, medium, very long)\n- Test timeout with slow network simulation\n- Verify API key is stored securely in Keychain\n\n## Dependencies\n- LLMChatOpenAI Swift package\n- Keychain access functionality\n- Network layer with timeout support","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:18.654266-05:00","updated_at":"2025-12-13T19:04:46.737051-05:00","closed_at":"2025-12-13T19:04:46.737051-05:00","dependencies":[{"issue_id":"oc-tmx.1","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:05:18.654921-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.1","depends_on_id":"oc-j0g","type":"blocks","created_at":"2025-12-13T09:36:20.57321-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.10","title":"LLM Error Handling","description":"Comprehensive error handling for LLM transformations with user-friendly notifications and clipboard protection.\n\n## BACKGROUND \u0026 CONTEXT\nLLM APIs fail in multiple ways: network errors, auth failures, rate limits, server errors, timeouts, content filters, invalid responses. Each provider has different error formats. Without proper handling users experience mysterious failures, corrupted clipboard, and frustration. Core principle: On ANY error clipboard remains unchanged and user receives actionable notification.\n\n## REAL-WORLD PROBLEM/USE CASE\nUser copies sensitive document, triggers transformation, API key expired (401). Without error handling: Clipboard wiped, document lost. With error handling: Notification \"Invalid API key. Check Settings\", clipboard unchanged, Settings button opens directly to API key field. User updates key, retries, succeeds.\n\nRate limit scenario: 20 rapid transformations, OpenAI returns 429 after 15th. Clear notification \"Rate limit reached. Wait 60 seconds\", clipboard preserved, guidance provided.\n\n## TECHNICAL IMPLEMENTATION DETAILS\n\n### Error Categories \u0026 Messages\nNetwork errors: \"Unable to connect to [Provider]. Check internet.\" Timeout: \"Request timed out. Try shorter text or increase timeout in Settings.\" Rate limits: \"[Provider] rate limit reached. Wait and try again\" (include retry-after if available). Invalid API key (401): \"Invalid [Provider] API key. Check Settings.\" Server errors (500+): \"[Provider] temporarily unavailable. Try shortly.\" Model unavailable (404): \"Model unavailable. Select different model.\" Content filter: \"Content rejected by [Provider] safety filters.\" Configuration: \"Configure [Provider] in Settings first.\" Insufficient credits (402): \"Insufficient credits. Add at provider website.\" Invalid response: \"[Provider] returned invalid response. Try again.\"\n\n### Notification System\nmacOS User Notification: Title \"Optimus Clip - Transformation Failed\", specific error body, action buttons (Settings, Retry, Learn More), subtle beep, 30s auto-dismiss. In-app alternative: Toast banner if notifications disabled, color-coded red, 5s auto-dismiss. Deduplication: Collapse identical errors within 60 seconds to prevent spam.\n\n### Clipboard Protection\nNEVER modify clipboard on error. Original content always preserved. Verification after error. Rollback if somehow modified (restore from memory backup). State reset: stop animation, reset to idle, clear temp data, release resources.\n\n### Error Context\nLLMError struct with type, provider, model, timestamp, requestID. Types: network, timeout, rateLimit, authentication, server, modelNotAvailable, contentFilter, configuration, insufficientCredits, invalidResponse. Includes user-friendly errorDescription and recoverySuggestion.\n\n### Error Prevention\nPre-flight checks: Validate API key format, check connectivity, verify model selection, confirm text size not exceeding limits. Defensive validation before API call. Early warnings for very long text.\n\n### Logging \u0026 Debugging\nLog: Timestamp, provider, model, error type, metadata (text length not content), response details. NEVER log: Clipboard content, full API keys (last 4 chars only), secrets. Debug mode: Verbose logging when enabled by user. Error aggregation: Track counts by type/provider for patterns.\n\n## ARCHITECTURAL CONNECTIONS\nIntegrates with TransformationEngine (catches errors), LLMProviderProtocol (throws typed errors), NotificationManager (displays), ClipboardManager (preserves content), SettingsView (actions), Logger (records), AnalyticsManager (tracks). Error flow: Provider throws -\u003e Engine catches -\u003e Notification shown -\u003e Clipboard verified -\u003e Logged -\u003e UI reset.\n\n## EDGE CASES \u0026 GOTCHAS\nNotification while another showing: Queue or replace. Error during cancellation: Prefer cancellation state. Error after success but before clipboard update: Treat as failure. Clipboard modified externally: Detect and warn. Notification permission denied: Fall back to in-app toasts. Multiple rapid errors: Deduplicate with count. Provider-specific error formats: Parse carefully, generic fallback.\n\n## TESTING REQUIREMENTS\nMock providers for each error type, verify correct notification, verify clipboard unchanged. Network conditions: offline, slow, unstable, DNS failure. Provider scenarios: invalid key, expired, no credits, model not enabled, service down. Clipboard protection: Verify unchanged after every error type. User testing: Verify messages clear and actionable.\n\n## SUCCESS CRITERIA\nMust work: All error categories handled, clipboard NEVER modified, notifications actionable, buttons work, logging captures info, no crashes, deduplication works. Should work: Retry button, countdown timers, error counts, pre-flight checks, help links. Nice to have: Smart retry, analytics dashboard, error history.\n\n## CONFIGURATION OPTIONS\nSettings: Enable system notifications (default on), enable in-app toasts (on), notification sound (on), auto-dismiss duration (30s), error logging level (error), debug mode (off). User controls logging verbosity.\n\n## SECURITY/PERFORMANCE CONSIDERATIONS\nSecurity: Never log sensitive data, sanitize error messages, validate responses, rate limit notifications. Performance: Minimal overhead \u003c1ms, async logging, deduplication, efficient propagation. Privacy: No telemetry, logs local only, content never logged. Reliability: Graceful degradation, clipboard rollback, defensive state reset.\n\n## DEPENDENCIES\nSystem: Foundation (URLError), AppKit (NSUserNotification), Swift (Error protocol). Internal: TransformationEngine, LLMProviderProtocol, NotificationManager, ClipboardManager, SettingsView, Logger, AnalyticsManager. Native Swift error handling.","notes":"Added mapping coverage for provider errors, ensured new tests cover auth/rate-limit/timeout/network/server/invalid-response mapping, ran make check-test.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:10:15.0141-05:00","updated_at":"2025-12-13T22:36:18.749661-05:00","closed_at":"2025-12-13T22:36:18.749661-05:00","dependencies":[{"issue_id":"oc-tmx.10","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:10:15.014744-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.10","depends_on_id":"oc-tmx.8","type":"blocks","created_at":"2025-12-12T23:54:11.515855-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.11","title":"Phase 5 Verification","description":"End-to-end verification that Phase 5 LLM Integration is complete, working correctly, and ready for production use.\n\n## BACKGROUND \u0026 CONTEXT\nPhase 5 represents the core value proposition of Optimus Clip: intelligent LLM-powered clipboard transformations. This is the most complex phase integrating multiple providers, async execution, error handling, and UI feedback. Comprehensive verification ensures: All 5 providers work correctly, error scenarios handled gracefully, UI responsive during operations, clipboard data protected, no regressions from earlier phases. Without thorough verification users experience crashes, data loss, confusing errors, poor performance. This checklist provides systematic validation covering happy paths, error scenarios, performance, integration, and edge cases.\n\n## REAL-WORLD PROBLEM/USE CASE\nDeveloper completes Phase 5 implementation. Without verification: Ships with OpenAI working but Bedrock broken, rate limit handling crashes app, clipboard corrupted on timeout. Users post negative reviews, data lost. With verification: Systematic testing reveals Bedrock authentication bug (fixed), rate limit crash (fixed), clipboard protection verified. Ships confidently, users have smooth experience.\n\nQA scenario: Tester follows checklist, finds animation doesn't stop on Ollama error. Developer fixes, re-tests, verification passes. Release quality high.\n\n## TECHNICAL IMPLEMENTATION DETAILS\n\n### Verification Checklist Structure\n10 major categories with specific testable criteria: Provider Configuration, Model Selection, LLM Transformations Execute, Async Execution \u0026 UI, Timeout Handling, Error Handling \u0026 Notifications, Processing Animation, Provider-Specific Features, Prompt Construction, Integration \u0026 Workflow. Each category has checkboxes for pass/fail with clear acceptance criteria.\n\n### Testing Approach\nUnit tests: Automated tests for individual components. Integration tests: Real API calls with providers. Manual tests: Human verification of UI/UX. Performance tests: Load, stress, responsiveness testing. Edge case tests: Unusual scenarios, error conditions, race conditions.\n\n### Provider Configuration Checklist\nVerify: OpenAI API key configurable and masked in UI. Anthropic API key configurable and masked. OpenRouter API key configurable and masked. Ollama endpoint configurable with test button. Bedrock credentials configurable (profile or explicit). All API keys stored in macOS Keychain (verify with Keychain Access.app). Keys displayed masked (sk-...abc). Can update/change keys. Ollama test connection button works and shows result.\n\n### Model Selection Checklist  \nVerify: OpenAI dropdown populated with gpt-4o, gpt-4o-mini, etc. Anthropic dropdown with Claude Sonnet, Haiku, Opus. OpenRouter dynamic list fetched and grouped by provider. Ollama list shows locally installed models. Bedrock list appropriate for selected region. Model cache refreshes (24hr cloud, on-demand Ollama). Manual refresh button works. Fallback to cached models on fetch failure.\n\n### LLM Transformations Execute Checklist\nVerify: OpenAI transformation completes and updates clipboard. Anthropic transformation completes and updates clipboard. OpenRouter transformation completes and updates clipboard. Ollama transformation completes if configured. Bedrock transformation completes if configured. Transformed text pastes correctly to active app (test in TextEdit). Original clipboard preserved on error (critical).\n\n### Async Execution \u0026 UI Responsiveness\nVerify: UI responsive during LLM processing (can click menu items). Processing animation (pulse) starts when call begins. Animation stops when call completes. Status text shows \"Processing with [Provider]...\". Can cancel mid-processing with ESC or button. Cancellation stops animation and shows message. App doesn't freeze or hang during processing (test with long transformation 30s+).\n\n### Timeout Handling Checklist\nVerify: Transformation times out after configured duration (default 30s for cloud, 60s for Ollama). Timeout shows user notification with message. Clipboard unchanged on timeout (original text preserved). No paste action on timeout. Can configure timeout in Settings (15s/30s/60s/120s options). Longer timeout works for Ollama (slower local inference).\n\n### Error Handling \u0026 Notifications Checklist\nVerify: Invalid API key shows \"Invalid API key\" notification (test with wrong key). Network error shows \"Unable to connect\" (test airplane mode). Rate limit shows \"Rate limit reached\" (test rapid requests). Server error shows \"Service unavailable\" (mock 500 response). Model unavailable shows appropriate message (test deprecated model). Ollama not running shows \"Ollama not detected\" (test with Ollama stopped). All notifications user-friendly and actionable. Settings button in notification opens correct Settings tab. Clipboard never modified on ANY error (test all error types). No paste action on ANY error (verify in TextEdit).\n\n### Processing Animation Checklist\nVerify: Menu bar icon pulses during LLM processing (visual inspection). Pulse animation smooth and non-distracting. Animation stops immediately on completion. Animation stops immediately on error. Animation stops immediately on cancellation. Works correctly with Reduce Motion enabled (test System Settings \u003e Accessibility \u003e Display \u003e Reduce Motion - should show color change not pulse). VoiceOver announces processing status (test with VoiceOver enabled).\n\n### Provider-Specific Features Checklist\nVerify: OpenRouter shows model pricing/context length in dropdown. OpenRouter groups models by provider (Anthropic, OpenAI, Google, etc.). Ollama Test Connection button shows status and model count. Ollama shows setup instructions for new users. Bedrock region selection updates available models. Bedrock profile selection works (test with ~/.aws/credentials profiles). Bedrock explicit credentials option works (test manual key entry).\n\n### Prompt Construction Checklist\nVerify: System prompt from Settings included in API call (check logs or network inspector). Clipboard text included as user message. OpenAI format correct (system + user messages array). Anthropic format correct (separate system parameter, not in messages). Bedrock format correct (wrapped in provider-specific format). Temperature and max_tokens configured correctly (check request payload).\n\n### Integration \u0026 Workflow Checklist\nVerify: LLM rule can be created in rule editor (Settings \u003e Transformations). LLM rule executes on clipboard copy if configured. Can manually trigger LLM transformation with hotkey. Multiple LLM rules work sequentially (test 2+ rules). LLM transformation integrates with existing rule engine. Can switch between algorithmic and LLM rules seamlessly. No interference with earlier Phase 0-4 features (menu bar, hotkeys, clipboard monitoring, algorithmic transforms).\n\n## TESTING SCENARIOS\n\n### Basic Happy Path\nTest: Configure OpenAI with valid API key. Select gpt-4o-mini model. Create LLM rule with system prompt: \"Fix grammar and spelling\". Copy text with errors: \"this are a test\". Verify: Transformation completes in \u003c10s, clipboard updated to \"This is a test\", text pastes to TextEdit, processing animation showed during operation.\n\n### Error Scenarios\nTest: Configure with invalid API key -\u003e verify error notification shows, clipboard unchanged. Disconnect internet -\u003e verify network error notification, clipboard unchanged. Use very long text (\u003e10000 chars) -\u003e verify timeout handling or success. Make rapid requests (10 in 10s) -\u003e verify rate limit notification. Select unavailable model -\u003e verify model error notification.\n\n### Performance Testing\nTest: Transform short text (10 words) -\u003e should complete \u003c5s. Transform medium text (100 words) -\u003e should complete \u003c15s. Transform long text (1000 words) -\u003e should handle gracefully \u003c30s. Verify UI responsive during all transformations (Instruments Time Profiler shows main thread not blocked). No memory leaks after 100 transformations (Instruments Leaks tool).\n\n### Provider Comparison\nTest: Same transformation \"Fix grammar: the dog are running\" with all 5 providers. Compare response quality (all should correct to \"is\"). Compare response times (OpenAI fastest ~3s, Bedrock slower ~10s, Ollama variable). Verify all providers handle task correctly.\n\n### Edge Cases\nTest: Cancel transformation mid-processing -\u003e verify stops immediately, clipboard unchanged. Quit app during transformation -\u003e verify clean exit, no crash on relaunch. System sleep during transformation -\u003e verify cancel on wake or resume correctly. Change provider/model during transformation -\u003e verify current transformation completes with original provider. Empty clipboard -\u003e verify no crash, error or silent skip. Binary content in clipboard (image) -\u003e verify not processed, original preserved. Very large clipboard (\u003e100KB text) -\u003e verify handled or warning shown.\n\n## ARCHITECTURAL CONNECTIONS\nVerification ensures all components integrate correctly: TransformationEngine triggers LLM providers. LLM providers call correct APIs with correct formats. AsyncExecutionEngine runs non-blocking. AnimationManager shows visual feedback. ErrorHandler catches and displays all error types. ClipboardManager preserves data on errors. NotificationManager displays user messages. SettingsView configures all options correctly. HotkeyManager triggers transformations. All phases 0-4 still work (no regressions).\n\n## EDGE CASES \u0026 GOTCHAS\nIncomplete testing: Missing one provider breaks user experience. Skipping error tests: Crashes in production on rate limits. No performance tests: App ships with UI freezing. Ignoring edge cases: Data loss on system sleep. Not testing regressions: Phase 3 hotkeys broken after Phase 5 changes. False positives: Marking passed without actually verifying (use rigorous criteria).\n\n## TESTING REQUIREMENTS\n\n### Automated Tests\nUnit tests: Mock provider responses for all error types. Test prompt construction formats. Test timeout logic. Test clipboard protection. Test state transitions. Integration tests: Real API calls (requires test credentials). Test network timeout handling. Test cache behavior.\n\n### Manual Tests\nVisual inspection: Processing animation smooth, notification messages clear. Functional: Every checkbox in checklist verified by human tester. Usability: User guide followed by non-developer. Accessibility: VoiceOver, Reduce Motion, keyboard navigation.\n\n### Performance Tests\nInstruments Time Profiler: Verify main thread not blocked during transformations. Instruments Leaks: No memory leaks after 100 transformations. Instruments Network: Verify API calls formatted correctly. System monitor: CPU \u003c5% during idle, \u003c20% during transformation.\n\n### Documentation Tests\nUser guide walkthrough: Can a new user configure each provider following docs? Error documentation: Is each error message documented with resolution? API documentation: Are all provider-specific requirements documented?\n\n## SUCCESS CRITERIA\n\n### Must Pass (Blocking)\nAll 5 providers configured and execute transformations successfully. All 10 error scenarios handled gracefully with notifications. UI responsive during all operations (main thread never blocked). Processing animation provides clear feedback. Timeout handling works correctly for all providers. Clipboard NEVER corrupted or lost on errors. No crashes or hangs in any scenario including edge cases. All checkboxes in 10 categories marked pass.\n\n### Should Pass (High Priority)\nResponse times acceptable: \u003c5s for short text, \u003c15s for medium, \u003c30s for long. Error messages clear and actionable with helpful guidance. Settings UI intuitive, can configure without documentation. Model selection dropdown well-organized. Multiple transformations queue smoothly. VoiceOver fully functional for accessibility.\n\n### Nice to Have (Low Priority)\nOllama setup instructions helpful for new users. OpenRouter model metadata (pricing, context) displayed usefully. Performance exceptional: \u003c3s for most transformations. Advanced features work: streaming, token tracking (if implemented).\n\n## CONFIGURATION OPTIONS\nSettings for verification environment: Test mode toggle (uses mock providers for automated tests). Debug logging enabled (verbose output for verification). Performance monitoring enabled (timing data logged). Test API keys configured (separate from production keys). Validation mode (extra checks and assertions during testing).\n\nDefaults for testing: Test mode off (use real APIs), debug logging on, performance monitoring on, test keys in separate config file, validation mode on during QA.\n\n## SECURITY/PERFORMANCE CONSIDERATIONS\n\n### Security Verification\nAPI keys stored in Keychain (verify with Keychain Access.app, search \"optimusclip\"). Keys never logged in plain text (check logs, only last 4 chars appear). Credentials encrypted at rest. Network traffic HTTPS only (verified with network inspector). No telemetry sent without consent. Privacy policy clear about data handling.\n\n### Performance Verification\nMain thread never blocked (Instruments Time Profiler shows 0% time in blocking calls during transformations). Memory stable (Instruments Allocations shows no growth over 100 transformations). Network efficient (connection pooling verified, no redundant requests). Battery impact minimal (\u003c1% per hour active use). App responsive \u003c100ms for all UI interactions.\n\n### Reliability Verification\nGraceful degradation on errors (no crashes, fallbacks work). Clipboard rollback mechanism tested (modify during error, verify restored). State consistency (no stuck states, always returns to idle). Resource cleanup (no leaked network connections, memory freed after operations). Crash logs reviewed (no unreported crashes during testing).\n\n## DEPENDENCIES\nTesting tools: Xcode (Test runner, Instruments), Network Link Conditioner (simulate slow/offline), Accessibility Inspector (VoiceOver testing), Keychain Access (verify secure storage), Console.app (log inspection). Test APIs: OpenAI test account, Anthropic test account, OpenRouter test account, Ollama local instance, AWS test account. CI/CD: GitHub Actions for automated tests, test matrix (macOS 14/15, Intel/Apple Silicon). Documentation: User guide, API docs, troubleshooting guide, release notes.\n\n## SIGN-OFF REQUIREMENTS\nBefore marking Phase 5 complete: All providers tested with valid credentials by at least 2 people. All error scenarios tested and handled correctly documented. Performance acceptable for typical use cases verified with metrics. No critical bugs or crashes in testing (P0 issues). User guide reviewed by non-developer and confirmed clear. Accessibility checklist completed (VoiceOver, keyboard, Reduce Motion). Security audit passed (keys stored securely, no data leaks). Regression testing passed (Phases 0-4 still work). Code review completed by 2+ engineers. Sign-off from: Lead developer, QA engineer, Product manager, UX designer (for animations/notifications).","notes":"Added Phase 5 automated verification for LLMTransformation in TransformationTests (request parameter forwarding + notConfigured mapping). Ran make check-test.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:10:49.797827-05:00","updated_at":"2025-12-13T22:48:25.555782-05:00","closed_at":"2025-12-13T22:48:25.555782-05:00","dependencies":[{"issue_id":"oc-tmx.11","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:10:49.798449-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.11","depends_on_id":"oc-tmx.9","type":"blocks","created_at":"2025-12-12T23:54:16.57279-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.11","depends_on_id":"oc-tmx.10","type":"blocks","created_at":"2025-12-12T23:54:16.683919-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.11","depends_on_id":"oc-tmx.1","type":"blocks","created_at":"2025-12-13T12:53:03.667584-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.11","depends_on_id":"oc-tmx.2","type":"blocks","created_at":"2025-12-13T12:53:04.045913-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.11","depends_on_id":"oc-tmx.3","type":"blocks","created_at":"2025-12-13T12:53:04.429562-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.11","depends_on_id":"oc-tmx.4","type":"blocks","created_at":"2025-12-13T12:53:04.840669-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.11","depends_on_id":"oc-tmx.5","type":"blocks","created_at":"2025-12-13T12:53:05.253777-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.2","title":"Anthropic Provider Integration","description":"## Task: Anthropic Provider Integration\n\n### Background \u0026 Strategic Value\n\nAnthropic's Claude models are arguably the most capable LLMs for text transformation tasks. Claude excels at:\n- Understanding nuanced instructions\n- Maintaining formatting while improving content\n- Following complex multi-step instructions\n- Providing consistent, high-quality outputs\n\n**Why Include Anthropic:**\n- Claude models are consistently top-ranked for text quality\n- Strong instruction-following makes them ideal for transformation prompts\n- Different strengths than OpenAI (complementary, not redundant)\n- Many power users already have Anthropic API keys\n\n### Technical Implementation\n\n**Package Dependency:**\n```swift\n// Package.swift\ndependencies: [\n    .package(url: \"https://github.com/kevinhermawan/swift-llm-chat-anthropic\", from: \"1.0.0\"),\n]\n\n// Target dependencies\n.target(\n    name: \"OptimusClip\",\n    dependencies: [\n        .product(name: \"LLMChatAnthropic\", package: \"swift-llm-chat-anthropic\"),\n    ]\n)\n```\n\n### API Details\n\n**Endpoint:** `https://api.anthropic.com/v1/messages`\n\n**Authentication:**\n- Header: `x-api-key: \u003cAPI_KEY\u003e`\n- Header: `anthropic-version: 2023-06-01` (required)\n\n**Request Format:**\n```json\n{\n    \"model\": \"claude-3-haiku-20240307\",\n    \"max_tokens\": 4096,\n    \"messages\": [\n        {\"role\": \"user\", \"content\": \"Transform this text: ...\"}\n    ],\n    \"system\": \"You are a text transformation assistant...\"\n}\n```\n\n**Key Differences from OpenAI:**\n1. System prompt is a top-level field, not a message\n2. Uses `x-api-key` header, not `Authorization: Bearer`\n3. `anthropic-version` header is required\n4. Different model naming convention\n\n### Available Models\n\n| Model | Use Case | Context | Speed |\n|-------|----------|---------|-------|\n| claude-3-opus-20240229 | Complex reasoning | 200K | Slow |\n| claude-3-sonnet-20240229 | Balanced | 200K | Medium |\n| claude-3-haiku-20240307 | Fast \u0026 cheap | 200K | Fast |\n| claude-3-5-sonnet-20241022 | Latest, best | 200K | Medium |\n\n**Recommendation:**\n- Default: `claude-3-haiku-20240307` (fast, cheap, good enough for most transforms)\n- Power users: `claude-3-5-sonnet-20241022` (best quality)\n\n### Implementation\n\n```swift\nimport LLMChatAnthropic\n\nfinal class AnthropicProvider: LLMProvider {\n    private let apiKey: String\n    private let client: LLMChatAnthropic\n\n    init(apiKey: String) {\n        self.apiKey = apiKey\n        self.client = LLMChatAnthropic(apiKey: apiKey)\n    }\n\n    func transform(\n        input: String,\n        systemPrompt: String,\n        model: String\n    ) async throws -\u003e String {\n        let messages = [\n            ChatMessage(role: .user, content: input)\n        ]\n\n        let response = try await client.send(\n            model: model,\n            messages: messages,\n            system: systemPrompt,\n            maxTokens: 4096\n        )\n\n        guard let content = response.content.first?.text else {\n            throw TransformationError.providerError(message: \"Empty response from Claude\")\n        }\n\n        return content\n    }\n}\n```\n\n### Error Handling\n\n**Anthropic-Specific Errors:**\n\n| HTTP Status | Meaning | User Message |\n|-------------|---------|--------------|\n| 401 | Invalid API key | \"Invalid Anthropic API key. Please check Settings.\" |\n| 400 | Bad request | \"Invalid request. Try shorter text.\" |\n| 429 | Rate limit | \"Anthropic rate limit. Please wait.\" |\n| 500+ | Server error | \"Anthropic service unavailable.\" |\n| 529 | Overloaded | \"Anthropic is overloaded. Try again shortly.\" |\n\n**Overload Handling (529):**\nAnthropic returns 529 when their servers are overloaded. Unlike rate limits (429), this indicates temporary capacity issues:\n```swift\nif response.statusCode == 529 {\n    throw TransformationError.providerError(\n        message: \"Anthropic servers are temporarily overloaded. Try again in a few minutes.\"\n    )\n}\n```\n\n### Keychain Integration\n\n**Service Name:** `com.optimusclip.anthropic`\n\n```swift\nstruct AnthropicKeychain {\n    private let service = \"com.optimusclip.anthropic\"\n\n    func saveKey(_ key: String) throws {\n        try KeychainWrapper.shared.save(key, service: service)\n    }\n\n    func loadKey() throws -\u003e String? {\n        try KeychainWrapper.shared.load(service: service)\n    }\n\n    func deleteKey() throws {\n        try KeychainWrapper.shared.delete(service: service)\n    }\n}\n```\n\n### Settings UI Integration\n\n```swift\nstruct AnthropicSettingsSection: View {\n    @State private var apiKey: String = \"\"\n    @State private var isKeyVisible: Bool = false\n    @State private var connectionStatus: ConnectionStatus = .unknown\n\n    var body: some View {\n        Section(\"Anthropic (Claude)\") {\n            // API Key input\n            HStack {\n                if isKeyVisible {\n                    TextField(\"API Key\", text: $apiKey)\n                        .textFieldStyle(.roundedBorder)\n                } else {\n                    SecureField(\"API Key\", text: $apiKey)\n                        .textFieldStyle(.roundedBorder)\n                }\n                Button(action: { isKeyVisible.toggle() }) {\n                    Image(systemName: isKeyVisible ? \"eye.slash\" : \"eye\")\n                }\n            }\n\n            // Status indicator\n            HStack {\n                Circle()\n                    .fill(connectionStatus.color)\n                    .frame(width: 8, height: 8)\n                Text(connectionStatus.description)\n                    .foregroundColor(.secondary)\n            }\n\n            // Test connection button\n            Button(\"Test Connection\") {\n                Task { await testConnection() }\n            }\n        }\n    }\n\n    private func testConnection() async {\n        // Make a minimal API call to verify key\n    }\n}\n```\n\n### Model Fetching\n\nUnlike OpenAI, Anthropic doesn't have a models endpoint. We hardcode the available models:\n\n```swift\nstruct AnthropicModels {\n    static let available: [ModelInfo] = [\n        ModelInfo(\n            id: \"claude-3-5-sonnet-20241022\",\n            name: \"Claude 3.5 Sonnet (Latest)\",\n            description: \"Best quality, moderate speed\"\n        ),\n        ModelInfo(\n            id: \"claude-3-haiku-20240307\",\n            name: \"Claude 3 Haiku\",\n            description: \"Fastest, most economical\"\n        ),\n        ModelInfo(\n            id: \"claude-3-sonnet-20240229\",\n            name: \"Claude 3 Sonnet\",\n            description: \"Balanced performance\"\n        ),\n        ModelInfo(\n            id: \"claude-3-opus-20240229\",\n            name: \"Claude 3 Opus\",\n            description: \"Most capable, slowest\"\n        ),\n    ]\n}\n```\n\n### Testing Checklist\n\n- [ ] API key validation (format: `sk-ant-...`)\n- [ ] Successful transformation with valid key\n- [ ] Error handling for invalid key (401)\n- [ ] Rate limit handling (429)\n- [ ] Overload handling (529)\n- [ ] Timeout behavior (30s default)\n- [ ] Key stored securely in Keychain\n- [ ] Model selection UI works\n- [ ] Connection test button works\n\n### Success Criteria\n- [ ] All Claude models accessible\n- [ ] API key securely stored in Keychain\n- [ ] Transformations complete successfully\n- [ ] Errors handled gracefully with clear messages\n- [ ] Settings UI functional and intuitive","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:05:40.071535-05:00","updated_at":"2025-12-13T19:15:14.086824-05:00","closed_at":"2025-12-13T19:15:14.086824-05:00","dependencies":[{"issue_id":"oc-tmx.2","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:05:40.072112-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.2","depends_on_id":"oc-j0g","type":"blocks","created_at":"2025-12-13T09:40:33.449917-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.3","title":"OpenRouter Provider Integration","description":"## Task: OpenRouter Provider Integration\n\n### Background \u0026 Strategic Value\n\nOpenRouter is a unified API gateway that provides access to 100+ AI models from multiple providers through a single, OpenAI-compatible API. It solves the \"which model should I use?\" problem by letting users experiment with different models without managing multiple API keys.\n\n**Why OpenRouter Matters for Optimus Clip:**\n\n1. **Model Diversity**: Access GPT-4, Claude, Llama, Mistral, Gemini, and more - all with one API key\n2. **Cost Optimization**: Users can choose cheaper models for simple tasks, premium models for complex ones\n3. **Future Proofing**: New models appear on OpenRouter before we could implement direct integrations\n4. **Fallback Strategy**: If OpenAI is down, user can route to Anthropic via OpenRouter\n5. **Discovery**: Users can explore models they've never heard of\n\n### Real-World Use Case\n\n**Scenario: Power User with Diverse Needs**\n\nSarah uses Optimus Clip for different workflows:\n- Quick text cleanup: Uses `mistralai/mistral-tiny` ($0.25/M tokens) - fast and cheap\n- Code formatting: Uses `anthropic/claude-3-haiku` ($0.25/M input) - good with code\n- Complex rewrites: Uses `anthropic/claude-3.5-sonnet` ($3/M input) - highest quality\n\nWith OpenRouter, Sarah manages ONE API key and switches models per-transformation. Without it, she'd need accounts with Mistral, Anthropic, OpenAI, etc.\n\n### Technical Implementation\n\n**Package \u0026 Dependencies:**\n- Use existing **LLMChatOpenAI** Swift package (OpenAI-compatible)\n- Simply change the base URL to OpenRouter's endpoint\n- No additional packages needed\n\n**Base URL Configuration:**\n```swift\nlet baseURL = \"https://openrouter.ai/api/v1\"\n```\n\n**API Compatibility:**\nOpenRouter implements the OpenAI API spec, so our existing OpenAI integration pattern works:\n- Same request format (chat completions)\n- Same authentication (Bearer token)\n- Same response format\n\n**Key Differences from Direct OpenAI:**\n1. Model IDs include provider prefix: `anthropic/claude-3-haiku` not just `claude-3-haiku`\n2. Some models have different context windows\n3. Pricing varies by model (shown in model list)\n\n### Dynamic Model Fetching\n\n**Why Dynamic Fetching is Critical:**\n- OpenRouter adds new models weekly\n- Hard-coded list would be outdated within days\n- Users expect to see the latest models\n\n**Models Endpoint:**\n```\nGET https://openrouter.ai/api/v1/models\n```\n\n**Response Structure:**\n```json\n{\n  \"data\": [\n    {\n      \"id\": \"anthropic/claude-3.5-sonnet\",\n      \"name\": \"Claude 3.5 Sonnet\",\n      \"description\": \"Most intelligent model from Anthropic\",\n      \"context_length\": 200000,\n      \"pricing\": {\n        \"prompt\": \"0.000003\",\n        \"completion\": \"0.000015\"\n      },\n      \"top_provider\": {\n        \"is_moderated\": true\n      }\n    }\n  ]\n}\n```\n\n**Implementation:**\n```swift\nstruct OpenRouterModel: Codable, Identifiable {\n    let id: String\n    let name: String\n    let description: String?\n    let contextLength: Int\n    let pricing: Pricing\n\n    struct Pricing: Codable {\n        let prompt: String  // Cost per token as string\n        let completion: String\n    }\n\n    var promptPricePerMillion: Double {\n        (Double(pricing.prompt) ?? 0) * 1_000_000\n    }\n\n    var displayPrice: String {\n        \"$\\(String(format: \"%.2f\", promptPricePerMillion))/M input\"\n    }\n}\n\nclass OpenRouterModelFetcher {\n    private let apiKey: String\n    private var cachedModels: [OpenRouterModel] = []\n    private var lastFetch: Date?\n    private let cacheExpiry: TimeInterval = 24 * 60 * 60 // 24 hours\n\n    func fetchModels() async throws -\u003e [OpenRouterModel] {\n        // Return cache if fresh\n        if let lastFetch = lastFetch,\n           Date().timeIntervalSince(lastFetch) \u003c cacheExpiry,\n           !cachedModels.isEmpty {\n            return cachedModels\n        }\n\n        // Fetch fresh list\n        var request = URLRequest(url: URL(string: \"https://openrouter.ai/api/v1/models\")!)\n        request.setValue(\"Bearer \\(apiKey)\", forHTTPHeaderField: \"Authorization\")\n\n        let (data, _) = try await URLSession.shared.data(for: request)\n        let response = try JSONDecoder().decode(ModelsResponse.self, from: data)\n\n        cachedModels = response.data\n        lastFetch = Date()\n\n        return cachedModels\n    }\n}\n```\n\n### Caching Strategy\n\n**Why Cache?**\n- Reduce API calls (good citizenship)\n- Faster Settings UI load\n- Works offline (with cached data)\n- Prevents rate limiting\n\n**Cache Implementation:**\n```swift\nclass OpenRouterModelCache {\n    private let defaults = UserDefaults.standard\n    private let modelsKey = \"openrouter_cached_models\"\n    private let timestampKey = \"openrouter_cache_timestamp\"\n    private let expirySeconds: TimeInterval = 86400 // 24 hours\n\n    func getCachedModels() -\u003e [OpenRouterModel]? {\n        guard let timestamp = defaults.object(forKey: timestampKey) as? Date,\n              Date().timeIntervalSince(timestamp) \u003c expirySeconds,\n              let data = defaults.data(forKey: modelsKey),\n              let models = try? JSONDecoder().decode([OpenRouterModel].self, from: data)\n        else {\n            return nil\n        }\n        return models\n    }\n\n    func cacheModels(_ models: [OpenRouterModel]) {\n        if let data = try? JSONEncoder().encode(models) {\n            defaults.set(data, forKey: modelsKey)\n            defaults.set(Date(), forKey: timestampKey)\n        }\n    }\n}\n```\n\n### Error Handling\n\n| HTTP Status | Meaning | User Message |\n|-------------|---------|--------------|\n| 401 | Invalid API key | \"Invalid OpenRouter API key. Get one at openrouter.ai\" |\n| 402 | Insufficient credits | \"OpenRouter credits depleted. Add credits at openrouter.ai/credits\" |\n| 404 | Model not found | \"Model no longer available. Select a different model.\" |\n| 429 | Rate limited | \"Rate limit reached. Please wait a moment.\" |\n| 500+ | Server error | \"OpenRouter service temporarily unavailable.\" |\n\n**Special: Model Deprecation**\nOpenRouter may deprecate models. Handle 404 gracefully:\n```swift\nif response.statusCode == 404 {\n    // Refresh model list - user's selected model may be gone\n    await refreshModelList()\n    throw OpenRouterError.modelNotFound(modelId)\n}\n```\n\n### Settings UI\n\n```swift\nstruct OpenRouterProviderSection: View {\n    @AppStorage(\"openrouter_api_key\") private var apiKey = \"\"\n    @State private var models: [OpenRouterModel] = []\n    @State private var isLoading = false\n    @State private var validationState: ValidationState = .idle\n\n    var body: some View {\n        Section(\"OpenRouter\") {\n            // API Key\n            SecureField(\"API Key\", text: $apiKey)\n                .textFieldStyle(.roundedBorder)\n\n            // Validate button with status\n            HStack {\n                Button(\"Validate\") {\n                    Task { await validateAndFetchModels() }\n                }\n                .disabled(apiKey.isEmpty || isLoading)\n\n                Spacer()\n\n                ValidationIndicator(state: validationState)\n            }\n\n            // Model count (when validated)\n            if case .success(let count) = validationState {\n                Text(\"\\(count) models available\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n\n            // Help text\n            Link(\"Get API key at openrouter.ai\", destination: URL(string: \"https://openrouter.ai/keys\")!)\n                .font(.caption)\n        }\n    }\n\n    private func validateAndFetchModels() async {\n        isLoading = true\n        validationState = .validating\n\n        do {\n            let fetcher = OpenRouterModelFetcher(apiKey: apiKey)\n            models = try await fetcher.fetchModels()\n            validationState = .success(modelCount: models.count)\n        } catch {\n            validationState = .failure(message: error.localizedDescription)\n        }\n\n        isLoading = false\n    }\n}\n```\n\n### Model Selection UI\n\n**Grouping by Provider:**\n```swift\nvar modelsByProvider: [String: [OpenRouterModel]] {\n    Dictionary(grouping: models) { model in\n        model.id.components(separatedBy: \"/\").first ?? \"Other\"\n    }\n}\n\n// In UI\nForEach(modelsByProvider.keys.sorted(), id: \\.self) { provider in\n    Section(provider.capitalized) {\n        ForEach(modelsByProvider[provider]!) { model in\n            ModelRow(model: model)\n        }\n    }\n}\n```\n\n**Model Row Display:**\n```swift\nstruct ModelRow: View {\n    let model: OpenRouterModel\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 2) {\n            Text(model.name)\n                .font(.body)\n\n            HStack {\n                Text(model.displayPrice)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n\n                Text(\"Context: \\(model.contextLength / 1000)K\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n        }\n    }\n}\n```\n\n### Keychain Integration\n\nStore API key securely:\n```swift\nlet service = \"com.optimusclip.openrouter\"\ntry KeychainWrapper.shared.saveString(apiKey, service: service, account: \"api_key\")\n```\n\n### Popular Models Reference\n\n| Model ID | Use Case | Price (input) |\n|----------|----------|---------------|\n| `anthropic/claude-3.5-sonnet` | High quality, complex tasks | $3/M |\n| `anthropic/claude-3-haiku` | Fast, good for code | $0.25/M |\n| `openai/gpt-4o` | General purpose | $2.50/M |\n| `openai/gpt-4o-mini` | Fast, economical | $0.15/M |\n| `google/gemini-pro-1.5` | Long context (1M+) | $1.25/M |\n| `mistralai/mistral-tiny` | Cheap, simple tasks | $0.25/M |\n| `meta-llama/llama-3.1-70b-instruct` | Open source, good value | $0.35/M |\n\n### Testing Checklist\n\n- [ ] API key validation with valid key succeeds\n- [ ] API key validation with invalid key shows clear error\n- [ ] Model list fetches and displays correctly\n- [ ] Model list caches and uses cache on reload\n- [ ] Cache expires after 24 hours and refreshes\n- [ ] Model selection persists across app restarts\n- [ ] Transformation works with selected OpenRouter model\n- [ ] 402 (no credits) shows helpful message with link\n- [ ] 404 (model gone) refreshes list and shows error\n- [ ] Rate limit (429) handled gracefully\n- [ ] Offline with cache shows cached models\n- [ ] Offline without cache shows appropriate error\n\n### Success Criteria\n\n- [ ] Single API key provides access to 100+ models\n- [ ] Model list fetches dynamically with pricing info\n- [ ] Models grouped by provider in Settings UI\n- [ ] Transformations work with any OpenRouter model\n- [ ] Errors guide users to resolution (get key, add credits)\n- [ ] Cache prevents excessive API calls\n- [ ] Key stored securely in Keychain\n\n### Architectural Connections\n\n- **LLMChatOpenAI package**: Reused for API calls (just different base URL)\n- **Keychain Wrapper (oc-l9j.12)**: Secure API key storage\n- **Providers Tab UI (oc-4tw.5)**: Configuration interface\n- **Transformation Engine (oc-j0g)**: Executes LLM transformations","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:17.207015-05:00","updated_at":"2025-12-13T19:39:30.863259-05:00","closed_at":"2025-12-13T19:39:30.863259-05:00","dependencies":[{"issue_id":"oc-tmx.3","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:06:17.207511-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.3","depends_on_id":"oc-j0g","type":"blocks","created_at":"2025-12-13T09:40:33.843914-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.4","title":"Ollama Provider Integration","description":"Integrate Ollama for local/offline LLM processing with complete privacy.\n\nBackground \u0026 Importance:\nOllama enables running LLMs locally on user's machine - NO data sent to cloud, NO API costs, works OFFLINE. Critical for:\n- Privacy-sensitive content (legal, medical, financial)\n- Offline work environments\n- Users wanting to avoid API costs\n- Data sovereignty requirements\n\nPopular local models: llama3.1, mistral, codellama, phi, gemma, deepseek-coder\n\nImplementation:\n- Use LLMChatOpenAI Swift package (Ollama has OpenAI-compatible API)\n- Default endpoint: http://localhost:11434/v1\n- CONFIGURABLE endpoint in Settings (users may change port or use remote Ollama)\n- NO API key required (local server)\n\nAPI Specifics:\n- Ollama runs as local HTTP server\n- OpenAI-compatible /v1/chat/completions endpoint\n- No authentication needed for localhost\n- Request/response format: Standard OpenAI\n\nDynamic Model Fetching:\n- Fetch from http://localhost:11434/api/tags (Ollama-specific endpoint)\n- Returns list of models user has pulled/installed locally\n- Response format: {\"models\": [{\"name\": \"llama3.1:latest\", \"size\": ..., \"digest\": ...}]}\n- Refresh model list when Settings opened (models can be added/removed via ollama CLI)\n- Empty list if no models installed\n\nConnection Testing:\n- Test Connection button in Settings UI\n- Ping http://localhost:11434/api/tags\n- Success: Show checkmark + number of available models\n- Failure: Show error message with troubleshooting\n  - Not running: 'Ollama not detected. Install from ollama.ai and run ollama serve'\n  - Wrong endpoint: 'Cannot connect to Ollama at [endpoint]. Check endpoint in Settings.'\n\nError Handling:\n- Connection refused: Ollama not running\n  - Message: 'Ollama is not running. Start Ollama and try again. Install from ollama.ai'\n- No models available: Empty model list\n  - Message: 'No models installed. Run: ollama pull llama3.1'\n- Timeout: Model inference taking too long\n  - Message: 'Ollama request timed out. Local model may be too slow for your hardware.'\n- Out of memory: System runs out of RAM\n  - Message: 'Insufficient system memory. Try a smaller model or close other apps.'\n\nTimeout Configuration:\n- Default: 60 seconds (longer than cloud APIs - local inference is slower)\n- Configurable: 30s/60s/120s/300s\n- Local models slower but no network latency\n\nSettings UI Elements:\n- Ollama endpoint URL (text field, default http://localhost:11434)\n- Test Connection button\n- Model dropdown (populated from /api/tags)\n- Refresh Models button\n- Help text: How to install Ollama and pull models\n- Link to ollama.ai\n\nPrompt Construction:\nStandard OpenAI format with system and user messages.\n\nPerformance Notes:\n- Speed depends on user's hardware (CPU/GPU/RAM)\n- Larger models (70B) need powerful hardware\n- Smaller models (7B, 13B) work on most modern Macs\n- Apple Silicon Macs (M1/M2/M3) have excellent performance\n\nDependencies:\n- LLMChatOpenAI package (custom base URL)\n- Network layer for local HTTP requests\n- Connection testing functionality\n- Endpoint configuration in Settings","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:38.44336-05:00","updated_at":"2025-12-13T19:19:52.8419-05:00","closed_at":"2025-12-13T19:19:52.8419-05:00","dependencies":[{"issue_id":"oc-tmx.4","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:06:38.443855-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.4","depends_on_id":"oc-j0g","type":"blocks","created_at":"2025-12-12T23:53:55.319664-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.5","title":"AWS Bedrock Provider Integration","description":"Integrate AWS Bedrock as an LLM provider for enterprise-grade cloud access to foundation models.\n\n## BACKGROUND \u0026 CONTEXT\nAWS Bedrock provides access to foundation models from multiple AI companies (Anthropic Claude, Meta Llama, Amazon Titan, Mistral, Cohere, AI21) through AWS infrastructure with enterprise features:\n- **Enterprise Integration**: Uses existing AWS accounts, IAM roles, VPCs, and billing\n- **Compliance**: HIPAA, SOC 2, GDPR-compliant infrastructure\n- **Data Sovereignty**: Data processed in selected AWS regions, never leaves AWS\n- **Centralized Governance**: CloudTrail logging, IAM policies, resource tagging\n- **No Model Training**: Input data NOT used for model training (unlike some providers)\n\nCritical for organizations that:\n- Already use AWS for infrastructure (seamless integration)\n- Require strict compliance and audit trails\n- Need data residency guarantees (specific regions)\n- Want unified AWS billing and cost management\n- Require enterprise support and SLAs\n\n## REAL-WORLD PROBLEM/USE CASE\n**Scenario**: Financial services company with AWS infrastructure\n- Requirement: Process sensitive financial documents with LLMs\n- Constraints: Data cannot leave US, must have audit trail, needs SOC 2 compliance\n- Solution: Bedrock in us-east-1 with CloudTrail logging, IAM-controlled access\n- Benefit: Existing AWS security policies apply, data never sent to third-party APIs, audit trail automatic\n\n**Scenario 2**: Enterprise developer team using AWS\n- Already authenticated with AWS CLI for work\n- Can use Bedrock without managing separate API keys\n- Unified billing: LLM usage on same AWS bill as EC2/S3\n\n## TECHNICAL IMPLEMENTATION DETAILS\n\n### Package \u0026 Dependencies\n- Use **AWS SDK for Swift** (official AWS SDK)\n  - Package: aws-sdk-swift\n  - Module: AWSBedrockRuntime\n- Service: BedrockRuntime\n- Operation: InvokeModel (synchronous) or InvokeModelWithResponseStream (streaming)\n- API Version: 2023-09-30\n\n### Authentication (Multiple Options)\n**Option 1: AWS Credentials Profile (PREFERRED)**\n- Location: ~/.aws/credentials (standard AWS credentials file)\n- Format: INI-style config\n- Implementation: Parse file, extract profiles, let user select in dropdown\n- Handles multiple profiles (default, work, personal, prod, dev, etc.)\n\n**Option 2: Explicit Credentials Input**\n- User manually enters Access Key ID + Secret Access Key in Settings\n- Store in macOS Keychain (service: com.optimusclip.aws.credentials)\n- More secure than profile file for single-user desktop app\n- Keychain items: account for access key, separate for secret key\n\n**Option 3: IAM Role (Advanced/Future)**\n- For EC2/ECS environments (less common for desktop app)\n- Automatic credential refresh via IMDS\n\n### AWS Region Selection\nAvailable Bedrock regions (as of December 2024):\n- us-east-1 (N. Virginia) - Widest model availability, RECOMMENDED\n- us-west-2 (Oregon) - Good availability\n- ap-southeast-1 (Singapore) - Asia Pacific\n- ap-northeast-1 (Tokyo) - Japan\n- eu-central-1 (Frankfurt) - Europe\n- eu-west-1 (Ireland) - Europe\n\nModel availability varies by region - us-east-1 has most models.\n\n### Model Selection\nBedrock Model IDs (full identifiers required):\n\n**Anthropic Claude** (Best for general use):\n- anthropic.claude-3-5-sonnet-20241022-v2:0 (Latest Sonnet, best balance)\n- anthropic.claude-3-5-haiku-20241022-v2:0 (Fast, economical)\n- anthropic.claude-3-opus-20240229-v1:0 (Most capable, expensive)\n\n**Amazon Titan** (AWS-native models):\n- amazon.titan-text-premier-v1:0 (Best Titan)\n- amazon.titan-text-express-v1 (Fast, economical)\n\n**Meta Llama** (Open source):\n- meta.llama3-1-405b-instruct-v1:0 (Largest)\n- meta.llama3-1-70b-instruct-v1:0 (Good balance)\n\n**Mistral AI**:\n- mistral.mistral-large-2407-v1:0 (Most capable)\n\nModel availability CHECK REQUIRED:\n- User must enable model access in AWS Console first\n- AWS Console → Bedrock → Model Access → Request Access\n- Some models require justification/approval\n- Provide help text with console link in Settings\n\n### API Specifics\nEndpoint: https://bedrock-runtime.[region].amazonaws.com\nAuthentication: AWS Signature V4 (handled by SDK automatically)\n\nRequest Format (varies by model provider):\n- Claude models: Anthropic message format with bedrock version\n- Titan models: Amazon's inputText format\n- Llama models: Meta's prompt format with tags\n\nResponse Format (also model-specific):\n- Claude: content array with text blocks\n- Titan: results array with outputText\n- Llama: generation field with text\n\nImplementation must handle model-specific formats via abstraction layer.\n\n### Error Handling\n\n**Invalid Credentials (403 Forbidden)**:\n- Message: \"Invalid AWS credentials. Check Access Key and Secret Key in Settings.\"\n- IAM Permission required: bedrock:InvokeModel\n\n**Model Not Available in Region (404 or ValidationException)**:\n- Message: \"[Model] not available in [Region]. Try us-east-1 or different model.\"\n\n**Model Access Not Enabled (AccessDeniedException)**:\n- Message: \"Model access not enabled. Enable in AWS Bedrock Console: [link]\"\n- Direct link to AWS Console Model Access page\n\n**Throttling (ThrottlingException or TooManyRequestsException)**:\n- Message: \"AWS Bedrock request limit reached. Wait and try again.\"\n- Implement exponential backoff (optional retry after 5s delay)\n\n**Service Quota Exceeded (ServiceQuotaExceededException)**:\n- Message: \"AWS Bedrock service quota exceeded. Request quota increase in AWS Console.\"\n\n**Network Errors**:\n- Message: \"Unable to connect to AWS Bedrock. Check internet and region configuration.\"\n\n**Server Errors (500, 502, 503)**:\n- Message: \"AWS Bedrock temporarily unavailable. Try again shortly.\"\n\n### Timeout Configuration\n- Default: 45 seconds (Bedrock can be slower than direct APIs due to cold starts)\n- Configurable: 30s / 45s / 60s / 120s\n- Bedrock cold start: First request to a model may take 10-20s\n- Subsequent requests faster (warm containers)\n\n### Prompt Construction\nFor Claude models (recommended):\n- system: User's configured system prompt from Settings\n- messages: [{role: \"user\", content: clipboard_text}]\n- max_tokens: 4096 (configurable)\n- anthropic_version: \"bedrock-2023-05-31\" (required)\n\nFor Titan models:\n- Concatenate system prompt + clipboard text with separator\n- inputText: \"{systemPrompt}\\n\\nUser: {clipboardText}\\n\\nAssistant:\"\n\n## ARCHITECTURAL CONNECTIONS\nIntegrates with:\n- KeychainManager: Store AWS credentials securely\n- LLMProviderProtocol: Implement as BedrockProvider\n- TransformationEngine: Called when LLM rule with Bedrock selected\n- SettingsView: Configuration UI for credentials, region, model\n- ErrorHandler: Map Bedrock errors to user notifications\n- ModelFetcher: Provide list of available models per region\n\n## EDGE CASES \u0026 GOTCHAS\n1. Model Access Approval Delay: Some models require AWS approval (hours to days)\n2. Region-Specific Model Availability: Model available in one region but not another\n3. IAM Permission Complexity: Valid credentials but missing bedrock:InvokeModel permission\n4. Cold Start Latency: First request can take 10-20 seconds\n5. Cost Awareness: Bedrock charges per token, large documents can be expensive\n6. Cross-Region Performance: High latency if user far from selected region\n\n## TESTING REQUIREMENTS\n- Parse AWS profiles from ~/.aws/credentials (valid, invalid, missing)\n- Store explicit credentials in Keychain securely\n- Select region and model, execute transformation\n- Handle model access error gracefully\n- Handle credential error gracefully\n- Test with various text sizes\n- Verify cold start vs warm request performance\n\n## SUCCESS CRITERIA\n- Parse and display AWS profiles from ~/.aws/credentials\n- Store explicit credentials in Keychain securely\n- Execute transformation with Claude and Titan models\n- Handle errors gracefully with clear messages\n- Cold start latency acceptable (\u003c20s)\n\n## CONFIGURATION OPTIONS\nSettings UI:\n1. Authentication Method: Dropdown (AWS Profile / Explicit Credentials)\n2. Profile dropdown (if using profiles)\n3. Access Key ID + Secret Access Key (if explicit)\n4. Region: Dropdown with regions\n5. Model: Dropdown (filtered by region availability)\n6. Timeout: 30s/45s/60s/120s\n7. Max tokens: 1024/2048/4096/8192\n\nDefaults:\n- Authentication: AWS Profile (if file exists), else Explicit\n- Profile: \"default\"\n- Region: us-east-1\n- Model: anthropic.claude-3-5-haiku-20241022-v2:0\n- Timeout: 45s\n- Max tokens: 4096\n\n## SECURITY/PERFORMANCE CONSIDERATIONS\n**Security**:\n- Store credentials in Keychain, NOT UserDefaults\n- Never log AWS secret keys\n- Credentials file read with proper permissions check\n- Use HTTPS for all API calls\n- Request file access permission for ~/.aws/credentials\n\n**Performance**:\n- Cache model list per region\n- Reuse AWS client instances\n- Monitor memory usage with large responses\n- Implement request timeout\n\n**Cost Management**:\n- Track token usage (input + output)\n- Show estimated cost (optional)\n- Warn on very large input (\u003e50k characters)\n\n**Privacy**:\n- Bedrock doesn't train on user data (per AWS policy)\n- Data processed in selected region only\n- Mention in UI: \"Your data processed in AWS [Region], not used for training\"\n\n## DEPENDENCIES\n- aws-sdk-swift (AWSBedrockRuntime module)\n- macOS Keychain (Security framework)\n- File system (~/.aws/credentials)\n- LLMProviderProtocol\n- KeychainManager\n- ErrorHandler\n- NetworkManager","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:07:02.998612-05:00","updated_at":"2025-12-13T19:37:51.369554-05:00","closed_at":"2025-12-13T19:37:51.369554-05:00","dependencies":[{"issue_id":"oc-tmx.5","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:07:02.999195-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.5","depends_on_id":"oc-j0g","type":"blocks","created_at":"2025-12-12T23:53:55.584074-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.6","title":"Dynamic Model Fetching","description":"Implement dynamic model fetching and caching for all LLM providers to ensure users always have access to current models.\n\n## BACKGROUND \u0026 CONTEXT\nModel availability changes frequently in the LLM ecosystem. New models are released every few months, old models get deprecated, regional availability changes, and local Ollama users constantly pull/remove models. Hardcoding model lists leads to outdated selections, broken references, and poor user experience. Dynamic fetching ensures users access latest models without app updates and handles deprecation automatically.\n\n## REAL-WORLD PROBLEM/USE CASE\nOpenAI releases GPT-4.5-turbo: Without dynamic fetching users wait weeks for app update. With it the model appears in dropdown within 24 hours. Ollama user runs ollama pull deepseek-coder:33b, opens Settings, and model appears immediately. AWS enables Claude Opus in new region, user switches region and sees available models automatically.\n\n## TECHNICAL IMPLEMENTATION DETAILS\n\n### Provider-Specific Implementation\n\n**OpenAI**: Endpoint https://api.openai.com/v1/models with Bearer auth. Filter for chat models only (exclude fine-tuned, embeddings). Sort by capability and recency.\n\n**Anthropic**: No public endpoint. Use STATIC hardcoded list updated with app releases. Consider manual override field for power users.\n\n**OpenRouter**: Endpoint https://openrouter.ai/api/v1/models (no auth required). Returns models with pricing and context length. Group by provider, display metadata in UI.\n\n**Ollama**: Endpoint http://localhost:11434/api/tags. Shows only locally installed models. Always fetch fresh (no cache) on Settings open since models change frequently.\n\n**Bedrock**: No public endpoint. Use STATIC list per region since availability varies. Update with app releases when AWS announces new models.\n\n### Caching Strategy\nCache duration: OpenAI 24hr, OpenRouter 12hr, Ollama no cache, Anthropic/Bedrock static. Store in UserDefaults for small lists or JSON file for large lists. Cache structure includes models array, fetched_at timestamp, and expires_at. On expiry fall back to cache until new fetch succeeds.\n\n### Refresh Triggers\n1. App launch: Check expiry, fetch if needed (background, non-blocking)\n2. Settings open: Attempt refresh for current provider\n3. Manual refresh: Button in Settings forces new fetch\n4. Config change: API key changed or endpoint changed triggers immediate fetch\n\n### Error Handling\nNetwork unavailable: Use cached list with warning. API error: Fall back to cache or minimal static fallback. Empty response: Use cache or show setup instructions (Ollama). Timeout: Log warning, use cache, retry on next trigger.\n\n### UI Implementation\nModel dropdown shows cached/fetched models with loading indicator. Display metadata: friendly name, context length, pricing, speed indicator, capability tags. Refresh button with states: normal/loading/success/error. Cache indicator shows last updated timestamp and warnings for stale cache.\n\n### Fallback Strategy\nIf all fails use minimal static list: OpenAI [\"gpt-4o\", \"gpt-4o-mini\"], Anthropic full static list, OpenRouter top 3 models, Ollama show error, Bedrock full static list per region.\n\n## ARCHITECTURAL CONNECTIONS\nIntegrates with NetworkManager for HTTP requests, CacheManager for storage, SettingsView for UI, ProviderManager for per-provider logic, ErrorHandler for graceful failures. Implements ModelFetcher protocol with fetchModels, getCachedModels, clearCache methods. Model struct includes id, name, contextLength, pricing, capabilities, deprecated flag.\n\n## EDGE CASES \u0026 GOTCHAS\n1. Race condition: User selects model while list refreshing - lock list during update\n2. API rate limits: Frequent fetching hits limits - use cache with appropriate expiry\n3. Large lists: OpenRouter 100+ models - fetch in background\n4. Model ID format changes: Handle both old and new formats\n5. Stale cache: Show warning if cache older than 7 days\n6. Ollama endpoint change: Immediately refresh model list\n7. Partial fetch failure: Validate response, fall back to cache on parse error\n\n## TESTING REQUIREMENTS\nUnit tests: Cache expiry logic, model parsing for each provider, fallback logic, filtering and sorting. Integration tests: Real API calls, cache persistence across restarts, offline scenarios. Manual tests: Verify model list populated, refresh button works, offline uses cache, Ollama pull new model appears. Performance: Fetch time \u003c10s, cache load \u003c100ms, UI responsive.\n\n## SUCCESS CRITERIA\nMust work: Dynamic fetch for OpenAI/OpenRouter/Ollama, static for Anthropic/Bedrock, cache persists and expires correctly, manual refresh works, fallbacks on errors. Should work: Loading indicators, cache age display, metadata in UI, sensible grouping/sorting. Nice to have: Background refresh, smart retry, deprecation warnings.\n\n## CONFIGURATION OPTIONS\nSettings: Auto-refresh toggle, cache duration dropdown, show deprecated models toggle, manual override field for custom model ID. Defaults: Auto-refresh enabled, 24hr cache (OpenAI), 12hr (OpenRouter), deprecated hidden.\n\n## SECURITY/PERFORMANCE CONSIDERATIONS\nSecurity: HTTPS enforced, validate API responses, rate limit manual refresh. Performance: Async non-blocking fetch, efficient cache storage, background app launch fetch, clean up old cache entries. Privacy: No user data sent, no telemetry, cache local only. Resource: Monitor memory with large lists, limit cache size to 1MB per provider.\n\n## DEPENDENCIES\nURLSession for HTTP, UserDefaults or FileManager for cache, Foundation for JSON/Date. Internal: NetworkManager, CacheManager, ProviderManager, ErrorHandler. Optional future: SwiftData for structured cache.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:07:31.718167-05:00","updated_at":"2025-12-13T20:47:44.399434-05:00","closed_at":"2025-12-13T20:47:44.399434-05:00","dependencies":[{"issue_id":"oc-tmx.6","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:07:31.718756-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.6","depends_on_id":"oc-tmx.1","type":"blocks","created_at":"2025-12-12T23:54:02.961047-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.6","depends_on_id":"oc-tmx.2","type":"blocks","created_at":"2025-12-12T23:54:03.309288-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.6","depends_on_id":"oc-tmx.3","type":"blocks","created_at":"2025-12-12T23:54:03.59409-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.6","depends_on_id":"oc-tmx.4","type":"blocks","created_at":"2025-12-12T23:54:04.06899-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.6","depends_on_id":"oc-tmx.5","type":"blocks","created_at":"2025-12-12T23:54:04.355217-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.7","title":"LLM Transformation Wrapper","description":"Create unified interface for LLM transformations across all providers with consistent error handling and prompt construction.\n\n## BACKGROUND \u0026 CONTEXT\nEach LLM provider has different APIs, authentication methods, request/response formats, and error codes. Without a unified wrapper the transformation engine would need provider-specific code everywhere leading to duplication, inconsistent error handling, and difficult maintenance. A wrapper provides single interface for rule execution, consistent error handling across providers, easy provider switching, centralized prompt construction, and uniform timeout/cancellation.\n\n## REAL-WORLD PROBLEM/USE CASE\nUser creates transformation \"Fix Grammar\" with OpenAI GPT-4. Later switches to Anthropic Claude for better results. Without wrapper: rewrite prompt construction, error handling, response parsing. With wrapper: change dropdown in Settings, transformation works identically. Error handling example: OpenAI returns 429 with specific format, Anthropic returns 429 differently, wrapper maps both to consistent RateLimitError with user-friendly message.\n\n## TECHNICAL IMPLEMENTATION DETAILS\n\n### LLMProvider Protocol\nCore interface all providers implement:\n- transform(text: String, systemPrompt: String, model: String) async throws -\u003e String\n- configure(credentials: ProviderCredentials) throws  \n- isConfigured() -\u003e Bool\n- getAvailableModels() async throws -\u003e [Model]\n- cancel() - Cancel in-flight request\n\n### Concrete Implementations\nOpenAIProvider, AnthropicProvider, OpenRouterProvider, OllamaProvider, BedrockProvider. Each handles provider-specific API format, authentication, and response parsing.\n\n### ProviderCredentials Enum\nStrongly-typed credentials per provider:\n- openai(apiKey: String)\n- anthropic(apiKey: String)  \n- openRouter(apiKey: String)\n- ollama(endpoint: URL)\n- bedrock(accessKey: String, secretKey: String, region: String)\n\n### Prompt Construction\nUnified input: systemPrompt, userContent (clipboard), model ID, temperature (default 0.7), maxTokens (default 4096). Provider-specific formatting: OpenAI/OpenRouter use messages array with system+user roles. Anthropic separates system parameter from messages. Bedrock wraps in provider format. Ollama uses OpenAI-compatible format.\n\n### Response Handling\nExtract text from provider responses: OpenAI response.choices[0].message.content, Anthropic response.content[0].text, others similar. Handle empty responses, validate UTF-8, trim whitespace. Phase 5 uses non-streaming (simpler). Future: streaming support for incremental results.\n\n### Timeout Handling\nConfiguration: Default 30s (cloud), 60s (Ollama local). Configurable 15s/30s/60s/120s/300s per provider. Implementation: Use Swift Task.withTimeout or similar. Cancel underlying network request on timeout. Throw TimeoutError with user message. Never paste on timeout.\n\n### Error Handling\nError types enum: ConfigurationError (missing API key), AuthenticationError (401 invalid key), RateLimitError (429 too many requests), ModelNotAvailableError (404 not found), TimeoutError (exceeded duration), NetworkError (connection failed), ServerError (500 series), ContentFilterError (safety rejection). On ANY error: Show notification, keep original clipboard unchanged, log for debugging, don't retry automatically.\n\n### Clipboard Integration\nSuccess flow: Receive LLM response, validate non-empty, update clipboard, show success notification (optional), paste if enabled. Failure flow: Catch error, keep clipboard unchanged, show error notification, DO NOT paste. Validation: Reject empty, trim whitespace, validate UTF-8, check macOS clipboard size limits.\n\n### Context Management\nProvider context: Single instance per provider (reuse connections), lazy initialization, persist config across calls. Request context: Unique ID per request, metadata (timestamp, provider, model, token count) for logging/analytics.\n\n### Cancellation Support\nUser cancels: ESC key or Cancel button cancels network request, cleans up resources, shows \"Cancelled\", doesn't modify clipboard. App lifecycle: Cancel in-flight on quit, provider switch, or Settings change.\n\n### Logging \u0026 Analytics\nLog events: Transformation started/completed (provider, model, text length, duration, token count). Errors: type, message, provider, model. Performance: request duration, time to first byte. Privacy: NEVER log actual clipboard content, only metadata. Configurable logging level. Future: Token usage tracking, cost estimation, usage statistics.\n\n## ARCHITECTURAL CONNECTIONS\nIntegrates with: Provider packages (LLMChatOpenAI, LLMChatAnthropic, AWS SDK), NetworkManager for timeouts, ErrorHandler for mapping errors, ClipboardManager for updates, NotificationManager for user alerts, SettingsManager for configuration, AnalyticsManager for logging.\n\n## EDGE CASES \u0026 GOTCHAS\n1. Empty responses: Validate before updating clipboard\n2. Very large responses: Check clipboard size limits (macOS ~100MB practical limit)\n3. Encoding issues: Validate UTF-8, handle emojis and special characters\n4. Provider-specific quirks: Anthropic requires max_tokens, OpenAI optional\n5. Timeout during network retry: Cancel all retry attempts\n6. Concurrent transformations: Queue or reject additional requests\n7. Provider config change mid-request: Cancel in-flight requests\n8. Response parsing errors: Map to InvalidResponseError with debug info\n\n## TESTING REQUIREMENTS\nUnit tests: Mock providers for each error type, prompt construction correctness per provider, response parsing for valid/invalid/empty responses, timeout behavior with Task simulation, cancellation cleanup. Integration tests: Real provider calls (if credentials available), error handling for each provider, multiple sequential transformations. Manual tests: Execute transformation with each provider, trigger each error scenario (invalid key, rate limit, timeout), verify clipboard never modified on error, test cancellation mid-transformation.\n\n## SUCCESS CRITERIA\nMust work: All 5 providers implement protocol, transform() returns cleaned text for valid requests, all error types handled gracefully with notifications, timeout cancels request properly, cancellation cleans up completely, clipboard never corrupted on errors. Should work: Prompt construction correct for each provider format, response parsing handles all edge cases, logging captures useful debug info without content. Nice to have: Token usage tracking, cost estimation, streaming support (future).\n\n## CONFIGURATION OPTIONS\nPer provider in Settings: Model selection, temperature (0.0-2.0 slider, default 0.7), max tokens (1024/2048/4096/8192 dropdown, default 4096), timeout (15s/30s/60s/120s/300s, provider-specific defaults). Global: Enable/disable logging, log level (error/warning/info/debug), show success notifications (optional).\n\n## SECURITY/PERFORMANCE CONSIDERATIONS\nSecurity: Credentials never logged, API keys masked in logs (show last 4 chars only), HTTPS enforced for all calls, validate provider responses to prevent injection. Performance: Reuse provider connections (don't recreate per request), async/await for non-blocking, cancel cleanly to free resources, monitor memory with large responses. Privacy: Never log clipboard content, no telemetry to developer, all analytics local only. Reliability: Comprehensive error handling, graceful degradation, no crashes on malformed responses.\n\n## DEPENDENCIES\nSwift packages: LLMChatOpenAI, LLMChatAnthropic, aws-sdk-swift (AWSBedrockRuntime). System: Foundation (URLSession, JSON), Swift Concurrency (async/await, Task). Internal: NetworkManager (timeouts), ErrorHandler (mapping), ClipboardManager (updates), NotificationManager (alerts), SettingsManager (config), AnalyticsManager (logging).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:08:05.745097-05:00","updated_at":"2025-12-13T21:04:07.951657-05:00","closed_at":"2025-12-13T21:04:07.951657-05:00","dependencies":[{"issue_id":"oc-tmx.7","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:08:05.745939-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.7","depends_on_id":"oc-tmx.6","type":"blocks","created_at":"2025-12-12T23:54:10.840349-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.8","title":"Async Transformation Execution","description":"Implement non-blocking async execution for LLM transformations using Swift concurrency to maintain responsive UI during long-running operations.\n\n## BACKGROUND \u0026 CONTEXT\nLLM API calls take 3-30+ seconds depending on model, text length, and network conditions. Blocking the main thread during these calls creates terrible UX: frozen menu bar icon, unresponsive interface, no ability to cancel, app appears hung. Users can't interact with other apps or cancel mistaken transformations. Modern Swift concurrency (async/await, Task, Actor) provides structured approach to async execution with proper cancellation, error propagation, and thread safety.\n\n## REAL-WORLD PROBLEM/USE CASE\nUser triggers \"Summarize for Slack\" transformation with Claude Opus on 10,000 character document. Without async: App freezes for 25 seconds, icon unresponsive, user thinks app crashed, force quits. With async: Icon immediately shows pulse animation, user sees \"Processing with Claude Opus...\" status, can click Cancel button if needed, can switch to other apps, transformation completes and pastes when ready.\n\nTechnical scenario: User accidentally triggers transformation, realizes wrong text copied, clicks Cancel. Async execution allows immediate cancellation, network request terminated, resources freed, no wasted API call.\n\n## TECHNICAL IMPLEMENTATION DETAILS\n\n### Swift Concurrency Foundations\nUse async/await (Swift 5.5+) for natural async code flow. Task for concurrent execution without blocking. @MainActor for UI updates ensuring main thread. Actor for shared mutable state ensuring thread safety. Structured concurrency for automatic cancellation propagation.\n\n### Execution Flow\n1. User triggers transformation (hotkey or button)\n2. Validate: Check clipboard has text, check provider configured, check not already processing\n3. Start Task: Task { await executeTransformation() } - non-blocking\n4. Update UI: Set isProcessing=true, show pulse animation, display status text\n5. Execute: Call LLM provider's transform() in background (async naturally uses background threads)\n6. Handle result: Success updates clipboard and pastes, failure shows error notification\n7. Clean up: Set isProcessing=false, stop animation, reset state, log event\n\n### Task Management\nStore current transformation Task: var currentTask: Task\u003cVoid, Never\u003e?. Allow only ONE active transformation at a time (avoid confusion, reduce costs). On new request while processing: Show \"Already processing\" notification or queue (advanced). Track state enum: idle, processing, completed, failed, cancelled. State transitions: idle -\u003e processing (on trigger), processing -\u003e completed (on success), processing -\u003e failed (on error), processing -\u003e cancelled (on user cancel), any -\u003e idle (after 2s cleanup).\n\n### Cancellation Implementation\nUser cancellation triggers: ESC key (global hotkey), Cancel button in menu/notification, quit app. Implementation: currentTask?.cancel() sends cancellation signal. In transform function: Check Task.isCancelled at key points (before API call, during parsing, before clipboard update). On cancellation: Stop network request via URLSessionTask.cancel(), clean up resources, set state to cancelled, show \"Cancelled\" message briefly, return to idle. Never modify clipboard on cancellation.\n\n### Timeout Implementation\nUse withTimeout wrapper with TaskGroup: One task for operation, one task for sleep(timeout). Cancel all tasks when first completes. If timeout wins: throw TimeoutError. Default 30s for cloud APIs, 60s for Ollama. Configurable per provider in Settings. On timeout: Cancel network request, show timeout notification, log duration and text length for debugging.\n\n### Thread Safety with @MainActor\nUI updates must run on main thread: @MainActor func updateUI() ensures safety. State changes trigger UI updates: @Published var isProcessing: Bool updates SwiftUI automatically. Clipboard operations on main thread (NSPasteboard not thread-safe). Paste simulation on main thread (CGEvent requires main thread).\n\n### Shared State Management with Actor\nTransformationQueue actor for thread-safe state: \n```swift\nactor TransformationQueue {\n    private(set) var isProcessing = false\n    private(set) var currentRequest: TransformationRequest?\n    \n    func startProcessing(_ request: TransformationRequest) async throws {\n        guard !isProcessing else { throw TransformationError.alreadyProcessing }\n        isProcessing = true\n        currentRequest = request\n    }\n    \n    func finishProcessing() async {\n        isProcessing = false\n        currentRequest = nil\n    }\n    \n    func cancel() async {\n        currentRequest?.cancel()\n        isProcessing = false\n    }\n}\n```\n\n### Progress Feedback\nIndeterminate progress (can't predict LLM completion time). UI elements: Pulse animation on menu bar icon, status text \"Processing with [Provider]...\" in menu, Cancel button enabled and prominent, other transformation actions disabled. Optional: Elapsed time counter \"Processing... 5s\". Advanced: Show token streaming progress (future with streaming APIs).\n\n### Error Handling in Async Context\nStructured concurrency: Errors propagate naturally with try await. Catch at top level in Task:\n```swift\nTask {\n    do {\n        let result = try await transformationService.transform(...)\n        await handleSuccess(result)\n    } catch let error as LLMError {\n        await handleLLMError(error)\n    } catch is CancellationError {\n        await handleCancellation()\n    } catch {\n        await handleUnexpectedError(error)\n    }\n}\n```\nAll error handlers use @MainActor for UI updates.\n\n### Resource Management\nRelease resources after completion: Network connection pools cleaned up, response data deallocated, provider instances reused (not recreated). Memory monitoring: Large responses (\u003e10MB) require careful handling, release immediately after clipboard update. Task cancellation automatically cleans up in-flight operations. On app quit: Cancel all active tasks via AppDelegate/WindowGroup.onDisappear.\n\n## ARCHITECTURAL CONNECTIONS\nIntegrates with: TransformationEngine for rule execution, LLMProviderProtocol for async transform calls, ClipboardManager for async clipboard updates, NotificationManager for async error notifications, SettingsView for UI state binding, HotkeyManager for cancellation triggers. Uses SwiftUI @Published for reactive UI updates, Combine for state propagation (optional).\n\n## EDGE CASES \u0026 GOTCHAS\n1. Rapid transformations: User triggers multiple times quickly - reject or queue subsequent requests\n2. App backgrounded during transformation: macOS may suspend, network may timeout - handle gracefully on foreground\n3. System sleep during transformation: Cancel on sleep, show notification on wake\n4. Transformation completes after user switches providers: Ignore stale results, check provider matches current\n5. Memory pressure: Large response causes memory warning - immediately release response data\n6. Task leaked: Ensure currentTask reference cleared on completion to prevent memory leak\n7. Cancellation race: User cancels just as completion arrives - prefer cancellation state\n8. Network changes: WiFi to cellular switch during call - URLSession handles, may timeout\n\n## TESTING REQUIREMENTS\nUnit tests: Task creation and cancellation, state transitions (idle-\u003eprocessing-\u003ecompleted), timeout logic with mocked delays, error propagation through async chain, concurrent transformation prevention, resource cleanup verification. Integration tests: Real provider calls with network delays, cancellation during actual transformation, timeout with slow responses, multiple sequential transformations, rapid trigger attempts. Manual tests: Trigger transformation and verify UI responsive, interact with menu during processing, cancel mid-transformation, force timeout by disconnecting network briefly, quit app during transformation and verify clean exit, transform very large text. Performance tests: Verify main thread never blocked (Instruments Time Profiler), measure overhead of async dispatch (\u003c10ms), monitor memory during long transformations, test 100 sequential transformations for leaks.\n\n## SUCCESS CRITERIA\nMust work: UI remains fully responsive during all LLM calls, processing animation starts immediately on trigger, user can cancel at any time, cancellation stops network request and cleans up, timeout throws proper error, only one transformation active at a time, no crashes or hangs in any scenario, Task references properly cleaned up (no leaks). Should work: Status text updates appropriately, cancel button appears/disappears correctly, elapsed time shown (optional), error notifications appear promptly, rapid triggers handled gracefully. Nice to have: Queue for multiple transformations, progress percentage (if streaming), estimated time remaining.\n\n## CONFIGURATION OPTIONS\nSettings: Transformation timeout per provider (15s/30s/60s/120s/300s), concurrent transformations (disabled in MVP, future: allow N concurrent), cancel hotkey (default ESC, customizable), show elapsed time toggle, auto-cancel on app background toggle.\n\nDefaults: Timeout 30s (cloud APIs), 60s (Ollama), concurrent disabled (only 1 at a time), cancel on ESC enabled, show elapsed time disabled, auto-cancel on background disabled.\n\n## SECURITY/PERFORMANCE CONSIDERATIONS\nSecurity: Task cancellation prevents wasted API calls on accidental triggers, timeout prevents indefinite hangs on malicious/slow servers, proper cleanup prevents resource exhaustion attacks. Performance: Async dispatch overhead minimal (\u003c10ms), background execution doesn't block UI (verified with profiling), memory released immediately after completion, connection pooling reuses HTTP connections. Reliability: Cancellation propagates through entire async chain, errors don't crash app (caught at top level), resources freed even on errors, no leaked Tasks or network connections. Resource limits: Maximum 1 concurrent transformation (prevent API cost explosion), maximum response size 100MB (prevent memory exhaustion), timeout prevents indefinite resource usage.\n\n## DEPENDENCIES\nSwift Concurrency: async/await syntax, Task for concurrent execution, @MainActor for main thread, Actor for thread-safe state, structured concurrency for cancellation. System: Foundation (URLSession for cancelable network), AppKit (CGEvent on main thread), Swift (error handling, protocols). Internal: TransformationEngine (async rule execution), LLMProviderProtocol (async transform method), ClipboardManager (async clipboard ops), NotificationManager (async notifications), StateManager (async state updates). UI: SwiftUI @Published for reactive updates, Combine for state streams (optional).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:08:55.222201-05:00","updated_at":"2025-12-13T22:16:41.117293-05:00","closed_at":"2025-12-13T22:16:41.117293-05:00","dependencies":[{"issue_id":"oc-tmx.8","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:08:55.222989-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.8","depends_on_id":"oc-tmx.7","type":"blocks","created_at":"2025-12-12T23:54:11.015486-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-tmx.9","title":"Processing Animation","description":"Implement pulse animation on menu bar icon during LLM processing to provide clear visual feedback and reassure users during long operations.\n\n## BACKGROUND \u0026 CONTEXT\nLLM transformations take 3-30 seconds. Without visual feedback users don't know if app is working, frozen, or crashed. Static icon gives no indication of processing state leading to frustration, duplicate triggers, and force quits. Animation provides: Reassurance that app is actively processing, clear distinction between idle and processing states, professional polished UX, accessibility for users who rely on visual cues. Pulse animation specifically chosen because: Built into macOS 14+ SwiftUI (.symbolEffect), smooth GPU-accelerated performance, universally understood \"working\" indicator, battery efficient compared to custom animations.\n\n## REAL-WORLD PROBLEM/USE CASE\nUser triggers transformation with Anthropic Claude on long document. Without animation: Stares at static icon for 15 seconds, wonders if hotkey registered, presses it again, now two API calls running, confusion ensues. With animation: Sees icon pulsing immediately, knows transformation is running, waits patiently, animation stops when complete, text pastes smoothly.\n\nAccessibility scenario: User with Reduce Motion enabled sees animation, experiences seizure trigger. With proper implementation: Animation replaced by color change or badge, no motion, accessibility maintained.\n\n## TECHNICAL IMPLEMENTATION DETAILS\n\n### SwiftUI Implementation (macOS 14+)\nUse SF Symbols .symbolEffect(.pulse) modifier:\n```swift\nMenuBarExtra(\"OptimusClip\", systemImage: \"scissors\") {\n    // Menu content\n}\n.symbolEffect(.pulse, isActive: isProcessing)\n```\nisProcessing is @Published boolean in ViewModel. State change automatically triggers/stops animation. Built-in smooth transitions, no manual timing needed.\n\n### Animation Characteristics\nVisual: Icon scales subtly 1.0 to ~1.1x, fades slightly during expansion, smooth ease-in-out timing. Speed: Medium pace ~0.8-1.0 seconds per pulse cycle, feels responsive not sluggish. Loop: Repeats continuously while isProcessing=true, stops immediately on false. Color: Keep default icon color (system adapts to dark/light mode) or use blue accent (.symbolRenderingMode(.palette) with blue tint).\n\n### State Management\n@Published var isProcessing: Bool = false in TransformationManager. Start animation: Set isProcessing=true when LLM call begins. Stop animation: Set isProcessing=false when call completes, errors, or cancelled. SwiftUI automatically observes @Published and updates icon. Synchronize with transformation lifecycle: start in executeTransformation() entry, stop in all exit paths (success, error, cancel, timeout).\n\n### Animation Lifecycle\nStart trigger: User presses transformation hotkey -\u003e validate inputs -\u003e set isProcessing=true -\u003e pulse begins immediately. During: Animation loops continuously, user sees icon pulsing, can interact with menu. Stop trigger: LLM response received OR error thrown OR user cancels OR timeout -\u003e set isProcessing=false -\u003e pulse stops within 100ms. Timing: Start/stop transitions smooth (SwiftUI handles), no jarring jumps.\n\n### Accessibility Considerations\nCheck user preferences: if UIAccessibility.isReduceMotionEnabled (macOS uses system setting). If Reduce Motion enabled: Replace pulse with static indicator - color change (blue icon), badge (small dot), or subtle glow without scale animation. VoiceOver integration: Announce state changes \"Processing transformation\" on start, \"Transformation complete\" on success, \"Transformation failed\" on error. Use .accessibilityLabel and .accessibilityValue modifiers. Screen Reader: Status text in menu announces \"Processing with Claude...\" readable by VoiceOver.\n\n### Error State Indicators\nSuccessful completion: Stop pulse animation, brief success indicator optional (green checkmark for 1s then return to normal). Error state: Stop pulse immediately, brief error indicator (red tint or X badge for 2s), return to normal. Critical error: Persistent indicator until user dismisses (rare, only for config errors).\n\n### Visual Design Guidelines\nSubtlety: Animation noticeable but not distracting, shouldn't draw eye away from work. Consistency: Match macOS system animation style (native SF Symbol effects). Color: Adapt to system appearance (dark/light mode), use semantic colors (system blue, red for error). Size: Menu bar icon standard size (16-22pt depending on system), pulse doesn't exceed bounds. Performance: GPU-accelerated via SwiftUI, no CPU overhead, \u003c1% battery impact.\n\n### Edge Cases Handling\nApp quit during processing: Stop animation immediately in applicationWillTerminate. System sleep: Animation pauses automatically (macOS behavior), resumes on wake if still processing. Multiple transformations queued: Single animation for \"any processing\" state, doesn't flicker on/off. Animation stuck on: Defensive timer resets isProcessing=false after 5 minutes max (prevents stuck state). Window server restart: SwiftUI reconstructs view, animation state preserved via @Published.\n\n### Fallback for macOS \u003c14\n.symbolEffect() not available pre-macOS 14. Fallback implementation:\n```swift\nif #available(macOS 14.0, *) {\n    image.symbolEffect(.pulse, isActive: isProcessing)\n} else {\n    image\n        .scaleEffect(isAnimating ? 1.2 : 1.0)\n        .animation(.easeInOut(duration: 0.8).repeatForever(autoreverses: true), value: isAnimating)\n        .onAppear { isAnimating = isProcessing }\n        .onChange(of: isProcessing) { isAnimating = $0 }\n}\n```\nManual scale animation with repeatForever, similar visual effect but more code.\n\n## ARCHITECTURAL CONNECTIONS\nIntegrates with: TransformationManager (@Published isProcessing state), MenuBarView (observes state, applies animation), AsyncExecutionEngine (sets isProcessing on start/stop), ErrorHandler (stops animation on errors), CancellationHandler (stops animation on cancel). State flow: TransformationManager.isProcessing -\u003e MenuBarView observes -\u003e SwiftUI applies .symbolEffect. Uni-directional data flow ensures consistency.\n\n## EDGE CASES \u0026 GOTCHAS\n1. Animation doesn't stop: Ensure isProcessing=false in ALL exit paths (success, error, cancel, timeout, crash recovery). Defensive timer as backup.\n2. Animation stuck on: Add recovery logic - if isProcessing=true for \u003e5 minutes, reset to false, log warning.\n3. Flicker on rapid triggers: Debounce state changes with small delay (~50ms) to avoid flicker if operation completes instantly.\n4. Accessibility not respected: Always check isReduceMotionEnabled, provide non-animated alternative.\n5. VoiceOver not announcing: Verify .accessibilityLabel and .accessibilityValue correctly set and updated.\n6. Dark mode contrast: Test icon visibility in both light and dark modes, adjust color if needed.\n7. Multiple concurrent animations: If queuing transformations (future), show single animation for \"any active\", not multiple.\n8. Animation performance: Monitor with Instruments, ensure \u003c1% CPU, no frame drops in other apps.\n\n## TESTING REQUIREMENTS\nVisual tests: Start transformation, verify pulse begins immediately, wait for completion, verify pulse stops, trigger error, verify pulse stops, cancel mid-transformation, verify pulse stops immediately. Accessibility tests: Enable Reduce Motion, verify no scale animation (color change instead), enable VoiceOver, verify state announcements, test with screen reader, verify status readable. Edge case tests: Quit app during transformation, verify no animation on relaunch, sleep system during transformation, verify animation stops/resumes correctly, rapid triggers (10x in 1s), verify no flicker. Performance tests: Run Instruments Time Profiler during animation, verify \u003c1% CPU, check frame rate in other apps, verify 60fps maintained, run 100 transformations, verify no memory leak in animation system. Manual tests: Visual inspection in light/dark mode, verify contrast, check animation smoothness, compare to system animations for style match.\n\n## SUCCESS CRITERIA\nMust work: Animation starts immediately on transformation trigger, animation loops smoothly during processing, animation stops immediately on completion/error/cancel, Reduce Motion respected with non-animated alternative, VoiceOver announces state changes, no animation stuck state, performance impact negligible. Should work: Animation visually smooth and professional, subtle and non-distracting, matches macOS native style, works in both light and dark modes, success/error indicators brief and clear. Nice to have: Customizable animation style (pulse vs bounce), color themes, disable animation option in Settings, elapsed time integrated with animation.\n\n## CONFIGURATION OPTIONS\nSettings: Animation style (pulse/bounce/fade - default pulse), animation speed (slow/medium/fast - default medium), show success indicator (brief checkmark - toggle, default off), show error indicator (brief X - toggle, default on), disable animations (respect system + user override - toggle, default system), color theme (system/blue/green/custom - default system). Defaults: Pulse style, medium speed, success indicator off, error indicator on, respect system Reduce Motion, system color.\n\n## SECURITY/PERFORMANCE CONSIDERATIONS\nSecurity: No security implications (purely visual). Performance: GPU-accelerated via Core Animation, \u003c1% CPU usage, \u003c1MB memory for animation layer, no battery impact in testing, 60fps maintained in all scenarios. Accessibility: Full compliance with macOS accessibility guidelines, Reduce Motion support mandatory, VoiceOver support verified, color contrast WCAG AA compliant. Resource usage: Animation layer released immediately on stop, no retained memory, no leaked animation objects, cleanup in deinit verified.\n\n## DEPENDENCIES\nSystem: SwiftUI (MenuBarExtra, .symbolEffect modifier - macOS 14+), SF Symbols (system icons), Accessibility framework (isReduceMotionEnabled), VoiceOver (accessibility labels). Internal: TransformationManager (@Published state), MenuBarView (observes and renders), AsyncExecutionEngine (triggers state changes), ErrorHandler (stops animation), StateManager (coordinates lifecycle). No external packages required (native SwiftUI).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:09:38.853962-05:00","updated_at":"2025-12-13T22:43:32.717739-05:00","closed_at":"2025-12-13T22:43:32.717739-05:00","dependencies":[{"issue_id":"oc-tmx.9","depends_on_id":"oc-tmx","type":"parent-child","created_at":"2025-12-12T22:09:38.854519-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-tmx.9","depends_on_id":"oc-tmx.8","type":"blocks","created_at":"2025-12-12T23:54:11.294036-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-u7w","title":"Show transformed text as hero item in history list","description":"The transformed text should be the prominent/hero element in each history list row. Users identify history items by the transformed output, not by metadata like transformation name or timestamp. Make the transformed text preview the primary visual element.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-16T20:39:21.555081-05:00","updated_at":"2025-12-16T20:39:21.555081-05:00"}
{"id":"oc-uzt","title":"Phase 1 - Menu Bar Shell","description":"Epic tracking all work to establish basic menu bar presence for Optimus Clip.\n\n## Background\nPhase 1 creates the essential user interface foundation: a menu bar-only application with no Dock presence. This is the first visible manifestation of Optimus Clip to the user.\n\n## Why Menu Bar Only?\nMenu bar apps are ideal for clipboard middleware because:\n- Always accessible without switching contexts (Cmd+Click or click)\n- Minimal screen real estate usage\n- Common pattern for utility/productivity tools on macOS\n- No Dock clutter for background services\n- Users expect clipboard tools to be \"always there but not in the way\"\n\n## Architecture Connection\nPhase 1 establishes the UI foundation for all future phases:\n- Phase 2 (Settings) will launch windows FROM the menu bar\n- Phase 3 (Clipboard Monitoring) status updates shown via menu bar icon states\n- Phase 4+ (AI/IPC) will surface interactions through menu bar menu items\n\nThe menu bar is the \"front door\" of the entire application.\n\n## Technical Approach\n- MenuBarExtra (SwiftUI) for declarative menu construction\n- NSApplicationDelegate with .accessory policy for Dock suppression\n- MenuBarExtraAccess package for NSStatusItem manipulation (icon states)\n- AppKit/SwiftUI hybrid approach for maximum flexibility\n\n## macOS-Specific Considerations\n- LSUIElement vs .accessory policy: We use .accessory for better control\n- Menu bar icon size constraints: 16x16pt @2x for Retina displays\n- Status item lifecycle: Must persist for app lifetime\n- Menu bar ordering: macOS controls position, we don't\n- Dark mode: Icon must adapt (use SF Symbols or template images)\n\n## Success Criteria\n- App appears in menu bar with clipboard icon\n- No Dock icon visible (LSMultipleInstancesProhibited + .accessory)\n- Menu shows Settings and Quit items\n- Icon can display 3 states: Idle, Disabled, Processing\n- pnpm start workflow launches app successfully\n- Single instance enforcement working","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-12-12T22:04:55.282972-05:00","updated_at":"2025-12-13T09:51:40.094394-05:00","closed_at":"2025-12-13T09:51:40.094394-05:00","dependencies":[{"issue_id":"oc-uzt","depends_on_id":"oc-8m8","type":"blocks","created_at":"2025-12-12T22:04:55.283758-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt","depends_on_id":"oc-9g6","type":"blocks","created_at":"2025-12-12T22:18:02.153156-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-uzt.1","title":"Implement App Entry Point with MenuBarExtra","description":"## Task: Implement App Entry Point with MenuBarExtra\n\n### BACKGROUND \u0026 CONTEXT\n\nThe @main App struct serves as the entry point for all SwiftUI-based macOS applications. For Optimus Clip, this entry point must establish a menu bar presence using MenuBarExtra, a declarative SwiftUI API introduced in macOS 13 that replaces the older imperative NSStatusItem approach.\n\nUnlike traditional macOS apps that appear in the Dock, Optimus Clip is a menu bar utility (similar to Dropbox, 1Password, or Alfred). This architectural decision means:\n- The app lives exclusively in the menu bar (top-right corner of screen)\n- No Dock icon appears during normal operation\n- The app launches silently in the background\n- All user interaction happens through the menu bar icon and its dropdown menu\n\nThis task establishes the root of the application SwiftUI view hierarchy. Every other UI component (settings window, permission dialogs, menu items) will be launched from this entry point.\n\nHistorical Context Why MenuBarExtra Prior to macOS 13, menu bar apps required imperative AppKit code using NSStatusBar.system.statusItem. This approach was verbose, error-prone, difficult to test, and hard to integrate with SwiftUI state management. MenuBarExtra brings the same declarative benefits to menu bar apps that SwiftUI brought to traditional UIs.\n\n### REAL-WORLD PROBLEM USE CASE\n\nScenario User Launches Optimus Clip for the First Time\n\n1. User double-clicks OptimusClip.app in Applications folder\n2. App launches without appearing in Dock (due to LSUIElement=true)\n3. Clipboard icon appears in menu bar (top-right, near clock and battery)\n4. User clicks icon shows dropdown menu with Settings and Quit\n5. User can now configure transformations and hotkeys\n\nWithout MenuBarExtra Old Approach requires 50+ lines of boilerplate AppKit code. With MenuBarExtra SwiftUI Approach reduces code by 80 percent and makes state management trivial.\n\n### WHY THIS APPROACH\n\nDecision MenuBarExtra vs NSStatusItem\n\nMenuBarExtra is the clear choice because Optimus Clip targets macOS 15+, SwiftUI is already used for Settings and Permissions windows, state management is simpler, and codebase stays modern and maintainable.\n\nDecision menu vs window Style\n\nMenuBarExtra supports two styles menu (standard dropdown) and window (custom popover). We choose menu because menu items are standard, discoverable, keyboard-navigable, and no need for complex UI in the menu bar dropdown.\n\nDecision System Image vs Custom Icon\n\nWe start with systemImage clipboard.fill because SF Symbols automatically adapt to light and dark mode, are retina-ready vectors, and match macOS design language.\n\n### TECHNICAL IMPLEMENTATION DETAILS\n\nFull Implementation:\n\n```swift\nimport SwiftUI\nimport MenuBarExtraAccess\n\n@main\nstruct OptimusClipApp: App {\n    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate\n    @StateObject private var menuBarState = MenuBarStateManager()\n    \n    var body: some Scene {\n        MenuBarExtra(\"Optimus Clip\", systemImage: \"clipboard.fill\") {\n            MenuBarMenuContent(menuBarState: menuBarState)\n        }\n        .menuBarExtraStyle(.menu)\n        .menuBarExtraAccess(isInserted: $menuBarState.statusItemInserted) { statusItem in\n            menuBarState.configureStatusItem(statusItem)\n        }\n    }\n}\n```\n\nBreaking Down the Components:\n\n1. @main Attribute designates this struct as the application entry point. Compiler generates main function automatically. Must conform to App protocol.\n\n2. @NSApplicationDelegateAdaptor bridges SwiftUI App to AppKit NSApplicationDelegate. Required for setting activation policy to accessory, handling applicationDidFinishLaunching lifecycle, and single instance enforcement.\n\n3. @StateObject for State Management creates observable state manager on first render. Survives view updates. Manages icon state, pulse animation trigger, and NSStatusItem configuration.\n\n4. MenuBarExtra Declaration with label Optimus Clip for accessibility, icon SF Symbol clipboard.fill, and content closure for menu items.\n\n5. MenuBarExtra Style uses menu for standard dropdown.\n\n6. MenuBarExtraAccess for Advanced Control provides access to underlying NSStatusItem for changing icon opacity, applying symbol effects, and customizing button appearance.\n\n### ARCHITECTURAL CONNECTIONS\n\nDependency Graph OptimusClipApp depends on AppDelegate for setting accessory activation policy and enforcing single instance. MenuBarStateManager manages icon states and triggers pulse animation. MenuBarMenuContent provides Settings and Quit menu items.\n\nInteraction with Other Phases:\n\nPhase 2 ClipboardMonitor will update menuBarState.iconState to processing during transformations and trigger pulse animation.\n\nPhase 3 Settings window launched from menu item. HotkeyManager registered in AppDelegate applicationDidFinishLaunching.\n\nPhase 4 Transformation pipeline calls menuBarState.startProcessing before API call and stopProcessing after completion.\n\nPhase 5 Async LLM calls update icon state for user feedback. Error states reflected in icon appearance.\n\n### EDGE CASES AND GOTCHAS\n\n1. Multiple MenuBarExtra Declarations: Cannot have multiple MenuBarExtra in same App. Solution: Use single MenuBarExtra with conditional content if needed.\n\n2. Missing LSUIElement: If Info.plist lacks LSUIElement=true, app appears in Dock (unwanted), Cmd+Tab switches to app (confusing), and window management issues occur. Solution: Verify Info.plist has LSUIElement true.\n\n3. MenuBarExtra Not Appearing: Symptoms App launches but no icon in menu bar. Causes include LSUIElement is false, activation policy not set to accessory, menu bar is full, or macOS version less than 13. Debugging: Add debug logging for activation policy and menu bar item count.\n\n4. Icon Flickering on State Changes: Cause rapid state updates trigger menu bar redraw. Solution: Debounce state changes in MenuBarStateManager.\n\n5. Memory Leaks from Retain Cycles: Danger MenuBarStateManager retains AppDelegate which retains MenuBarStateManager. Solution: Use weak references.\n\n6. SwiftUI Preview Crashes: Cause MenuBarExtra not supported in Xcode Previews. Solution: Use conditional compilation for previews.\n\n7. Icon Not Visible in Dark Mode: Cause using raster image without dark mode variant. Solution: Use SF Symbols which auto-adapt or provide separate dark mode icon.\n\n### TESTING REQUIREMENTS\n\nManual Testing Checklist:\n\n1. App Launch: Double-click OptimusClip.app in Finder, app launches without Dock icon appearing, clipboard icon appears in menu bar top-right, no console errors or warnings.\n\n2. Icon Visibility: Icon visible in light mode, icon visible in dark mode, icon positioned correctly right of other menu bar items, icon retains position after app restart.\n\n3. Menu Interaction: Click icon shows dropdown menu, click outside menu dismisses, press Escape dismisses, keyboard navigation works with Arrow keys.\n\n4. Menu Bar Overflow: Fill menu bar with many icons and verify Optimus Clip still accessible, macOS automatically collapses overflow items.\n\n5. Accessibility: Enable VoiceOver, focus menu bar shows Optimus Clip announced, menu items readable by VoiceOver.\n\n6. Performance: CPU usage less than 1 percent when idle, memory usage less than 50MB on launch, no main thread blocking.\n\n### SUCCESS CRITERIA\n\nDefinition of Done: OptimusClipApp struct compiles without warnings, app launches and icon appears in menu bar, no Dock icon visible, menu dropdown shows placeholder content, @StateObject and @NSApplicationDelegateAdaptor initialized correctly, code follows Swift 6 concurrency requirements, SwiftFormat and SwiftLint pass, commit message follows conventional commits format, task description updated with any deviations from plan.\n\nAcceptance Criteria:\n1. Run pnpm start and app builds and launches\n2. Verify icon appears in menu bar within 2 seconds\n3. Click icon shows menu even if empty or placeholder\n4. Quit app and icon disappears from menu bar\n5. Relaunch and icon reappears in same position\n\n### CONFIGURATION OPTIONS\n\nInfo.plist Requirements: LSUIElement true for menu bar app with no Dock icon, LSMultipleInstancesProhibited true for single instance, LSMinimumSystemVersion 15.0, CFBundleIdentifier com.yourname.optimusclip, CFBundleName OptimusClip, CFBundleDisplayName Optimus Clip.\n\nBuild Settings: Deployment Target macOS 15.0+, Swift Language Version 6.0, Enable Hardened Runtime Yes for notarization.\n\nPackage.swift Dependencies: MenuBarExtraAccess from orchetect version 1.0.0 or later.\n\n### SECURITY PERFORMANCE CONSIDERATIONS\n\nSecurity:\n1. No elevated privileges required for this task (Accessibility permission needed later)\n2. Code signing required for MenuBarExtra to appear (unsigned apps may be blocked)\n3. Hardened Runtime enabled prevents code injection\n\nPerformance:\n1. Lazy initialization: MenuBarStateManager only created when needed\n2. No blocking operations in App struct body\n3. Memory footprint approximately 10MB for MenuBarExtra infrastructure\n4. CPU usage less than 0.1 percent when idle (SwiftUI state observation is efficient)\n\nBest Practices: Keep App struct body simple with no heavy computation, use @StateObject for long-lived state that survives view updates, avoid @State for large objects which causes memory churn, profile with Instruments Time Profiler to catch regressions.\n\n### IMPLEMENTATION ORDER\n\n1. Create OptimusClipApp.swift in Sources/OptimusClip\n2. Define @main App struct with minimal MenuBarExtra\n3. Add @NSApplicationDelegateAdaptor with AppDelegate stub\n4. Add @StateObject for MenuBarStateManager stub\n5. Test build with swift build succeeds\n6. Test launch with pnpm start shows icon in menu bar\n7. Add MenuBarExtraAccess for NSStatusItem access\n8. Verify icon customization with opacity and symbol effects work\n9. Run SwiftFormat and SwiftLint\n10. Commit with message feat implement app entry point with MenuBarExtra\n\n### FILE STRUCTURE\n\nSources/OptimusClip/OptimusClipApp.swift is the @main App struct for this task\nSources/OptimusClip/AppDelegate.swift is NSApplicationDelegate for Task oc-uzt.2\nSources/OptimusClip/MenuBarStateManager.swift is Observable state for Task oc-uzt.6\nSources/OptimusClip/Views/MenuBar/MenuBarMenuContent.swift is Menu items for Task oc-uzt.4\n\n### REFERENCES\n\nMenuBarExtra Documentation at developer.apple.com/documentation/swiftui/menubarextra\nApp Protocol at developer.apple.com/documentation/swiftui/app\nNSApplicationDelegateAdaptor at developer.apple.com/documentation/swiftui/nsapplicationdelegateadaptor\nMenuBarExtraAccess Package at github.com/orchetect/MenuBarExtraAccess\nSF Symbols Browser at developer.apple.com/sf-symbols\n\n### ESTIMATED TIME: 120 minutes\n- Setup and scaffolding: 30 minutes\n- Implementation: 45 minutes\n- Testing and debugging: 30 minutes\n- Documentation and commit: 15 minutes\n\nPRIORITY: P1 (Blocks all other Phase 1 tasks)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:05:12.881933-05:00","updated_at":"2025-12-13T08:55:22.292276-05:00","closed_at":"2025-12-13T08:55:22.292276-05:00","dependencies":[{"issue_id":"oc-uzt.1","depends_on_id":"oc-uzt","type":"parent-child","created_at":"2025-12-12T22:05:12.882722-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.1","depends_on_id":"oc-8m8","type":"blocks","created_at":"2025-12-12T22:05:12.883389-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.1","depends_on_id":"oc-9g6","type":"blocks","created_at":"2025-12-12T23:54:04.515841-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-uzt.2","title":"Implement Application Delegate with Accessory Activation Policy","description":"Create NSApplicationDelegate class with .accessory activation policy to suppress Dock icon.\n\n## Background\nWhile MenuBarExtra provides the UI, we need NSApplicationDelegate for low-level application lifecycle control. The activation policy determines how the app appears in macOS UI (Dock, App Switcher, etc.).\n\n## Why .accessory Activation Policy?\nmacOS offers three activation policies:\n1. **.regular**: Normal app with Dock icon and menu bar (default)\n2. **.accessory**: Menu bar only, no Dock icon, visible in App Switcher\n3. **.prohibited**: No UI presence (background daemon)\n\nWe use .accessory because:\n- Suppresses Dock icon (key requirement)\n- Still allows menu bar presence\n- Visible in Cmd+Tab switcher (users can find/switch to it)\n- Can present windows when needed (Settings, future features)\n- More user-friendly than .prohibited\n\n## Alternative: LSUIElement\nInfo.plist can set `LSUIElement=true` for similar effect, but:\n- Less flexible (can't change at runtime)\n- .accessory provides programmatic control\n- Can't conditionally enable Dock icon later if needed\n- We use BOTH for defense-in-depth (LSUIElement as backup)\n\n## Technical Implementation\n```swift\nclass AppDelegate: NSObject, NSApplicationDelegate {\n    func applicationDidFinishLaunching(_ notification: Notification) {\n        // Set activation policy EARLY in launch\n        NSApp.setActivationPolicy(.accessory)\n        \n        // Additional setup:\n        // - Single instance check (separate task)\n        // - Initialize services\n        // - Setup IPC (future phases)\n    }\n    \n    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -\u003e Bool {\n        // Never quit when windows close (we're menu bar only)\n        return false\n    }\n    \n    func applicationWillTerminate(_ notification: Notification) {\n        // Cleanup: Stop monitoring, close connections, etc.\n    }\n}\n```\n\n## Integration with SwiftUI\nUse `@NSApplicationDelegateAdaptor` in App struct:\n```swift\n@NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate\n```\nThis bridges SwiftUI app lifecycle with traditional NSApplicationDelegate.\n\n## macOS-Specific Gotchas\n1. **Timing**: setActivationPolicy must be called BEFORE app fully launches (in applicationDidFinishLaunching)\n2. **Can't toggle back**: Once set to .accessory, can't change to .regular in same session\n3. **Window management**: .accessory apps can still show windows, but won't auto-activate\n4. **Quit behavior**: Must handle Cmd+Q and menu Quit explicitly (no automatic termination)\n\n## Architecture Connection\n- App struct (separate task) references this via @NSApplicationDelegateAdaptor\n- Single instance check (separate task) will be added to applicationDidFinishLaunching\n- Future IPC setup will hook into delegate methods\n- Settings window (Phase 2) presentation logic may hook here\n\n## Testing\n- Run app: No Dock icon should appear\n- Cmd+Tab: App should appear in switcher\n- Force quit: Should be able to quit via Activity Monitor or killall\n- Launch twice: Second instance should be prevented (separate task handles this)\n\n## Dependencies\n- Depends on Phase 0 scaffolding\n- Parallel with App Entry Point task (both needed, no strict ordering)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:05:33.321625-05:00","updated_at":"2025-12-13T08:59:44.33023-05:00","closed_at":"2025-12-13T08:59:44.33023-05:00","dependencies":[{"issue_id":"oc-uzt.2","depends_on_id":"oc-uzt","type":"parent-child","created_at":"2025-12-12T22:05:33.322175-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.2","depends_on_id":"oc-8m8","type":"blocks","created_at":"2025-12-12T22:05:33.322943-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.2","depends_on_id":"oc-uzt.1","type":"blocks","created_at":"2025-12-12T23:54:09.568409-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-uzt.3","title":"Implement Status Bar Icon with Three States","description":"Implement status bar icon with three visual states: Idle, Disabled, and Processing with animation.\n\n## Background\nThe menu bar icon is the primary visual feedback mechanism for Optimus Clip. It must communicate app status at a glance without being intrusive.\n\n## Why Three States?\n1. **Idle** (full opacity): App is running and monitoring clipboard normally\n2. **Disabled** (dimmed ~0.45 opacity): User has paused monitoring or app is inactive\n3. **Processing** (pulse animation): AI processing in progress, visual feedback for async operations\n\nThese states map to core app functionality:\n- Phase 3: Clipboard monitoring active/inactive\n- Phase 4: AI processing in progress\n- Future: Error states, queue status, etc.\n\n## Why Not Use MenuBarExtra's Built-in Image?\nMenuBarExtra's `systemImage:` parameter is static. We need dynamic state changes and animations, requiring access to the underlying NSStatusItem.\n\n## Technical Approach: MenuBarExtraAccess Package\n```swift\n// Use MenuBarExtraAccess package (https://github.com/orchetect/MenuBarExtraAccess)\nimport MenuBarExtraAccess\n\n@main\nstruct OptimusClipApp: App {\n    @StateObject private var menuBarState = MenuBarStateManager()\n    \n    var body: some Scene {\n        MenuBarExtra {\n            // Menu content\n        } label: {\n            Image(systemName: \"clipboard.fill\")\n                .symbolEffect(.pulse, options: .repeating, value: menuBarState.pulseID)\n                .opacity(menuBarState.iconOpacity)\n        }\n        .menuBarExtraAccess(isInserted: $menuBarState.isMenuBarItemInserted) { statusItem in\n            // Access to NSStatusItem for advanced control if needed\n            statusItem?.button?.appearsDisabled = false\n        }\n    }\n}\n```\n\n## State Management (MenuBarStateManager)\n```swift\n@MainActor\nclass MenuBarStateManager: ObservableObject {\n    @Published var iconState: IconState = .idle\n    @Published var pulseID: Int = 0 // Increment to trigger pulse\n    @Published var isMenuBarItemInserted: Bool = false\n    \n    enum IconState {\n        case idle\n        case disabled\n        case processing\n    }\n    \n    var iconOpacity: Double {\n        switch iconState {\n        case .idle, .processing: return 1.0\n        case .disabled: return 0.45\n        }\n    }\n    \n    func startProcessing() {\n        iconState = .processing\n        pulseID += 1 // Triggers .pulse animation\n    }\n    \n    func stopProcessing() {\n        iconState = .idle\n    }\n    \n    func setDisabled(_ disabled: Bool) {\n        iconState = disabled ? .disabled : .idle\n    }\n}\n```\n\n## Icon Choice: SF Symbol vs Custom\n**Decision: Start with SF Symbol \"clipboard.fill\"**\n- Pros: Automatic dark mode, retina support, system consistency\n- Cons: Less unique, can't fully customize\n- Future: Can add custom icon in Phase 2 with asset catalog\n\n## Animation Details\n- `.symbolEffect(.pulse)`: Built-in SwiftUI animation for SF Symbols\n- `options: .repeating`: Continuous pulse during processing\n- `value: pulseID`: Triggers animation when ID changes\n- Smooth, non-intrusive visual feedback\n\n## macOS Rendering Considerations\n1. **Template Rendering**: SF Symbols render as template images (adapt to menu bar color)\n2. **Dark Mode**: Automatic color inversion\n3. **Retina**: Vector symbols scale perfectly\n4. **Size**: Menu bar auto-sizes to ~16pt (don't override)\n5. **Accessibility**: VoiceOver should read status changes (add accessibilityLabel)\n\n## Architecture Integration\n- MenuBarStateManager injected into App struct (@StateObject)\n- Phase 3 (Clipboard Monitor) will call startProcessing/stopProcessing\n- Phase 2 (Settings) will call setDisabled when user pauses\n- Future: Error states, notifications, badge counts\n\n## Testing Strategy\n1. **Visual test**: Change iconState and verify opacity/animation\n2. **Performance**: Ensure pulse animation doesn't spike CPU\n3. **Dark mode**: Toggle system appearance and verify icon visibility\n4. **Accessibility**: VoiceOver should announce status changes\n\n## Dependencies\n- Depends on App Entry Point (oc-uzt.1) being implemented first\n- Requires MenuBarExtraAccess package (add via SPM in Phase 0)\n- Blocks: State Management task (this defines the manager structure)\n\n## Gotchas\n1. **Animation Timing**: .pulse effect duration not customizable (use ID increment pattern)\n2. **NSStatusItem Access**: Only available through MenuBarExtraAccess, not directly via MenuBarExtra\n3. **Memory**: @StateObject ensures single instance lifecycle management\n4. **Thread Safety**: @MainActor on MenuBarStateManager prevents threading issues","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:05:56.879645-05:00","updated_at":"2025-12-13T09:25:53.893857-05:00","closed_at":"2025-12-13T09:25:53.893857-05:00","dependencies":[{"issue_id":"oc-uzt.3","depends_on_id":"oc-uzt","type":"parent-child","created_at":"2025-12-12T22:05:56.880225-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.3","depends_on_id":"oc-uzt.1","type":"blocks","created_at":"2025-12-12T22:05:56.880864-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-uzt.4","title":"Implement Menu Bar Menu Items (Settings and Quit)","description":"Implement basic menu bar menu structure with Settings and Quit items.\n\n## Background\nMenu bar apps need minimal UI for user control. Phase 1 establishes the foundational menu structure that will be expanded in later phases.\n\n## Why These Items?\n1. **Settings/Preferences**: Standard for macOS apps, required for Phase 2 (Settings window)\n2. **Quit**: Required since .accessory apps don't auto-quit on window close\n3. **Keyboard Shortcuts**: Cmd+, (Settings) and Cmd+Q (Quit) follow macOS conventions\n\nFuture phases will add:\n- Clipboard history list\n- Enable/Disable toggle\n- About panel\n- Check for Updates\n\n## Technical Implementation\n```swift\nMenuBarExtra(\"Optimus Clip\", systemImage: \"clipboard.fill\") {\n    Button(\"Settings...\") {\n        // Will open settings window in Phase 2\n        // For Phase 1: Just print or show alert\n    }\n    .keyboardShortcut(\",\", modifiers: .command)\n    \n    Divider()\n    \n    Button(\"Quit Optimus Clip\") {\n        NSApplication.shared.terminate(nil)\n    }\n    .keyboardShortcut(\"q\", modifiers: .command)\n}\n```\n\n## Menu Structure Best Practices\n1. **Item Order** (macOS convention):\n   - Primary actions (clipboard items, future)\n   - Divider\n   - Secondary actions (Settings)\n   - Divider\n   - Quit (always last)\n\n2. **Naming**:\n   - \"Settings...\" (ellipsis indicates opens window)\n   - \"Quit Optimus Clip\" (explicit app name for clarity)\n\n3. **Shortcuts**:\n   - Cmd+, is universal Settings shortcut on macOS\n   - Cmd+Q is universal Quit shortcut\n\n## Why SwiftUI Button vs NSMenuItem?\n- **SwiftUI Button**: Declarative, type-safe, easier to test\n- **NSMenuItem**: More control, required for advanced features (badges, custom views)\n- **Decision**: Start with SwiftUI Button, migrate specific items to NSMenuItem if needed\n\n## Settings Button Behavior (Phase 1)\nSince Settings window isn't implemented yet (Phase 2):\n```swift\nButton(\"Settings...\") {\n    #if DEBUG\n    print(\"Settings tapped - will open window in Phase 2\")\n    #else\n    // Show alert that settings coming soon\n    let alert = NSAlert()\n    alert.messageText = \"Settings\"\n    alert.informativeText = \"Settings window coming in Phase 2\"\n    alert.alertStyle = .informational\n    alert.runModal()\n    #endif\n}\n```\n\n## Quit Button Behavior\n```swift\nButton(\"Quit Optimus Clip\") {\n    // Cleanup before quit (if needed)\n    // - Stop clipboard monitoring\n    // - Save state\n    // - Close connections\n    NSApplication.shared.terminate(nil)\n}\n```\n\n## macOS-Specific Considerations\n1. **Cmd+Q vs terminate**: \n   - Cmd+Q should work even when menu not open (handled by NSApplication)\n   - Our button provides explicit UI affordance\n2. **Menu Item State**:\n   - Can disable items with `.disabled(condition)`\n   - Future: Disable Settings if already open\n3. **Accessibility**:\n   - VoiceOver reads menu items automatically\n   - Keyboard shortcuts announced\n4. **Dark Mode**:\n   - SwiftUI handles automatically\n   - Dividers render appropriately\n\n## Architecture Integration\n- Settings button will trigger window presentation in Phase 2\n- Future phases add items ABOVE first divider:\n  ```\n  [Clipboard History Items]\n  Toggle Monitoring\n  ------- (divider)\n  Settings...\n  ------- (divider)\n  Quit\n  ```\n\n## Testing Strategy\n1. Click menu bar icon: Menu should appear\n2. Click Settings: Should show debug message or alert\n3. Cmd+,: Should trigger Settings action\n4. Click Quit: App should terminate\n5. Cmd+Q: App should terminate (even without menu open)\n6. VoiceOver: Verify all items are readable\n\n## Dependencies\n- Depends on App Entry Point (oc-uzt.1) - need MenuBarExtra structure\n- Parallel with Icon States (oc-uzt.3) - no strict ordering\n- Blocks Phase 2 Settings Window (menu item will trigger window)\n\n## Future Expansion Points\n```swift\n// Phase 2: Add toggle\nToggle(\"Enable Monitoring\", isOn: $menuBarState.isMonitoring)\n\n// Phase 3: Add clipboard history\nForEach(clipboardHistory.recentItems) { item in\n    Button(item.preview) {\n        item.paste()\n    }\n}\n\n// Phase 4: Add status indicator\nText(\"Processing...\").font(.caption)\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:06:22.55298-05:00","updated_at":"2025-12-13T09:24:05.707376-05:00","closed_at":"2025-12-13T09:24:05.707376-05:00","dependencies":[{"issue_id":"oc-uzt.4","depends_on_id":"oc-uzt","type":"parent-child","created_at":"2025-12-12T22:06:22.553609-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.4","depends_on_id":"oc-uzt.1","type":"blocks","created_at":"2025-12-12T22:06:22.554377-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-uzt.5","title":"Implement Single Instance Enforcement","description":"## Task: Implement Single Instance Enforcement\n\n### BACKGROUND \u0026 CONTEXT\n\nSingle instance enforcement ensures that only one copy of Optimus Clip can run at any given time. This is a critical requirement for menu bar applications because multiple instances would cause severe conflicts and undefined behavior.\n\nWhy Single Instance Matters for Optimus Clip:\n\n1. **Clipboard Monitoring Conflicts**: Phase 2 implements clipboard polling with DispatchSourceTimer at 150ms intervals. If two instances run simultaneously, both will detect clipboard changes and attempt to transform the same content, leading to race conditions where the clipboard gets overwritten multiple times with unpredictable results.\n\n2. **Hotkey Registration Conflicts**: Phase 3 registers global hotkeys using the KeyboardShortcuts package. macOS allows only one application to register a given hotkey combination. If two instances try to register the same hotkey (e.g., Cmd+Opt+V), the second registration will silently fail, leaving the user confused about why hotkeys don't work.\n\n3. **Settings Corruption**: Both instances would read and write to the same UserDefaults and potentially the same SQLite database (Phase 6). Concurrent writes without proper locking can corrupt settings or history data.\n\n4. **Resource Waste**: Each instance consumes approximately 50-80MB of memory and registers system-wide event taps for Accessibility. Running multiple copies is wasteful and may degrade system performance.\n\n5. **User Confusion**: Users expect menu bar apps to behave like system utilities. Seeing two identical clipboard icons or receiving duplicate notifications would be confusing and unprofessional.\n\nHistorical Context: macOS provides LSMultipleInstancesProhibited in Info.plist, but this alone is insufficient because:\n- It can be bypassed with `open -n /Applications/OptimusClip.app` command\n- It doesn't work reliably if the app crashes and leaves stale state\n- It provides no feedback to the user about why the second instance didn't launch\n\nTherefore, we implement a two-layer defense: Info.plist configuration plus programmatic runtime checking.\n\n### REAL-WORLD PROBLEM USE CASE\n\nScenario 1: User Accidentally Double-Clicks\n\n1. User opens Finder and navigates to Applications folder\n2. User double-clicks OptimusClip.app\n3. App launches successfully, icon appears in menu bar\n4. User forgets they already launched it\n5. User double-clicks OptimusClip.app again (muscle memory)\n6. macOS blocks second launch due to LSMultipleInstancesProhibited=true\n7. Nothing happens (no error, no feedback)\n8. User is confused but the system is protected\n\nScenario 2: Developer Uses open -n Command\n\n1. Developer is testing the app\n2. First instance is running\n3. Developer runs `open -n /Applications/OptimusClip.app` to force new instance\n4. macOS bypasses Info.plist restriction (by design)\n5. Second instance starts launching\n6. AppDelegate.applicationDidFinishLaunching runs programmatic check\n7. Code detects existing instance via NSWorkspace\n8. Alert dialog shows: \"Optimus Clip is already running\"\n9. Second instance calls NSApp.terminate(nil) and exits cleanly\n10. First instance continues running normally\n\nScenario 3: Crash Recovery\n\n1. First instance crashes due to unhandled exception\n2. Process terminates but may leave stale locks or IPC endpoints\n3. User relaunches app\n4. Programmatic check runs\n5. NSWorkspace.shared.runningApplications doesn't find crashed process\n6. New instance launches successfully\n7. No stale state causes problems\n\nWithout Single Instance Enforcement:\n\n- Two instances fight over clipboard ownership\n- Hotkeys registered by first instance stop working\n- Settings changes in one instance overwrite the other\n- Memory usage doubles\n- User sees duplicate menu bar icons (confusing)\n- Transformation history becomes corrupted\n\n### WHY THIS APPROACH\n\nDecision: Two-Layer Defense (Info.plist + Programmatic Check)\n\n| Approach | Pros | Cons |\n|----------|------|------|\n| **Info.plist only** | Simple, one-line change | Can be bypassed with open -n, no user feedback |\n| **Programmatic check only** | Can show alert to user | Requires code, runs after app starts |\n| **Both (chosen)** | Defense in depth, catches bypasses | Slightly more complex |\n\nWe use both because:\n1. LSMultipleInstancesProhibited catches 99% of cases (normal double-click)\n2. Programmatic check catches edge cases (open -n, developer mistakes)\n3. Combined approach provides user feedback when needed\n4. Minimal complexity cost (less than 20 lines of code)\n\nDecision: NSWorkspace vs File-Based Locking\n\nAlternative approaches considered:\n\n**File-Based Locking (e.g., /tmp/optimusclip.lock)**\n```swift\n// Create lock file on launch\nlet lockPath = \"/tmp/optimusclip.lock\"\nif FileManager.default.fileExists(atPath: lockPath) {\n    // Another instance running\n} else {\n    FileManager.default.createFile(atPath: lockPath, contents: Data())\n}\n```\n\nProblems:\n- Stale locks if app crashes (requires cleanup logic)\n- Race condition between check and create (requires atomic operations)\n- Permissions issues if lock file owned by different user\n- Doesn't work reliably with sandboxing\n\n**NSWorkspace.runningApplications (chosen)**\n```swift\nlet running = NSWorkspace.shared.runningApplications(withBundleIdentifier: \"com.yourname.optimusclip\")\nif running.count \u003e 1 {\n    // Another instance detected\n}\n```\n\nAdvantages:\n- No stale state (kernel tracks running processes)\n- No race conditions (atomic kernel operation)\n- Works across all user sessions\n- No file system dependencies\n- Sandboxing-friendly\n\nDecision: Alert vs Silent Termination\n\nWhen second instance detected, we have options:\n1. **Silent termination** (just quit)\n2. **Alert dialog** (inform user)\n3. **Activate existing instance** (bring to front)\n\nWe choose Alert Dialog because:\n- User feedback is good UX (explains why nothing happened)\n- Brings existing instance to front after dismissing alert\n- Only shown in edge cases (open -n scenarios)\n- Aligns with macOS conventions (Xcode, Terminal do this)\n\n### TECHNICAL IMPLEMENTATION DETAILS\n\nFull Implementation in AppDelegate:\n\n```swift\nimport Cocoa\n\nclass AppDelegate: NSObject, NSApplicationDelegate {\n    func applicationDidFinishLaunching(_ notification: Notification) {\n        // Set activation policy for menu bar app (Task oc-uzt.2)\n        NSApp.setActivationPolicy(.accessory)\n        \n        // Single instance enforcement (THIS TASK)\n        enforceS singleInstance()\n        \n        // Other initialization...\n    }\n    \n    private func enforceSingleInstance() {\n        let bundleID = Bundle.main.bundleIdentifier ?? \"com.unknown.optimusclip\"\n        \n        // Get all running instances of this app\n        let runningInstances = NSWorkspace.shared.runningApplications(\n            withBundleIdentifier: bundleID\n        )\n        \n        // If count \u003e 1, another instance is already running\n        guard runningInstances.count \u003e 1 else {\n            return  // We're the only instance, continue normally\n        }\n        \n        // Find the other instance (oldest one)\n        let sortedByLaunchDate = runningInstances.sorted {\n            ($0.launchDate ?? Date.distantPast) \u003c ($1.launchDate ?? Date.distantPast)\n        }\n        \n        let firstInstance = sortedByLaunchDate.first\n        let currentPID = ProcessInfo.processInfo.processIdentifier\n        \n        // If we're not the first instance, we should quit\n        if firstInstance?.processIdentifier != currentPID {\n            showAlreadyRunningAlert(existingInstance: firstInstance)\n            NSApp.terminate(nil)\n        }\n    }\n    \n    private func showAlreadyRunningAlert(existingInstance: NSRunningApplication?) {\n        let alert = NSAlert()\n        alert.messageText = \"Optimus Clip is Already Running\"\n        alert.informativeText = \"Another instance of Optimus Clip is already running. Only one instance can run at a time to prevent conflicts.\"\n        alert.alertStyle = .informational\n        alert.icon = NSImage(systemSymbolName: \"exclamationmark.triangle\", accessibilityDescription: \"Warning\")\n        \n        // Add button to activate existing instance\n        alert.addButton(withTitle: \"OK\")\n        \n        // Run modal (blocks until dismissed)\n        alert.runModal()\n        \n        // Try to activate the existing instance\n        existingInstance?.activate(options: [.activateIgnoringOtherApps])\n    }\n}\n```\n\nBreaking Down the Implementation:\n\n**1. Bundle Identifier Lookup**\n```swift\nlet bundleID = Bundle.main.bundleIdentifier ?? \"com.unknown.optimusclip\"\n```\n- Gets bundle ID from Info.plist (set in Phase 0)\n- Fallback to default if nil (should never happen in practice)\n- Critical for identifying our app among all running processes\n\n**2. Query Running Applications**\n```swift\nlet runningInstances = NSWorkspace.shared.runningApplications(\n    withBundleIdentifier: bundleID\n)\n```\n- NSWorkspace is macOS API for workspace management\n- `runningApplications(withBundleIdentifier:)` filters by bundle ID\n- Returns array of NSRunningApplication objects\n- Includes current process (so count \u003e= 1 always)\n\n**3. Early Return for Single Instance**\n```swift\nguard runningInstances.count \u003e 1 else {\n    return  // We're the only instance\n}\n```\n- If count is 1, we're the only instance (normal case)\n- If count \u003e 1, multiple instances detected (proceed to termination)\n\n**4. Determine Which Instance to Keep**\n```swift\nlet sortedByLaunchDate = runningInstances.sorted {\n    ($0.launchDate ?? Date.distantPast) \u003c ($1.launchDate ?? Date.distantPast)\n}\n\nlet firstInstance = sortedByLaunchDate.first\nlet currentPID = ProcessInfo.processInfo.processIdentifier\n\nif firstInstance?.processIdentifier != currentPID {\n    // Current instance is not the first, so we should quit\n}\n```\n- Sort by launch date (oldest first)\n- Compare current process ID with first instance\n- If we're not the first, we're the duplicate and should quit\n- This ensures the original instance stays running (user expectation)\n\n**5. Show Alert to User**\n```swift\nlet alert = NSAlert()\nalert.messageText = \"Optimus Clip is Already Running\"\nalert.informativeText = \"Another instance is already running...\"\nalert.alertStyle = .informational\nalert.icon = NSImage(systemSymbolName: \"exclamationmark.triangle\", ...)\nalert.runModal()\n```\n- NSAlert provides standard macOS alert dialog\n- `.informational` style (blue icon, not critical)\n- Custom icon with SF Symbol\n- `runModal()` blocks until user dismisses\n- Prevents \"silent failure\" confusion\n\n**6. Activate Existing Instance**\n```swift\nexistingInstance?.activate(options: [.activateIgnoringOtherApps])\n```\n- Brings first instance to front\n- `.activateIgnoringOtherApps` ensures it activates even if another app is fullscreen\n- Good UX: user sees the existing instance after dismissing alert\n\n**7. Clean Termination**\n```swift\nNSApp.terminate(nil)\n```\n- Gracefully terminates current instance\n- Calls `applicationWillTerminate` if implemented\n- Releases resources properly\n- Exits with status code 0 (success)\n\n### ARCHITECTURAL CONNECTIONS\n\nSingle Instance Enforcement integrates with:\n\n**Phase 0 (Project Scaffolding):**\n- Requires `LSMultipleInstancesProhibited=true` in Info.plist\n- Requires valid `CFBundleIdentifier` in Info.plist\n- Relies on bundle ID being unique on system\n\n**Phase 1 (Menu Bar Shell):**\n- Called from AppDelegate.applicationDidFinishLaunching\n- Must run before any expensive initialization (hotkey registration, clipboard monitoring)\n- Blocks AppDelegate tasks oc-uzt.3 and oc-uzt.4\n\n**Phase 2 (Clipboard \u0026 Paste):**\n- Prevents multiple ClipboardMonitors fighting over pasteboard\n- Ensures only one timer polling clipboard\n- Avoids race conditions in self-write marker detection\n\n**Phase 3 (Hotkeys \u0026 Settings):**\n- Prevents duplicate hotkey registrations\n- Ensures settings window opens from correct instance\n- Avoids UserDefaults concurrent write conflicts\n\n**Phase 4 (Transformation Engine):**\n- Single transformation pipeline running\n- No duplicate transformation history entries\n- Predictable transformation state\n\n**Phase 5 (LLM Integration):**\n- No duplicate API calls to providers\n- API key access not contended\n- Rate limits applied to single instance\n\n**Phase 6 (Data \u0026 Security):**\n- Single SwiftData context (no database corruption)\n- Single Keychain access pattern\n- Launch-at-login registers one service\n\n### EDGE CASES AND GOTCHAS\n\n**1. Race Condition on Simultaneous Launch**\n\n**Scenario:** User triple-clicks app icon rapidly, launching 3 instances nearly simultaneously.\n\n**Problem:** All instances might pass the `runningInstances.count \u003e 1` check before any terminates.\n\n**Mitigation:**\n- `LSMultipleInstancesProhibited` in Info.plist prevents most cases\n- Launch date sorting ensures oldest instance survives\n- Even if race occurs, harm is minimal (one instance survives)\n\n**2. Stale Process After Crash**\n\n**Scenario:** App crashes with SIGSEGV, kernel immediately removes from running applications list.\n\n**Impact:** No stale state remains, next launch succeeds.\n\n**Why This Works:** NSWorkspace queries kernel, which knows about crashed processes immediately.\n\n**3. Different User Accounts**\n\n**Scenario:** User A runs Optimus Clip, User B also runs it (Fast User Switching).\n\n**Expected Behavior:** Both instances should run (different users, different contexts).\n\n**Why It Works:** NSWorkspace.runningApplications only sees processes in current session.\n\n**4. Developer Build vs App Store Build**\n\n**Scenario:** Developer has debug build and release build with same bundle ID.\n\n**Problem:** Both would detect each other and one would quit.\n\n**Solution:** Use different bundle IDs for debug builds:\n```swift\n// In Phase 0, set debug bundle ID\n// Debug: com.yourname.optimusclip.debug\n// Release: com.yourname.optimusclip\n```\n\n**5. Sandboxing Restrictions**\n\n**Scenario:** App is sandboxed, NSWorkspace restricted.\n\n**Mitigation:**\n- Add `com.apple.security.automation.apple-events` entitlement\n- Or use XPC service for instance checking (overkill for MVP)\n\nFor MVP, Optimus Clip is NOT sandboxed (Accessibility permission required), so this is not an issue.\n\n**6. Launch at Login Race Condition**\n\n**Scenario:** User logs in, app configured to launch at login, user also manually launches app from Dock.\n\n**Behavior:**\n1. Login item launches first\n2. Manual launch detected as second instance\n3. Manual launch shows alert and quits\n4. Original instance continues running\n\n**User Experience:** Slightly confusing alert, but correct behavior.\n\n**Future Improvement:** Detect if launch is manual vs automatic, suppress alert for manual launches if login item already running.\n\n**7. App in Different Locations**\n\n**Scenario:** User has OptimusClip.app in both /Applications and ~/Applications.\n\n**Problem:** Both have same bundle ID, should only one run?\n\n**Behavior:** NSWorkspace matches by bundle ID, not path. First launched instance survives, regardless of location.\n\n**User Impact:** Confusing if user expects both to run. Document that only one instance allowed system-wide.\n\n**8. Accessibility Alert Timing**\n\n**Scenario:** Second instance shows \"already running\" alert, but first instance is showing Accessibility permission alert.\n\n**User Experience:** Two alerts on screen simultaneously (confusing).\n\n**Mitigation:** Rare in practice. Accessibility alert is modal and blocks first instance, so second instance alert appears after.\n\n### TESTING REQUIREMENTS\n\n**Manual Testing Checklist:**\n\n1. **Normal Double-Click (Info.plist Protection)**\n   - [ ] Launch app normally (double-click)\n   - [ ] Icon appears in menu bar\n   - [ ] Double-click app again\n   - [ ] Nothing happens (no second icon)\n   - [ ] No alert shown (Info.plist blocked it silently)\n\n2. **Force Multiple Instances (Programmatic Protection)**\n   - [ ] Launch app normally\n   - [ ] In Terminal, run: `open -n /Applications/OptimusClip.app`\n   - [ ] Alert appears: \"Optimus Clip is Already Running\"\n   - [ ] Click OK\n   - [ ] Second instance quits\n   - [ ] First instance still running\n\n3. **Existing Instance Activation**\n   - [ ] Launch first instance\n   - [ ] Open Settings window\n   - [ ] Force second instance with `open -n`\n   - [ ] Dismiss alert\n   - [ ] First instance activates (Settings window comes to front)\n\n4. **Rapid Launch (Race Condition)**\n   - [ ] Quit app if running\n   - [ ] Triple-click app icon rapidly\n   - [ ] Only one instance runs\n   - [ ] No duplicate menu bar icons\n\n5. **Crash Recovery**\n   - [ ] Launch app\n   - [ ] Force crash with `kill -9 \u003cpid\u003e`\n   - [ ] Launch app again immediately\n   - [ ] New instance launches successfully\n   - [ ] No stale lock errors\n\n6. **Different User Accounts (if available)**\n   - [ ] User A launches app\n   - [ ] Switch to User B (Fast User Switching)\n   - [ ] User B launches app\n   - [ ] Both instances run (separate sessions)\n\n**Automated Testing:**\n\n```swift\nimport Testing\nimport AppKit\n\n@Test func testSingleInstanceDetection() async throws {\n    // Launch first instance\n    let firstInstance = try await launchTestApp()\n    #expect(firstInstance.isRunning == true)\n    \n    // Attempt to launch second instance\n    let secondInstance = try await launchTestApp()\n    \n    // Wait for second instance to terminate\n    try await Task.sleep(for: .seconds(2))\n    \n    // Verify second instance quit\n    #expect(secondInstance.isRunning == false)\n    #expect(firstInstance.isRunning == true)\n    \n    // Clean up\n    firstInstance.terminate()\n}\n\n@Test func testBundleIdentifierMatching() {\n    let bundleID = \"com.yourname.optimusclip\"\n    let running = NSWorkspace.shared.runningApplications(withBundleIdentifier: bundleID)\n    \n    // Should find at least current process\n    #expect(running.count \u003e= 1)\n    \n    // Current process should be in list\n    let currentPID = ProcessInfo.processInfo.processIdentifier\n    let containsCurrent = running.contains { $0.processIdentifier == currentPID }\n    #expect(containsCurrent == true)\n}\n```\n\n### SUCCESS CRITERIA\n\n**Definition of Done:**\n- [ ] enforceSingleInstance method implemented in AppDelegate\n- [ ] LSMultipleInstancesProhibited=true in Info.plist (verify)\n- [ ] Alert dialog shows correct messaging\n- [ ] Second instance terminates cleanly\n- [ ] First instance remains running\n- [ ] Existing instance activates after alert dismissed\n- [ ] No stale locks after crash\n- [ ] Code follows Swift 6 concurrency requirements\n- [ ] SwiftFormat and SwiftLint pass\n- [ ] All manual tests pass\n- [ ] Commit message follows conventional commits format\n\n**Acceptance Criteria:**\n1. Normal double-click does NOT show alert (Info.plist blocks)\n2. `open -n` command shows alert and quits second instance\n3. First instance continues running after second quits\n4. No duplicate menu bar icons ever appear\n5. Crash recovery works (new instance launches)\n\n### CONFIGURATION OPTIONS\n\n**Info.plist (Required):**\n```xml\n\u003c!-- Single Instance Enforcement (Layer 1) --\u003e\n\u003ckey\u003eLSMultipleInstancesProhibited\u003c/key\u003e\n\u003ctrue/\u003e\n\n\u003c!-- Bundle ID (Must be unique) --\u003e\n\u003ckey\u003eCFBundleIdentifier\u003c/key\u003e\n\u003cstring\u003ecom.yourname.optimusclip\u003c/string\u003e\n```\n\n**AppDelegate Configuration:**\n```swift\n// Optional: Customize alert text\nprivate let alertTitle = \"Optimus Clip is Already Running\"\nprivate let alertMessage = \"Another instance of Optimus Clip is already running. Only one instance can run at a time to prevent conflicts.\"\n\n// Optional: Disable alert for silent behavior\nprivate let showAlert = true  // Set to false for silent termination\n```\n\n### SECURITY PERFORMANCE CONSIDERATIONS\n\n**Security:**\n1. **No privilege escalation risk**: Single instance check runs with normal user permissions\n2. **No sensitive data in alert**: Alert text does not leak information about user or system state\n3. **Process isolation**: NSWorkspace only sees processes in current user session (secure)\n4. **No file system locks**: Avoids race conditions and stale locks\n\n**Performance:**\n1. **Fast check**: NSWorkspace query is O(n) where n = running apps, typically \u003c 100ms\n2. **Early termination**: Runs in applicationDidFinishLaunching before expensive init\n3. **No polling**: Check happens once at launch, no ongoing overhead\n4. **Memory impact**: Negligible (no persistent state)\n\n**Best Practices:**\n- Run check as early as possible in app lifecycle\n- Terminate before registering global hotkeys (avoid cleanup)\n- Terminate before starting clipboard monitoring (avoid conflicts)\n- Use clean termination (NSApp.terminate) not exit() or abort()\n\n### IMPLEMENTATION ORDER\n\n1. **Verify Info.plist** has LSMultipleInstancesProhibited=true (from Phase 0)\n2. **Add enforceSingleInstance method** to AppDelegate\n3. **Implement NSWorkspace query** and count check\n4. **Implement alert dialog** with proper messaging\n5. **Test with open -n** to verify alert appears\n6. **Test activation** of existing instance\n7. **Test crash recovery** with kill -9\n8. **Run SwiftFormat and SwiftLint**\n9. **Commit:** \"feat: implement single instance enforcement\"\n\n### FILE STRUCTURE\n\n```\nSources/OptimusClip/\n├── OptimusClipApp.swift          # @main App struct (Task oc-uzt.1)\n└── AppDelegate.swift             # enforceSingleInstance method (THIS TASK)\n```\n\n### REFERENCES\n\n- [NSWorkspace Documentation](https://developer.apple.com/documentation/appkit/nsworkspace)\n- [NSRunningApplication](https://developer.apple.com/documentation/appkit/nsrunningapplication)\n- [LSMultipleInstancesProhibited](https://developer.apple.com/documentation/bundleresources/information_property_list/lsmultipleinstancesprohibited)\n- [NSAlert](https://developer.apple.com/documentation/appkit/nsalert)\n- [Application Lifecycle](https://developer.apple.com/documentation/appkit/nsapplicationdelegate)\n\n### ESTIMATED TIME: 120 minutes\n- Implementation: 45 minutes\n- Testing normal and edge cases: 45 minutes\n- Documentation and commit: 30 minutes\n\n**PRIORITY: P2** (Important for stability, but not blocking other Phase 1 tasks)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T22:06:59.952826-05:00","updated_at":"2025-12-13T09:04:42.243447-05:00","closed_at":"2025-12-13T09:04:42.243447-05:00","dependencies":[{"issue_id":"oc-uzt.5","depends_on_id":"oc-uzt","type":"parent-child","created_at":"2025-12-12T22:06:59.953501-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.5","depends_on_id":"oc-uzt.2","type":"blocks","created_at":"2025-12-12T22:06:59.954183-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-uzt.6","title":"Implement Menu Bar State Management (ObservableObject)","description":"BACKGROUND \u0026 CONTEXT:\nThe Menu Bar State Manager is the central nervous system for Optimus Clip's visual presence. It's an ObservableObject that coordinates all icon state changes (idle, disabled, processing) and animations across the entire app lifecycle.\n\nWhy we need centralized state management:\n1. **Multiple State Triggers:** The icon needs to respond to events from disparate sources:\n   - User toggling transformations on/off (Settings window)\n   - Clipboard monitor detecting content changes (Phase 2)\n   - LLM processor starting/completing transformations (Phase 5)\n   - Error conditions requiring user notification\n2. **SwiftUI Reactivity:** MenuBarExtra is SwiftUI-based. Changes to icon appearance must flow through @Published properties to trigger view updates\n3. **Thread Safety:** Menu bar icon lives on the main thread (AppKit requirement). All state mutations must be @MainActor-isolated to prevent crashes\n4. **Animation Coordination:** The pulse effect requires state ID incrementing to trigger SwiftUI's .symbolEffect(.pulse) modifier\n\nWithout this manager:\n- State would be scattered across multiple files\n- Threading bugs would cause NSView crashes\n- Animation triggers would be inconsistent\n- Testing would require launching full UI\n\nREAL-WORLD PROBLEM/USE CASE:\nUser scenario showing state transitions:\n1. App launches → Manager initializes in `.idle` state → Icon appears normal in menu bar\n2. User opens Settings → Disables transformations toggle → Manager transitions to `.disabled` → Icon dims to 45% opacity\n3. User re-enables transformations → Manager transitions back to `.idle` → Icon returns to full opacity\n4. User copies CLI output and hits Cmd+Option+V (LLM transformation hotkey)\n5. Clipboard monitor detects content → Calls `menuBarState.startProcessing()`\n6. Manager increments `pulseID` → `.symbolEffect(.pulse)` triggers → Icon pulses\n7. Manager sets state to `.processing` → Icon shows \"busy\" appearance\n8. LLM returns result after 2 seconds → Calls `menuBarState.stopProcessing()`\n9. Manager resets to `.idle` → Pulse stops → User sees completion\n\nWithout proper state management:\n- User hits hotkey, icon doesn't pulse → No feedback transformation is running\n- LLM takes 30 seconds → User thinks app crashed, tries again → Multiple requests\n- Processing completes but icon stays pulsing → User confused about state\n- Threading crash when clipboard monitor on background thread tries to update icon\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. CLASS DEFINITION:\n```swift\nimport SwiftUI\n\n/// Centralized state manager for menu bar icon appearance and animations.\n/// All state mutations are @MainActor-isolated to ensure thread safety with AppKit NSStatusItem.\n@MainActor\nfinal class MenuBarStateManager: ObservableObject {\n    // MARK: - Published State\n    \n    /// Current operational state of the menu bar icon\n    @Published private(set) var iconState: IconState = .idle\n    \n    /// Animation trigger ID - increment to trigger pulse effect\n    @Published private(set) var pulseID: Int = 0\n    \n    // MARK: - State Types\n    \n    enum IconState: Equatable {\n        case idle           // Normal operation, transformations enabled\n        case disabled       // Transformations disabled by user\n        case processing     // Currently running transformation\n    }\n    \n    // MARK: - Computed Properties\n    \n    /// Icon opacity based on current state\n    var iconOpacity: Double {\n        switch iconState {\n        case .idle, .processing:\n            return 1.0\n        case .disabled:\n            return 0.45\n        }\n    }\n    \n    /// Whether processing is currently active\n    var isProcessing: Bool {\n        iconState == .processing\n    }\n    \n    // MARK: - State Mutations\n    \n    /// Begin processing animation and state\n    /// Called by clipboard monitor when transformation starts\n    func startProcessing() {\n        guard iconState != .disabled else { return }\n        iconState = .processing\n        pulseID += 1  // Increment triggers .symbolEffect(.pulse, value: pulseID)\n    }\n    \n    /// End processing animation and return to idle\n    /// Called when transformation completes (success or failure)\n    func stopProcessing() {\n        guard iconState == .processing else { return }\n        iconState = .idle\n    }\n    \n    /// Toggle disabled state\n    /// Called from Settings when user enables/disables transformations\n    func setDisabled(_ disabled: Bool) {\n        if disabled {\n            iconState = .disabled\n        } else if iconState == .disabled {\n            iconState = .idle\n        }\n    }\n}\n```\n\n2. INTEGRATION WITH APP STRUCT:\n```swift\nimport SwiftUI\nimport MenuBarExtraAccess\n\n@main\nstruct OptimusClipApp: App {\n    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate\n    @StateObject private var menuBarState = MenuBarStateManager()\n    \n    var body: some Scene {\n        MenuBarExtra {\n            MenuBarContentView(menuBarState: menuBarState)\n        } label: {\n            Label(\"Optimus Clip\", systemImage: \"clipboard.fill\")\n                .symbolEffect(.pulse, value: menuBarState.pulseID)\n                .opacity(menuBarState.iconOpacity)\n        }\n        .menuBarExtraStyle(.menu)\n        .menuBarExtraAccess(isInserted: $appDelegate.isMenuBarExtraInserted) { statusItem in\n            // Store reference for future icon customization\n            appDelegate.statusItem = statusItem\n        }\n        \n        Settings {\n            SettingsView(menuBarState: menuBarState)  // Phase 3\n        }\n    }\n}\n```\n\n3. MENU CONTENT VIEW USAGE:\n```swift\nstruct MenuBarContentView: View {\n    @ObservedObject var menuBarState: MenuBarStateManager\n    \n    var body: some View {\n        Button(\"Settings...\") {\n            NSApp.sendAction(Selector((\"showSettingsWindow:\")), to: nil, from: nil)\n        }\n        .keyboardShortcut(\",\", modifiers: .command)\n        \n        Divider()\n        \n        // Show processing status\n        if menuBarState.isProcessing {\n            HStack {\n                ProgressView()\n                    .scaleEffect(0.7)\n                Text(\"Processing...\")\n            }\n            .disabled(true)\n            \n            Divider()\n        }\n        \n        Button(\"Quit\") {\n            NSApplication.shared.terminate(nil)\n        }\n        .keyboardShortcut(\"q\", modifiers: .command)\n    }\n}\n```\n\n4. CLIPBOARD MONITOR INTEGRATION (Phase 2 Preview):\n```swift\nfinal class ClipboardMonitor {\n    private let menuBarState: MenuBarStateManager\n    \n    init(menuBarState: MenuBarStateManager) {\n        self.menuBarState = menuBarState\n    }\n    \n    func processClipboard(with transformation: Transformation) async {\n        // Signal start on main thread\n        await MainActor.run {\n            menuBarState.startProcessing()\n        }\n        \n        do {\n            // Perform transformation (off main thread)\n            let result = try await transformation.process(clipboardText)\n            \n            // Write to clipboard and paste\n            await writeAndPaste(result)\n            \n            // Signal completion on main thread\n            await MainActor.run {\n                menuBarState.stopProcessing()\n            }\n        } catch {\n            // Signal completion even on error\n            await MainActor.run {\n                menuBarState.stopProcessing()\n            }\n        }\n    }\n}\n```\n\n5. SETTINGS INTEGRATION (Phase 3 Preview):\n```swift\nstruct GeneralTabView: View {\n    @ObservedObject var menuBarState: MenuBarStateManager\n    @AppStorage(\"transformations_enabled\") private var transformationsEnabled = true\n    \n    var body: some View {\n        Form {\n            Section(\"Transformations\") {\n                Toggle(\"Enable Transformations\", isOn: $transformationsEnabled)\n                    .onChange(of: transformationsEnabled) { _, newValue in\n                        menuBarState.setDisabled(!newValue)\n                    }\n                \n                Text(\"When disabled, all hotkeys are inactive and clipboard is not monitored\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n        }\n    }\n}\n```\n\nARCHITECTURAL CONNECTIONS:\n- Created in Phase 1 (Menu Bar Shell)\n- Used by Clipboard Monitor in Phase 2 to signal processing\n- Used by Settings window in Phase 3 to toggle disabled state\n- Used by LLM integration in Phase 5 for transformation feedback\n- Passed down through SwiftUI environment/parameter injection\n- @MainActor isolation critical for AppKit NSStatusItem thread safety\n- ObservableObject pattern enables reactive UI updates\n- Single source of truth for icon appearance across app\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. MULTIPLE PROCESSING CALLS:\n   - User spam-presses hotkey while processing\n   - SOLUTION: startProcessing() checks current state, ignores if already processing\n   - Alternative: Disable hotkeys during processing (Phase 3)\n\n2. PROCESSING NEVER STOPS:\n   - LLM request times out but stopProcessing() not called\n   - SOLUTION: Always call stopProcessing() in defer block or finally clause\n   - Add timeout handler that auto-stops after 30 seconds\n\n3. THREAD SAFETY:\n   - Clipboard monitor runs on background queue\n   - SOLUTION: @MainActor on entire class forces all methods to main thread\n   - Use await MainActor.run {} when calling from background context\n\n4. STATE TRANSITIONS DURING DISABLED:\n   - User disables transformations while processing is active\n   - SOLUTION: setDisabled() only transitions from .idle, not from .processing\n   - Processing must complete before disabled state takes effect\n\n5. ANIMATION NOT TRIGGERING:\n   - pulseID increments but icon doesn't pulse\n   - SOLUTION: Ensure .symbolEffect(.pulse, value:) uses the EXACT property\n   - Don't use .symbolEffect(.pulse) without value parameter\n\n6. MEMORY LEAKS:\n   - MenuBarStateManager held by App struct (@StateObject)\n   - Child views use @ObservedObject (not @StateObject)\n   - SOLUTION: Only create @StateObject in App, pass down via parameters\n\n7. SWIFTUI PREVIEW CRASHES:\n   - @MainActor isolation can cause preview issues\n   - SOLUTION: Create mock MenuBarStateManager for previews\n   ```swift\n   #Preview {\n       MenuBarContentView(menuBarState: MenuBarStateManager())\n   }\n   ```\n\n8. PULSE EFFECT ON MACOS 14:\n   - .symbolEffect() requires macOS 15+\n   - SOLUTION: App already requires macOS 15+ (LSMinimumSystemVersion)\n   - No fallback needed, clearly documented in README\n\nTESTING REQUIREMENTS:\n\n1. UNIT TESTS (Swift Testing Framework):\n```swift\nimport Testing\n@testable import OptimusClip\n\n@Suite(\"MenuBarStateManager Tests\")\nstruct MenuBarStateManagerTests {\n    @MainActor\n    @Test(\"Initial state is idle\")\n    func initialState() {\n        let manager = MenuBarStateManager()\n        #expect(manager.iconState == .idle)\n        #expect(manager.pulseID == 0)\n        #expect(manager.iconOpacity == 1.0)\n        #expect(!manager.isProcessing)\n    }\n    \n    @MainActor\n    @Test(\"startProcessing transitions to processing and increments pulseID\")\n    func startProcessing() {\n        let manager = MenuBarStateManager()\n        manager.startProcessing()\n        #expect(manager.iconState == .processing)\n        #expect(manager.pulseID == 1)\n        #expect(manager.isProcessing)\n    }\n    \n    @MainActor\n    @Test(\"stopProcessing returns to idle\")\n    func stopProcessing() {\n        let manager = MenuBarStateManager()\n        manager.startProcessing()\n        manager.stopProcessing()\n        #expect(manager.iconState == .idle)\n        #expect(!manager.isProcessing)\n    }\n    \n    @MainActor\n    @Test(\"setDisabled dims icon opacity\")\n    func setDisabled() {\n        let manager = MenuBarStateManager()\n        manager.setDisabled(true)\n        #expect(manager.iconState == .disabled)\n        #expect(manager.iconOpacity == 0.45)\n    }\n    \n    @MainActor\n    @Test(\"setDisabled(false) returns to idle\")\n    func reEnable() {\n        let manager = MenuBarStateManager()\n        manager.setDisabled(true)\n        manager.setDisabled(false)\n        #expect(manager.iconState == .idle)\n        #expect(manager.iconOpacity == 1.0)\n    }\n    \n    @MainActor\n    @Test(\"startProcessing ignored when disabled\")\n    func noProcessingWhenDisabled() {\n        let manager = MenuBarStateManager()\n        manager.setDisabled(true)\n        manager.startProcessing()\n        #expect(manager.iconState == .disabled)  // Still disabled\n        #expect(manager.pulseID == 0)  // No pulse triggered\n    }\n    \n    @MainActor\n    @Test(\"pulseID increments on each startProcessing\")\n    func multiplePulses() {\n        let manager = MenuBarStateManager()\n        manager.startProcessing()\n        manager.stopProcessing()\n        manager.startProcessing()\n        #expect(manager.pulseID == 2)\n    }\n}\n```\n\n2. INTEGRATION TESTS (Manual):\n- Launch app via pnpm start\n- Verify icon appears in menu bar\n- Call menuBarState.startProcessing() from debugger → Icon pulses\n- Call menuBarState.stopProcessing() → Pulse stops\n- Toggle transformationsEnabled in Settings → Icon dims/brightens\n- No threading crashes or console warnings\n\n3. SWIFTUI PREVIEW TESTS:\n- MenuBarContentView preview renders without crash\n- Mock state manager works in preview context\n- Icon opacity changes visible in preview\n\nSUCCESS CRITERIA:\n- [ ] MenuBarStateManager class compiles without warnings\n- [ ] All unit tests pass (7 test cases)\n- [ ] App launches with icon in menu bar (idle state)\n- [ ] startProcessing() triggers visible pulse animation\n- [ ] stopProcessing() stops pulse and returns to idle\n- [ ] setDisabled(true) dims icon to 45% opacity\n- [ ] setDisabled(false) returns to full opacity\n- [ ] No threading crashes (all state changes on main thread)\n- [ ] SwiftUI previews work with mock manager\n- [ ] isProcessing computed property accurate\n- [ ] Processing ignored when disabled\n\nIMPLEMENTATION ORDER:\n1. Create MenuBarStateManager.swift file\n2. Define IconState enum\n3. Add @Published properties (iconState, pulseID)\n4. Implement computed properties (iconOpacity, isProcessing)\n5. Implement state mutation methods (start/stop/setDisabled)\n6. Add @MainActor isolation to class\n7. Write unit tests\n8. Update App struct to create @StateObject\n9. Pass to MenuBarContentView\n10. Test in running app\n\nCODE ORGANIZATION:\nSources/OptimusClip/Managers/MenuBarStateManager.swift\nTests/OptimusClipTests/MenuBarStateManagerTests.swift\n\nPRIORITY: P1 (Required for icon animation and state management)\n\nESTIMATED TIME: 90 minutes\n- Class implementation: 30 minutes\n- Unit tests: 30 minutes\n- Integration with App struct: 20 minutes\n- Manual testing: 10 minutes\n\nDEPENDENCIES:\n- Phase 1 tasks (App entry point, icon implementation)\n- macOS 15+ for .symbolEffect() API\n- Swift 6.0 for @MainActor isolation\n\nBLOCKS:\n- Phase 1 verification (can't test without state manager)\n- Phase 2 clipboard monitor (needs state manager reference)\n- Phase 3 settings (needs to toggle disabled state)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:07:11.485438-05:00","updated_at":"2025-12-13T09:31:18.564191-05:00","closed_at":"2025-12-13T09:31:18.564191-05:00","dependencies":[{"issue_id":"oc-uzt.6","depends_on_id":"oc-uzt","type":"parent-child","created_at":"2025-12-12T22:07:11.486005-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.6","depends_on_id":"oc-8m8","type":"blocks","created_at":"2025-12-12T22:07:11.486857-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.6","depends_on_id":"oc-uzt.1","type":"blocks","created_at":"2025-12-12T23:54:29.543716-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.6","depends_on_id":"oc-uzt.3","type":"blocks","created_at":"2025-12-12T23:54:34.040274-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-uzt.7","title":"Phase 1 Verification and Integration Testing","description":"BACKGROUND \u0026 CONTEXT:\nPhase 1 Verification is the acceptance gate that confirms all menu bar shell components work together correctly before moving to Phase 2 (Clipboard \u0026 Paste). This is NOT just running tests - it's comprehensive integration validation ensuring the foundation is solid.\n\nWhy verification matters:\n1. **Integration vs. Unit Testing:** Individual tasks may pass their unit tests but fail when combined. Integration testing catches:\n   - Lifecycle coordination issues (delegate setup, MenuBarExtra initialization)\n   - State management flow between components\n   - AppKit/SwiftUI bridging problems\n   - Thread safety violations in production environment\n2. **Phase Dependencies:** Phase 2 (Clipboard Monitor) and Phase 3 (Hotkeys/Settings) build on Phase 1. If menu bar shell is broken, all subsequent work is unstable.\n3. **Platform Quirks:** macOS-specific behaviors only surface in real-world usage:\n   - Single instance enforcement edge cases\n   - Activation policy timing issues\n   - Menu bar icon rendering in different macOS appearances\n   - Keyboard shortcut conflicts with system\n4. **Documentation Accuracy:** Verification catches deviations from spec that need documenting for future developers.\n\nWhat gets tested:\n- App lifecycle (launch, activation, termination)\n- Menu bar presence and appearance\n- Icon state transitions and animations\n- Menu item functionality and keyboard shortcuts\n- Configuration enforcement (single instance, no Dock icon)\n- Dark mode and accessibility compatibility\n- Build/run workflow (pnpm start)\n- Performance baseline (memory, CPU)\n\nREAL-WORLD PROBLEM/USE CASE:\nDeveloper scenario showing why verification catches issues unit tests miss:\n\n**Scenario 1: Launch and Verify Presence**\n1. Developer runs `pnpm start` → App compiles and launches\n2. Checks menu bar → Icon NOT visible\n3. Checks Dock → App appears there instead (WRONG)\n4. Diagnosis: LSUIElement not set correctly in Info.plist\n5. Fix: Verify Info.plist configuration\n6. Rerun verification → Icon now in menu bar, no Dock presence\n\n**Scenario 2: Single Instance Enforcement**\n1. Developer runs `pnpm start` → App launches successfully\n2. Developer double-clicks OptimusClip.app again\n3. Expected: Nothing happens (single instance)\n4. Actual: Second instance launches, both icons in menu bar (BUG)\n5. Diagnosis: LSMultipleInstancesProhibited not working\n6. Fix: Add runtime check in AppDelegate.applicationDidFinishLaunching\n7. Rerun verification → Second launch blocked correctly\n\n**Scenario 3: Icon State Transitions**\n1. Tester opens app → Icon visible at full opacity\n2. Uses debugger to call menuBarState.startProcessing()\n3. Expected: Icon pulses\n4. Actual: Icon disappears (BUG)\n5. Diagnosis: .symbolEffect() modifier breaking with nil value\n6. Fix: Ensure pulseID binding correct in MenuBarExtra label\n7. Rerun verification → Pulse animation works\n\n**Scenario 4: Keyboard Shortcuts**\n1. User clicks menu bar icon → Menu opens\n2. User presses Cmd+Q\n3. Expected: App quits\n4. Actual: Nothing happens (BUG)\n5. Diagnosis: .keyboardShortcut() not working in MenuBarExtra menu\n6. Fix: Use NSMenuItem approach instead of SwiftUI modifier\n7. Rerun verification → Cmd+Q quits app\n\nWithout verification phase:\n- Developer moves to Phase 2 with broken foundation\n- Clipboard monitor written but can't trigger icon state\n- Hours wasted debugging integration issues\n- Forced to backtrack and fix Phase 1 retroactively\n- Project timeline delays cascade\n\nTECHNICAL IMPLEMENTATION DETAILS:\n\n1. MANUAL VERIFICATION CHECKLIST:\nCreate `Tests/Manual/Phase1Checklist.md`:\n```markdown\n# Phase 1 Verification Checklist\n\n## App Launch \u0026 Presence\n- [ ] Run `pnpm start` → App compiles without warnings\n- [ ] Menu bar icon appears (top right, near clock)\n- [ ] Icon uses clipboard.fill SF Symbol\n- [ ] No Dock icon visible (verify visually)\n- [ ] App not in Cmd+Tab switcher (verify by tabbing)\n\n## Single Instance Enforcement\n- [ ] With app running, double-click OptimusClip.app again\n- [ ] Second instance does NOT launch (no second icon)\n- [ ] Run `ps aux | grep OptimusClip` → Only 1 process\n\n## Icon Appearance \u0026 States\n- [ ] Icon at full opacity on launch (idle state)\n- [ ] Icon renders correctly in Light Mode\n- [ ] Icon renders correctly in Dark Mode\n- [ ] Switch macOS appearance → Icon adapts automatically\n\n## Menu Functionality\n- [ ] Click icon → Menu drops down\n- [ ] \"Settings...\" menu item present\n- [ ] \"Quit\" menu item present\n- [ ] Divider between items visible\n\n## Keyboard Shortcuts\n- [ ] With menu open, press Cmd+, → (Settings placeholder for now)\n- [ ] With menu open, press Cmd+Q → App quits immediately\n- [ ] Relaunch and test Cmd+Q from menu bar (not in menu)\n\n## State Manager Integration\n- [ ] In debugger, call `menuBarState.startProcessing()`\n- [ ] Icon pulses with .symbolEffect(.pulse) animation\n- [ ] Call `menuBarState.stopProcessing()`\n- [ ] Pulse stops, icon returns to idle\n- [ ] Call `menuBarState.setDisabled(true)`\n- [ ] Icon dims to ~45% opacity\n- [ ] Call `menuBarState.setDisabled(false)`\n- [ ] Icon returns to full opacity\n\n## Info.plist Configuration\n- [ ] Run `defaults read \u003cpath-to-app\u003e/Contents/Info.plist LSUIElement` → Returns 1\n- [ ] Run `defaults read \u003cpath-to-app\u003e/Contents/Info.plist LSMultipleInstancesProhibited` → Returns 1\n- [ ] Run `defaults read \u003cpath-to-app\u003e/Contents/Info.plist LSMinimumSystemVersion` → Returns 15.0\n\n## Build \u0026 Workflow\n- [ ] `pnpm build` succeeds\n- [ ] `pnpm test` passes (all unit tests)\n- [ ] `pnpm check` passes (format + lint)\n- [ ] `pnpm package` creates OptimusClip.app bundle\n- [ ] `pnpm stop` terminates running instance\n- [ ] `pnpm start` kills old instance and relaunches\n\n## Performance Baseline\n- [ ] Open Activity Monitor → Find OptimusClip\n- [ ] CPU usage \u003c 1% when idle\n- [ ] Memory usage \u003c 50 MB\n- [ ] No excessive thread count (\u003c 10 threads)\n- [ ] Energy Impact: Low\n\n## Accessibility\n- [ ] Enable VoiceOver (Cmd+F5)\n- [ ] Navigate to menu bar icon → VoiceOver reads \"Optimus Clip\"\n- [ ] Open menu → VoiceOver reads menu items\n- [ ] Keyboard navigation works (arrows, Enter, Escape)\n\n## Error Cases\n- [ ] Kill app via Activity Monitor → Terminates cleanly\n- [ ] Force quit via Cmd+Option+Escape → Terminates cleanly\n- [ ] No crash logs in Console.app\n\n## Architecture Validation\n- [ ] MenuBarStateManager is @StateObject in App struct\n- [ ] MenuBarContentView receives manager as @ObservedObject\n- [ ] AppDelegate.statusItem reference populated\n- [ ] No retain cycles (Instruments Leaks profile)\n```\n\n2. AUTOMATED INTEGRATION TESTS:\nCreate `Tests/IntegrationTests/Phase1IntegrationTests.swift`:\n```swift\nimport Testing\nimport AppKit\n@testable import OptimusClip\n\n@Suite(\"Phase 1 Integration Tests\", .tags(.integration))\nstruct Phase1IntegrationTests {\n    @MainActor\n    @Test(\"App launches with menu bar extra\")\n    func appLaunchesWithMenuBar() async {\n        let app = OptimusClipApp()\n        \n        // Launch app in test mode\n        // Note: This is conceptual - actual XCUITest may be needed\n        \n        #expect(NSApp.activationPolicy() == .accessory)\n        // Verify NSStatusItem exists\n        // Verify no Dock icon\n    }\n    \n    @MainActor\n    @Test(\"MenuBarStateManager integration\")\n    func stateManagerIntegration() {\n        let manager = MenuBarStateManager()\n        \n        // Verify state transitions\n        manager.startProcessing()\n        #expect(manager.iconState == .processing)\n        \n        manager.stopProcessing()\n        #expect(manager.iconState == .idle)\n        \n        manager.setDisabled(true)\n        #expect(manager.iconOpacity == 0.45)\n    }\n    \n    @Test(\"Single instance enforcement\")\n    func singleInstanceEnforcement() {\n        // Verify NSRunningApplication count for bundle ID\n        let instances = NSRunningApplication.runningApplications(\n            withBundleIdentifier: \"com.yourname.optimusclip\"\n        )\n        #expect(instances.count == 1)\n    }\n}\n```\n\n3. VERIFICATION SCRIPT:\nCreate `Scripts/verify-phase1.sh`:\n```bash\n#!/usr/bin/env bash\n# Automated Phase 1 verification script\n# Runs before marking phase complete\n\nset -euo pipefail\n\nROOT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\" \u0026\u0026 pwd)\"\n\necho \"🔍 Phase 1 Verification Starting...\"\n\n# 1. Build and Test\necho \"➤ Running build and tests...\"\npnpm build || { echo \"❌ Build failed\"; exit 1; }\npnpm test || { echo \"❌ Tests failed\"; exit 1; }\npnpm check || { echo \"❌ Format/lint failed\"; exit 1; }\n\n# 2. Package app\necho \"➤ Packaging app...\"\npnpm package || { echo \"❌ Packaging failed\"; exit 1; }\n\nAPP_BUNDLE=\"${ROOT_DIR}/OptimusClip.app\"\n[[ -d \"${APP_BUNDLE}\" ]] || { echo \"❌ App bundle not created\"; exit 1; }\n\n# 3. Verify Info.plist settings\necho \"➤ Verifying Info.plist...\"\nLSUIElement=$(defaults read \"${APP_BUNDLE}/Contents/Info.plist\" LSUIElement 2\u003e/dev/null || echo \"0\")\n[[ \"$LSUIElement\" == \"1\" ]] || { echo \"❌ LSUIElement not set\"; exit 1; }\n\nLSMultiple=$(defaults read \"${APP_BUNDLE}/Contents/Info.plist\" LSMultipleInstancesProhibited 2\u003e/dev/null || echo \"0\")\n[[ \"$LSMultiple\" == \"1\" ]] || { echo \"❌ LSMultipleInstancesProhibited not set\"; exit 1; }\n\nMinVersion=$(defaults read \"${APP_BUNDLE}/Contents/Info.plist\" LSMinimumSystemVersion 2\u003e/dev/null || echo \"0\")\n[[ \"$MinVersion\" == \"15.0\" ]] || { echo \"❌ LSMinimumSystemVersion not 15.0\"; exit 1; }\n\n# 4. Kill existing instances\necho \"➤ Cleaning up existing instances...\"\npnpm stop || true\n\n# 5. Launch app\necho \"➤ Launching app...\"\nopen -a \"${APP_BUNDLE}\"\n\n# Wait for launch\nsleep 3\n\n# 6. Verify app is running\nPROCESS_COUNT=$(ps aux | grep -c \"[O]ptimusClip\" || true)\n[[ \"$PROCESS_COUNT\" == \"1\" ]] || { echo \"❌ App not running or multiple instances\"; exit 1; }\n\n# 7. Verify no Dock icon (activation policy)\n# Note: This check is conceptual - may need AppleScript\nosascript \u003c\u003c 'APPLESCRIPT' || { echo \"❌ Activation policy check failed\"; exit 1; }\ntell application \"System Events\"\n    set dockApps to name of every application process whose background only is false\n    if \"OptimusClip\" is in dockApps then\n        error \"OptimusClip should not appear in Dock\"\n    end if\nend tell\nAPPLESCRIPT\n\n# 8. Verify menu bar icon presence\n# Note: This requires Accessibility permission and UI testing\necho \"➤ Verify menu bar icon manually (see checklist)\"\n\n# 9. Memory check\nMEMORY_KB=$(ps aux | grep \"[O]ptimusClip\" | awk '{print $6}' || echo \"0\")\nMEMORY_MB=$((MEMORY_KB / 1024))\n[[ \"$MEMORY_MB\" -lt 100 ]] || { echo \"⚠️  Warning: Memory usage high ($MEMORY_MB MB)\"; }\n\necho \"✅ Automated checks passed!\"\necho \"\"\necho \"📋 Manual verification required:\"\necho \"   1. Check menu bar icon visible\"\necho \"   2. Test icon states (debugger)\"\necho \"   3. Test keyboard shortcuts\"\necho \"   4. Test dark mode compatibility\"\necho \"   5. Complete checklist in Tests/Manual/Phase1Checklist.md\"\necho \"\"\necho \"When all items pass, mark Phase 1 complete and proceed to Phase 2.\"\n```\n\n4. LLDB DEBUGGING SESSION (For State Testing):\n```bash\n# Launch app with debugger attached\nlldb OptimusClip.app/Contents/MacOS/OptimusClip\n\n# Set breakpoint and test state transitions\n(lldb) br set -n main\n(lldb) run\n(lldb) po MenuBarStateManager.shared  # Assuming singleton pattern\n(lldb) expr menuBarState.startProcessing()\n# → Observe icon pulse in menu bar\n(lldb) expr menuBarState.stopProcessing()\n# → Observe pulse stop\n(lldb) expr menuBarState.setDisabled(true)\n# → Observe icon dim\n```\n\nARCHITECTURAL CONNECTIONS:\n- Validates all Phase 1 tasks integrated correctly\n- Blocks Phase 2 start (dependency gate)\n- Establishes performance baseline for future comparison\n- Documents platform quirks discovered during testing\n- Creates manual testing checklist for future phases\n- Verifies Info.plist configuration matches spec\n- Confirms AppKit/SwiftUI bridging stable\n- Validates thread safety of state management\n\nEDGE CASES \u0026 GOTCHAS:\n\n1. MENU BAR ICON NOT VISIBLE:\n   - App launches but icon not in menu bar\n   - DIAGNOSIS: Check Console.app for MenuBarExtra errors\n   - FIX: Verify LSUIElement set, check MenuBarExtra initialization\n\n2. SECOND INSTANCE LAUNCHES:\n   - LSMultipleInstancesProhibited set but second instance still launches\n   - DIAGNOSIS: Info.plist not loaded or runtime override\n   - FIX: Add explicit check in AppDelegate.applicationWillFinishLaunching\n\n3. KEYBOARD SHORTCUTS DON'T WORK:\n   - Cmd+Q or Cmd+, don't trigger actions\n   - DIAGNOSIS: .keyboardShortcut() broken in MenuBarExtra (known SwiftUI issue)\n   - FIX: Use NSMenuItem with keyEquivalent instead\n\n4. ICON PULSE NOT TRIGGERING:\n   - startProcessing() called but no pulse animation\n   - DIAGNOSIS: .symbolEffect(.pulse, value:) not observing pulseID changes\n   - FIX: Ensure @Published property observed, increment triggers update\n\n5. DARK MODE ICON INVISIBLE:\n   - Icon visible in Light Mode but disappears in Dark Mode\n   - DIAGNOSIS: SF Symbol rendering mode incorrect\n   - FIX: Use .renderingMode(.template) to adapt to appearance\n\n6. MEMORY LEAK ON QUIT:\n   - App quits but process lingers\n   - DIAGNOSIS: Retain cycle in MenuBarStateManager or delegate\n   - FIX: Use [weak self] in closures, verify with Instruments\n\n7. ACTIVATION POLICY TIMING:\n   - Setting .accessory policy too late causes Dock icon flash\n   - DIAGNOSIS: Must set in applicationWillFinishLaunching, not didFinishLaunching\n   - FIX: Move to earlier lifecycle hook\n\n8. VOICEOVER NOT READING ICON:\n   - Accessibility label missing\n   - DIAGNOSIS: MenuBarExtra label not providing accessibility info\n   - FIX: Add .accessibilityLabel() modifier\n\nTESTING REQUIREMENTS:\n\n1. AUTOMATED TESTS:\n   - Run `pnpm test` → All unit tests pass\n   - Run `pnpm check` → Format and lint clean\n   - Run `Scripts/verify-phase1.sh` → All automated checks pass\n\n2. MANUAL TESTS:\n   - Complete `Tests/Manual/Phase1Checklist.md` → All items checked\n   - Test in Light Mode and Dark Mode\n   - Test with VoiceOver enabled\n   - Test on clean macOS installation (if possible)\n\n3. PERFORMANCE TESTS:\n   - Memory \u003c 50 MB idle\n   - CPU \u003c 1% idle\n   - Launch time \u003c 2 seconds\n   - No excessive thread creation\n\n4. INTEGRATION TESTS:\n   - App launches and appears in menu bar\n   - Icon states transition correctly\n   - Menu items functional\n   - Keyboard shortcuts work\n   - Single instance enforced\n\nSUCCESS CRITERIA:\n- [ ] All automated checks pass (build, test, lint, package)\n- [ ] App appears in menu bar with correct icon\n- [ ] No Dock icon visible\n- [ ] Single instance enforcement works (second launch blocked)\n- [ ] Icon renders correctly in Light and Dark Mode\n- [ ] Menu opens on click with Settings and Quit items\n- [ ] Cmd+, and Cmd+Q keyboard shortcuts work\n- [ ] MenuBarStateManager state transitions work (idle/disabled/processing)\n- [ ] Icon pulse animation triggers on startProcessing()\n- [ ] Icon dims to 45% opacity when disabled\n- [ ] Info.plist settings verified (LSUIElement, LSMultipleInstancesProhibited, LSMinimumSystemVersion)\n- [ ] Performance baseline acceptable (\u003c 50MB memory, \u003c 1% CPU)\n- [ ] VoiceOver reads menu items correctly\n- [ ] No crashes or errors in Console.app\n- [ ] All Phase 1 tasks marked complete\n- [ ] Manual checklist 100% complete\n- [ ] Architecture validated (state flow, delegate lifecycle)\n- [ ] Documentation updated with any discovered quirks\n\nCONFIGURATION OPTIONS:\n- Verification timeout: 30 seconds for app launch\n- Performance thresholds: \u003c 50MB memory, \u003c 1% CPU\n- Test modes: automated vs. manual vs. full integration\n\nPERFORMANCE CONSIDERATIONS:\n- Launch time should be \u003c 2 seconds\n- Memory footprint \u003c 50MB idle (baseline for Phase 1)\n- No CPU usage when idle (\u003c 0.5%)\n- Icon animation smooth (60 FPS)\n- Menu open latency \u003c 100ms\n\nSECURITY CONSIDERATIONS:\n- Verify app sandbox entitlements (if applicable)\n- Check code signing status (not required for Phase 1 but good practice)\n- Ensure no sensitive data logged to Console.app\n- Validate Info.plist doesn't expose unnecessary permissions\n\nIMPLEMENTATION ORDER:\n1. Create manual checklist (Tests/Manual/Phase1Checklist.md)\n2. Create verification script (Scripts/verify-phase1.sh)\n3. Run automated verification script\n4. Fix any automated check failures\n5. Launch app and work through manual checklist\n6. Test icon state transitions with debugger\n7. Test keyboard shortcuts\n8. Test dark mode compatibility\n9. Test VoiceOver accessibility\n10. Verify performance baseline\n11. Run full integration test suite\n12. Document any discovered issues/quirks\n13. Update AGENTS.md with platform-specific findings\n14. Mark all Phase 1 tasks complete\n15. Create Phase 2 kickoff checklist\n\nCODE ORGANIZATION:\nTests/Manual/Phase1Checklist.md\nTests/IntegrationTests/Phase1IntegrationTests.swift\nScripts/verify-phase1.sh\n\nPRIORITY: P1 (Gates Phase 2 start)\n\nESTIMATED TIME: 120 minutes\n- Automated script creation: 30 minutes\n- Automated test execution: 10 minutes\n- Manual checklist completion: 40 minutes\n- State transition testing: 20 minutes\n- Performance profiling: 10 minutes\n- Documentation: 10 minutes\n\nDEPENDENCIES:\n- All Phase 1 tasks complete (oc-uzt.1 through oc-uzt.6)\n- App successfully builds and runs\n- Unit tests passing\n\nBLOCKS:\n- Phase 2 start (clipboard monitor)\n- Phase 3 start (hotkeys and settings)\n\nCOMMON ISSUES \u0026 SOLUTIONS:\n| Issue | Diagnosis | Solution |\n|-------|-----------|----------|\n| Icon not visible | LSUIElement not set | Verify Info.plist configuration |\n| Second instance launches | Runtime override | Add AppDelegate check |\n| Shortcuts don't work | SwiftUI bug | Use NSMenuItem API |\n| Pulse not animating | Value not observed | Check @Published binding |\n| Dark mode issue | Rendering mode | Use .template mode |\n| Memory leak | Retain cycle | Use weak references |\n\nPOST-VERIFICATION ACTIONS:\n1. Tag commit: `git tag phase-1-complete`\n2. Update project tracker: Mark Phase 1 complete\n3. Create Phase 2 kickoff document\n4. Archive verification results for future reference\n5. Update README with Phase 1 completion status","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T22:07:24.181019-05:00","updated_at":"2025-12-13T09:51:04.983134-05:00","closed_at":"2025-12-13T09:51:04.983134-05:00","dependencies":[{"issue_id":"oc-uzt.7","depends_on_id":"oc-uzt","type":"parent-child","created_at":"2025-12-12T22:07:24.181587-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.7","depends_on_id":"oc-uzt.1","type":"blocks","created_at":"2025-12-12T22:07:24.182265-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.7","depends_on_id":"oc-uzt.2","type":"blocks","created_at":"2025-12-12T22:07:24.182813-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.7","depends_on_id":"oc-uzt.3","type":"blocks","created_at":"2025-12-12T22:07:24.183344-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.7","depends_on_id":"oc-uzt.4","type":"blocks","created_at":"2025-12-12T22:07:24.183867-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.7","depends_on_id":"oc-uzt.5","type":"blocks","created_at":"2025-12-12T22:07:24.184398-05:00","created_by":"daemon","metadata":"{}"},{"issue_id":"oc-uzt.7","depends_on_id":"oc-uzt.6","type":"blocks","created_at":"2025-12-12T22:07:24.18492-05:00","created_by":"daemon","metadata":"{}"}]}
{"id":"oc-ve7","title":"Duplicate withTimeout implementations across codebase","description":"## Problem\nThere are three separate withTimeout implementations:\n- TransformationFlowCoordinator.swift:455-478\n- TransformationPipeline.swift:226-252  \n- LLMTransformation.swift:101-122\n\nAll do similar things but with subtle differences.\n\n## Impact\n- DRY violation\n- Inconsistent behavior across timeout handling\n- Maintenance burden when bugs found\n\n## Fix\nConsolidate into a single utility in OptimusClipCore that all can use.","status":"closed","priority":3,"issue_type":"chore","created_at":"2025-12-16T18:57:37.044195-05:00","updated_at":"2025-12-16T19:42:12.509153-05:00","closed_at":"2025-12-16T19:42:12.509153-05:00","close_reason":"Created shared withTimeout utility in AsyncUtilities.swift, removed duplicates from TransformationPipeline and LLMTransformation"}
{"id":"oc-vjk","title":"Fix LLMTransformation withTimeout build error","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-16T19:41:12.022938-05:00","updated_at":"2025-12-16T20:35:11.299822-05:00","closed_at":"2025-12-16T20:35:11.299822-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T19:44:43.911494-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-vos","title":"Cannot set keyboard shortcut to Cmd+Option+V","description":"KeyboardShortcuts recorder allows setting shortcuts to other keys but blocks Cmd+Option+V (the default). Even after changing to another key combination, cannot change it back to Cmd+Option+V. The UI seems to treat this as a reserved/excluded combination.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-13T21:12:09.258907Z","updated_at":"2025-12-16T09:40:59.713642-05:00","closed_at":"2025-12-16T09:40:59.713642-05:00"}
{"id":"oc-wpk","title":"CODE: Remove debug print() in ProviderSetupStepView.swift","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-16T19:54:53.238678-05:00","updated_at":"2025-12-16T20:35:11.306489-05:00","closed_at":"2025-12-16T20:35:11.306489-05:00","close_reason":"Closing tombstone issues - already resolved","deleted_at":"2025-12-16T20:05:29.863127-05:00","deleted_by":"git-history-backfill","delete_reason":"recovered from git history (pruned from manifest)","original_type":"bug"}
{"id":"oc-yte","title":"Wire LLM runtime to Keychain credentials","description":"Wire runtime LLM consumers to ProviderCredentialsResolver and Keychain-backed APIKeyStore. Scope: add a small factory or wiring layer that pulls creds from Keychain + settings, builds provider clients, and uses them in LLM transformations/model catalog. Ensure strict concurrency compliance, no secrets in logs, and reuse existing resolver. Blocked only by identifying construction points.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-14T22:02:26.803277-05:00","updated_at":"2025-12-14T22:24:15.19493-05:00","closed_at":"2025-12-14T22:24:15.19493-05:00","dependencies":[{"issue_id":"oc-yte","depends_on_id":"oc-l9j.3","type":"discovered-from","created_at":"2025-12-14T22:02:26.804101-05:00","created_by":"daemon","metadata":"{}"}]}
